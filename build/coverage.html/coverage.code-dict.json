{"/home/travis/build/npmtest/node-npmtest-marko/test.js":"/* istanbul instrument in package npmtest_marko */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-marko/lib.npmtest_marko.js":"/* istanbul instrument in package npmtest_marko */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_marko = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_marko = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-marko/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-marko && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_marko */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_marko\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_marko.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_marko.rollup.js'] =\n            local.assetsDict['/assets.npmtest_marko.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_marko.__dirname + '/lib.npmtest_marko.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/index.js":"'use strict';\nrequire('./env-init'); // no-op in the browser, but enables extra features on the server\n\nexports.createOut = require('./createOut');\nexports.load = require('./loader');\nexports.events = require('./events');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/env-init.js":"require('./stream');\nrequire('./dependencies/html');\n\nif (!process.env.BUNDLE) {\n    if (process.env.MARKO_HOT_RELOAD) {\n        require('../hot-reload').enable();\n    }\n\n    // If process was launched with browser refresh then automatically\n    // enable browser-refresh\n    require('../browser-refresh').enable();\n}\n\nfunction fixFlush() {\n    try {\n        var OutgoingMessage = require('http').OutgoingMessage;\n        if (OutgoingMessage.prototype.flush && OutgoingMessage.prototype.flush.toString().indexOf('deprecated') !== -1) {\n            // Yes, we are monkey-patching http. This method should never have been added and it was introduced on\n            // the iojs fork. It was quickly deprecated and I'm 99% sure no one is actually using it.\n            // See:\n            // - https://github.com/marko-js/async-writer/issues/3\n            // - https://github.com/nodejs/node/issues/2920\n            //\n            // This method causes problems since marko looks for the flush method and calls it found.\n            // The `res.flush()` method is introduced by the [compression](https://www.npmjs.com/package/compression)\n            // middleware, but, otherwise, it should typically not exist.\n            delete require('http').OutgoingMessage.prototype.flush;\n        }\n    } catch(e) {}\n}\n\nfixFlush();","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/stream.js":"'use strict';\n/*\nThis module is used to monkey patch `Template.prototype` to add a new `stream(templateData)` method. Since\nthis module is likely not needed in the browser, we have split out the code into a separate module. This module\nis always loaded on the server, but if you need streaming in the browser you must add the following\nline to your app:\n\n    require('marko/stream');\n\n*/\nvar stream = require('stream');\nvar Template = require('./html/Template');\nvar AsyncStream = require('./html/AsyncStream');\n\nfunction Readable(template, data, options) {\n   Readable.$super.call(this);\n   this._t = template;\n   this._d = data;\n   this._shouldBuffer = !options || options.shouldBuffer !== false;\n   this._rendered = false;\n}\n\nReadable.prototype = {\n   write: function(data) {\n       if (data != null) {\n           this.push(data);\n       }\n   },\n   end: function() {\n       this.push(null);\n   },\n   _read: function() {\n       if (this._rendered) {\n           return;\n       }\n\n       this._rendered = true;\n\n       var template = this._t;\n       var data = this._d;\n       var globalData = data && data.$global;\n       var shouldBuffer = this._shouldBuffer;\n       var out = new AsyncStream(globalData, this, null, shouldBuffer);\n       template.render(data, out);\n       out.end();\n   }\n};\n\nrequire('raptor-util/inherit')(Readable, stream.Readable);\n\nTemplate.prototype.stream = function(data) {\n    return new Readable(this, data, this._options);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/Template.js":"'use strict';\nvar AsyncStream = require('./AsyncStream');\nvar makeRenderable = require('../renderable');\n\nfunction Template(path, renderFunc, options) {\n    this.path = path;\n    this._ = renderFunc;\n    this.$__shouldBuffer = !options || options.shouldBuffer !== false;\n    this.meta = undefined;\n}\n\nfunction createOut(globalData, parent, state, buffer) {\n    return new AsyncStream(globalData, parent, state, buffer);\n}\n\nTemplate.prototype = {\n    createOut: createOut,\n    stream: function() {\n        throw new Error('You must require(\"marko/stream\")');\n    }\n};\n\nmakeRenderable(Template.prototype);\n\nmodule.exports = Template;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/AsyncStream.js":"'use strict';\nvar EventEmitter = require('events-light');\nvar StringWriter = require('./StringWriter');\nvar BufferedWriter = require('./BufferedWriter');\nvar defaultDocument = typeof document != 'undefined' && document;\nvar RenderResult = require('../RenderResult');\nvar attrsHelper = require('./helper-attrs');\nvar escapeXml = require('./escape').escapeXml;\n\nvar voidWriter = { write:function(){} };\n\nfunction State(root, stream, writer, events) {\n    this.root = root;\n    this.stream = stream;\n    this.writer = writer;\n    this.events = events;\n\n    this.remaining = 0;\n    this.lastCount = 0;\n    this.last = undefined; // Array\n    this.ended = false;\n    this.finished = false;\n    this.ids = 0;\n}\n\nfunction AsyncStream(global, writer, state, shouldBuffer) {\n    var finalGlobal = this.attributes = global || {};\n    var originalStream;\n\n    if (state) {\n        originalStream = state.stream;\n    } else {\n        var events = finalGlobal.events /* deprecated */ = writer && writer.on ? writer : new EventEmitter();\n\n        if (writer) {\n            originalStream = writer;\n            if (shouldBuffer) {\n                writer = new BufferedWriter(writer);\n            }\n        } else {\n            writer = originalStream = new StringWriter();\n        }\n\n        state = new State(this, originalStream, writer, events);\n    }\n\n    this.global = finalGlobal;\n    this.stream = originalStream;\n    this._state = state;\n\n    this.data = {};\n    this.writer = writer;\n    writer.stream = this;\n\n    this._sync = false;\n    this._stack = undefined;\n    this.name = undefined;\n    this._timeoutId = undefined;\n\n    this._node = undefined;\n\n    this._elStack = undefined; // Array\n\n    this.$c = null; // Component args\n}\n\nAsyncStream.DEFAULT_TIMEOUT = 10000;\nAsyncStream.INCLUDE_STACK = typeof process !== 'undefined' && process.env.NODE_ENV === 'development';\nAsyncStream.enableAsyncStackTrace = function() {\n    AsyncStream.INCLUDE_STACK = true;\n};\n\nvar proto = AsyncStream.prototype = {\n    constructor: AsyncStream,\n    $__document: defaultDocument,\n    $__isOut: true,\n\n    sync: function() {\n        this._sync = true;\n    },\n\n    isSync: function() {\n        return this._sync === true;\n    },\n\n    write: function(str) {\n        if (str != null) {\n            this.writer.write(str.toString());\n        }\n        return this;\n    },\n\n    $__getOutput: function() {\n        return this._state.writer.toString();\n    },\n\n    /**\n     * Legacy...\n     */\n    getOutput: function() {\n        return this.$__getOutput();\n    },\n\n    toString: function() {\n        return this._state.writer.toString();\n    },\n\n    $__getResult: function() {\n        this._result = this._result || new RenderResult(this);\n        return this._result;\n    },\n\n    beginAsync: function(options) {\n        if (this._sync) {\n            throw new Error('beginAsync() not allowed when using renderSync()');\n        }\n\n        var state = this._state;\n\n        var currentWriter = this.writer;\n\n        /* ┏━━━━━┓               this\n           ┃ WAS ┃               ↓↑\n           ┗━━━━━┛  prevWriter → currentWriter → nextWriter  */\n\n        var newWriter = new StringWriter();\n        var newStream = new AsyncStream(this.global, currentWriter, state);\n\n        this.writer = newWriter;\n        newWriter.stream = this;\n\n        newWriter.next = currentWriter.next;\n        currentWriter.next = newWriter;\n\n        /* ┏━━━━━┓               newStream       this\n           ┃ NOW ┃               ↓↑              ↓↑\n           ┗━━━━━┛  prevWriter → currentWriter → newWriter → nextWriter  */\n\n       var timeout;\n       var name;\n\n       state.remaining++;\n\n       if (options != null) {\n           if (typeof options === 'number') {\n               timeout = options;\n           } else {\n               timeout = options.timeout;\n\n               if (options.last === true) {\n                   if (timeout == null) {\n                       // Don't assign a timeout to last flush fragments\n                       // unless it is explicitly given a timeout\n                       timeout = 0;\n                   }\n\n                   state.lastCount++;\n               }\n\n               name = options.name;\n           }\n       }\n\n       if (timeout == null) {\n           timeout = AsyncStream.DEFAULT_TIMEOUT;\n       }\n\n       newStream.stack = AsyncStream.INCLUDE_STACK ? new Error().stack : null;\n       newStream.name = name;\n\n       if (timeout > 0) {\n           newStream._timeoutId = setTimeout(function() {\n               newStream.error(new Error('Async fragment ' + (name ? '(' + name + ') ': '') + 'timed out after ' + timeout + 'ms'));\n           }, timeout);\n       }\n\n       state.events.emit('beginAsync', {\n           writer: newStream, // Legacy\n           parentWriter: this, // Legacy\n           out: newStream,\n           parentOut: this\n       });\n\n        return newStream;\n    },\n\n    end: function(data) {\n        if (data) {\n            this.write(data);\n        }\n\n        var currentWriter = this.writer;\n\n        /* ┏━━━━━┓  this            nextStream\n           ┃ WAS ┃  ↓↑              ↓↑\n           ┗━━━━━┛  currentWriter → nextWriter → futureWriter  */\n\n        // Prevent any more writes to the current steam\n        this.writer = voidWriter;\n        currentWriter.stream = null;\n\n        // Flush the contents of nextWriter to the currentWriter\n        this.flushNext(currentWriter);\n\n        /* ┏━━━━━┓    this        ╵  nextStream\n           ┃     ┃    ↓           ╵  ↓↑\n           ┃ NOW ┃    voidWriter  ╵  currentWriter → futureWriter\n           ┃     ┃  ──────────────┴────────────────────────────────\n           ┗━━━━━┛    Flushed & garbage collected: nextWriter  */\n\n\n       var state = this._state;\n\n       if (state.finished) {\n           return;\n       }\n\n       var remaining;\n\n       if (this === state.root) {\n           remaining = state.remaining;\n           state.ended = true;\n       } else {\n           var timeoutId = this._timeoutId;\n\n           if (timeoutId) {\n               clearTimeout(timeoutId);\n           }\n\n           remaining = --state.remaining;\n       }\n\n       if (state.ended) {\n           if (!state.lastFired && (state.remaining - state.lastCount === 0)) {\n               state.lastFired = true;\n               state.lastCount = 0;\n               state.events.emit('last');\n           }\n\n           if (remaining === 0) {\n               state.finished = true;\n\n               if (state.writer.end) {\n                   state.writer.end();\n               } else {\n                   state.events.emit('finish', this.$__getResult());\n               }\n           }\n       }\n\n       return this;\n    },\n\n    // flushNextOld: function(currentWriter) {\n    //     if (currentWriter === this._state.writer) {\n    //         var nextStream;\n    //         var nextWriter = currentWriter.next;\n    //\n    //         // flush until there is no nextWriter\n    //         // or the nextWriter is still attached\n    //         // to a branch.\n    //         while(nextWriter) {\n    //             currentWriter.write(nextWriter.toString());\n    //             nextStream = nextWriter.stream;\n    //\n    //             if(nextStream) break;\n    //             else nextWriter = nextWriter.next;\n    //         }\n    //\n    //         // Orphan the nextWriter and everything that\n    //         // came before it. They have been flushed.\n    //         currentWriter.next = nextWriter && nextWriter.next;\n    //\n    //         // If there is a nextStream,\n    //         // set its writer to currentWriter\n    //         // (which is the state.writer)\n    //         if(nextStream) {\n    //             nextStream.writer = currentWriter;\n    //             currentWriter.stream = nextStream;\n    //         }\n    //     }\n    // },\n\n    flushNext: function(currentWriter) {\n        // It is possible that currentWriter is the\n        // last writer in the chain, so let's make\n        // sure there is a nextWriter to flush.\n        var nextWriter = currentWriter.next;\n        if (nextWriter) {\n            // Flush the contents of nextWriter\n            // to the currentWriter\n            currentWriter.write(nextWriter.toString());\n\n            // Remove nextWriter from the chain.\n            // It has been flushed and can now be\n            // garbage collected.\n            currentWriter.next = nextWriter.next;\n\n            // It's possible that nextWriter is the last\n            // writer in the chain and its stream already\n            // ended, so let's make sure nextStream exists.\n            var nextStream = nextWriter.stream;\n            if (nextStream) {\n                // Point the nextStream to currentWriter\n                nextStream.writer = currentWriter;\n                currentWriter.stream = nextStream;\n            }\n        }\n    },\n\n    on: function(event, callback) {\n        var state = this._state;\n\n        if (event === 'finish' && state.finished) {\n            callback(this.$__getResult());\n            return this;\n        }\n\n        state.events.on(event, callback);\n        return this;\n    },\n\n    once: function(event, callback) {\n        var state = this._state;\n\n        if (event === 'finish' && state.finished) {\n            callback(this.$__getResult());\n            return this;\n        }\n\n        state.events.once(event, callback);\n        return this;\n    },\n\n    onLast: function(callback) {\n        var state = this._state;\n\n        var lastArray = state.last;\n\n        if (!lastArray) {\n            lastArray = state.last = [];\n            var i = 0;\n            var next = function next() {\n                if (i === lastArray.length) {\n                    return;\n                }\n                var _next = lastArray[i++];\n                _next(next);\n            };\n\n            this.once('last', function() {\n                next();\n            });\n        }\n\n        lastArray.push(callback);\n        return this;\n    },\n\n    emit: function(type, arg) {\n        var events = this._state.events;\n        switch(arguments.length) {\n            case 1:\n                events.emit(type);\n                break;\n            case 2:\n                events.emit(type, arg);\n                break;\n            default:\n                events.emit.apply(events, arguments);\n                break;\n        }\n        return this;\n    },\n\n    removeListener: function() {\n        var events = this._state.events;\n        events.removeListener.apply(events, arguments);\n        return this;\n    },\n\n    prependListener: function() {\n        var events = this._state.events;\n        events.prependListener.apply(events, arguments);\n        return this;\n    },\n\n    pipe: function(stream) {\n        this._state.stream.pipe(stream);\n        return this;\n    },\n\n    error: function(e) {\n        var stack = this._stack;\n        var name = this.name;\n\n        var message;\n\n        if (name) {\n            message = 'Render async fragment error (' + name + ')';\n        } else {\n            message = 'Render error';\n        }\n\n        message += '. Exception: ' + (e.stack || e);\n\n        if (stack) {\n            message += '\\nCreation stack trace: ' + stack;\n        }\n\n        e = new Error(message);\n\n        try {\n            this.emit('error', e);\n        } finally {\n            // If there is no listener for the error event then it will\n            // throw a new here. In order to ensure that the async fragment\n            // is still properly ended we need to put the end() in a `finally`\n            // block\n            this.end();\n        }\n\n        if (console) {\n            console.error(message);\n        }\n\n        return this;\n    },\n\n    flush: function() {\n        var state = this._state;\n\n        if (!state.finished) {\n            var writer = state.writer;\n            if (writer && writer.flush) {\n                writer.flush();\n            }\n        }\n        return this;\n    },\n\n    createOut: function() {\n        return new AsyncStream(this.global);\n    },\n\n    element: function(tagName, elementAttrs, openTagOnly) {\n        var str = '<' + tagName +\n            attrsHelper(elementAttrs) +\n            '>';\n\n        if (openTagOnly !== true) {\n            str += '</' + tagName + '>';\n        }\n\n        this.write(str);\n    },\n\n    beginElement: function(name, elementAttrs) {\n\n        var str = '<' + name +\n            attrsHelper(elementAttrs) +\n            '>';\n\n        this.write(str);\n\n        if (this._elStack) {\n            this._elStack.push(name);\n        } else {\n            this._elStack = [name];\n        }\n    },\n\n    endElement: function() {\n        var tagName = this._elStack.pop();\n        this.write('</' + tagName + '>');\n    },\n\n    text: function(str) {\n        this.write(escapeXml(str));\n    },\n\n    $__getNode: function(doc) {\n        var node = this._node;\n        var curEl;\n        var newBodyEl;\n        var html = this.$__getOutput();\n\n        if (!doc) {\n            doc = this.$__document;\n        }\n\n        if (!node) {\n            if (html) {\n                newBodyEl = doc.createElement('body');\n                newBodyEl.innerHTML = html;\n                if (newBodyEl.childNodes.length == 1) {\n                    // If the rendered component resulted in a single node then just use that node\n                    node = newBodyEl.childNodes[0];\n                } else {\n                    // Otherwise, wrap the nodes in a document fragment node\n                    node = doc.createDocumentFragment();\n                    while ((curEl = newBodyEl.firstChild)) {\n                        node.appendChild(curEl);\n                    }\n                }\n            } else {\n                // empty HTML so use empty document fragment (so that we're returning a valid DOM node)\n                node = doc.createDocumentFragment();\n            }\n            this._node = node;\n        }\n        return node;\n    },\n\n    then: function(fn, fnErr) {\n        var out = this;\n        var promise = new Promise(function(resolve, reject) {\n            out.on('error', reject);\n            out.on('finish', function(result) {\n                resolve(result);\n            });\n        });\n\n        return Promise.resolve(promise).then(fn, fnErr);\n    },\n\n    catch: function(fnErr) {\n        return this.then(undefined, fnErr);\n    }\n};\n\n// alias:\nproto.w = proto.write;\n\nmodule.exports = AsyncStream;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/StringWriter.js":"'use strict';\n\nfunction StringWriter() {\n    this.str = '';\n}\n\nStringWriter.prototype = {\n    write: function(str) {\n        this.str += str;\n        return this;\n    },\n\n    /**\n     * Converts the string buffer into a String.\n     *\n     * @returns {String} The built String\n     */\n    toString: function() {\n        return this.str;\n    }\n};\n\nmodule.exports = StringWriter;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/BufferedWriter.js":"'use strict';\n\n/**\n * Simple wrapper that can be used to wrap a stream\n * to reduce the number of write calls. In Node.js world,\n * each stream.write() becomes a chunk. We can avoid overhead\n * by reducing the number of chunks by buffering the output.\n */\nfunction BufferedWriter(wrappedStream) {\n    this._buffer = '';\n    this._wrapped = wrappedStream;\n}\n\nBufferedWriter.prototype = {\n    write: function(str) {\n        this._buffer += str;\n    },\n\n    flush: function() {\n        if (this._buffer.length !== 0) {\n            this._wrapped.write(this._buffer);\n            this._buffer = '';\n            if (this._wrapped.flush) {\n                this._wrapped.flush();\n            }\n        }\n    },\n\n    end: function() {\n        this.flush();\n        if (!this._wrapped.isTTY) {\n            this._wrapped.end();\n        }\n    },\n\n    clear: function() {\n        this._buffer = '';\n    }\n};\n\nmodule.exports = BufferedWriter;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/RenderResult.js":"var domInsert = require('./dom-insert');\n\nfunction getComponentDefs(result) {\n    var componentDefs = result.$__components;\n\n    if (!componentDefs) {\n        throw Error('No component');\n    }\n    return componentDefs;\n}\n\nfunction RenderResult(out) {\n   this.out = this.$__out = out;\n   this.$__components = undefined;\n}\n\nmodule.exports = RenderResult;\n\nvar proto = RenderResult.prototype = {\n    getComponent: function() {\n        return this.getComponents()[0];\n    },\n    getComponents: function(selector) {\n        if (this.$__components === undefined) {\n            throw Error('Not added to DOM');\n        }\n\n        var componentDefs = getComponentDefs(this);\n\n        var components = [];\n\n        componentDefs.forEach(function(componentDef) {\n            var component = componentDef.$__component;\n            if (!selector || selector(component)) {\n                components.push(component);\n            }\n        });\n\n        return components;\n    },\n\n    afterInsert: function(doc) {\n        var out = this.$__out;\n        var globalComponentsContext = out.global.components;\n        if (globalComponentsContext) {\n            this.$__components = globalComponentsContext.$__initComponents(doc);\n        } else {\n            this.$__components = null;\n        }\n\n        return this;\n    },\n    getNode: function(doc) {\n        return this.$__out.$__getNode(doc);\n    },\n    getOutput: function() {\n        return this.$__out.$__getOutput();\n    },\n    toString: function() {\n        return this.$__out.toString();\n    },\n    document: typeof document != 'undefined' && document\n};\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n    proto,\n    function getEl(renderResult, referenceEl) {\n        return renderResult.getNode(referenceEl.ownerDocument);\n    },\n    function afterInsert(renderResult, referenceEl) {\n        return renderResult.afterInsert(referenceEl.ownerDocument);\n    });\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/dom-insert.js":"var extend = require('raptor-util/extend');\nvar componentsUtil = require('../components/util');\nvar destroyComponentForEl = componentsUtil.$__destroyComponentForEl;\nvar destroyElRecursive = componentsUtil.$__destroyElRecursive;\n\nfunction resolveEl(el) {\n    if (typeof el == 'string') {\n        var elId = el;\n        el = document.getElementById(elId);\n        if (!el) {\n            throw Error('Not found: ' + elId);\n        }\n    }\n    return el;\n}\n\nfunction beforeRemove(referenceEl) {\n    destroyElRecursive(referenceEl);\n    destroyComponentForEl(referenceEl);\n}\n\nmodule.exports = function(target, getEl, afterInsert) {\n    extend(target, {\n        appendTo: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            referenceEl.appendChild(el);\n            return afterInsert(this, referenceEl);\n        },\n        prependTo: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            referenceEl.insertBefore(el, referenceEl.firstChild || null);\n            return afterInsert(this, referenceEl);\n        },\n        replace: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            beforeRemove(referenceEl);\n            referenceEl.parentNode.replaceChild(el, referenceEl);\n            return afterInsert(this, referenceEl);\n        },\n        replaceChildrenOf: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n\n            var curChild = referenceEl.firstChild;\n            while(curChild) {\n                var nextSibling = curChild.nextSibling; // Just in case the DOM changes while removing\n                if (curChild.nodeType == 1) {\n                    beforeRemove(curChild);\n                }\n                curChild = nextSibling;\n            }\n\n            referenceEl.innerHTML = '';\n            referenceEl.appendChild(el);\n            return afterInsert(this, referenceEl);\n        },\n        insertBefore: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            referenceEl.parentNode.insertBefore(el, referenceEl);\n            return afterInsert(this, referenceEl);\n        },\n        insertAfter: function(referenceEl) {\n            referenceEl = resolveEl(referenceEl);\n            var el = getEl(this, referenceEl);\n            el = el;\n            var nextSibling = referenceEl.nextSibling;\n            var parentNode = referenceEl.parentNode;\n            if (nextSibling) {\n                parentNode.insertBefore(el, nextSibling);\n            } else {\n                parentNode.appendChild(el);\n            }\n            return afterInsert(this, referenceEl);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/util.js":"var KEY = Symbol();\nvar isArray = Array.isArray;\n\nfunction UniqueId(out) {\n    this.prefix = out.global.componentIdPrefix || 's'; // \"s\" is for server (we use \"b\" for the browser)\n    this.nextId = 0;\n}\n\nfunction nextComponentId(out) {\n    var global = out.global;\n\n    var idProvider = global[KEY] ||\n        (global[KEY] = new UniqueId(out));\n\n    return idProvider.prefix + (idProvider.nextId++);\n}\n\nfunction attachBubblingEvent(componentDef, handlerMethodName, extraArgs) {\n    if (handlerMethodName) {\n        if (extraArgs) {\n            var bubblingDomEvents = componentDef.$__bubblingDomEvents ||\n                ( componentDef.$__bubblingDomEvents = [] );\n\n            var eventIndex = bubblingDomEvents.length;\n            if (extraArgs.length === 1) {\n                var firstArg = extraArgs[0];\n                if (isArray(firstArg)) {\n                    bubblingDomEvents.push(extraArgs);\n                } else {\n                    bubblingDomEvents.push(firstArg);\n                }\n            } else {\n                bubblingDomEvents.push(extraArgs);\n            }\n\n            return handlerMethodName + ' ' + componentDef.id + ' ' + eventIndex;\n        } else {\n            return handlerMethodName + ' ' + componentDef.id;\n        }\n    }\n}\n\nexports.$__nextComponentId = nextComponentId;\nexports.$__server = true;\nexports.$__attachBubblingEvent = attachBubblingEvent;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/helper-attrs.js":"var attrHelper = require('./helper-attr');\n\nfunction attrs(arg) {\n    if (typeof arg === 'object') {\n        var out = '';\n        for (var attrName in arg) {\n            out += attrHelper(attrName, arg[attrName]);\n        }\n        return out;\n    } else if (typeof arg === 'string') {\n        return arg;\n    }\n    return '';\n}\n\nmodule.exports = attrs;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/helper-attr.js":"var escape = require('./escape');\nvar escapeString = escape.escapeString;\nvar escapeXmlAttr = escape.escapeXmlAttr;\n\nvar stringifiedAttrTest = /[&\\'\\n]/;\nvar stringifiedAttrReplace = /[&\\'\\n]/g;\n\nfunction attr(name, value, shouldEscape) {\n    shouldEscape = shouldEscape !== false;\n    var type = typeof value;\n\n    if (type === 'string') {\n        return ' ' + name + '=\"' + (shouldEscape ? escapeXmlAttr(value) : value) + '\"';\n    } else if (value === true) {\n        return ' ' + name;\n    } else if (value == null || value === false) {\n        return '';\n    } else if (type === 'object') {\n        value = JSON.stringify(value);\n        if (shouldEscape) {\n            value = escapeString(value, stringifiedAttrTest, stringifiedAttrReplace);\n        }\n\n        return ' ' + name + \"='\" + value + \"'\";\n    } else {\n        return ' ' + name + '=' + value; // number (doesn't need quotes)\n    }\n}\n\nmodule.exports = attr;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/escape.js":"var elTest = /[&<]/;\nvar elTestReplace = /[&<]/g;\nvar attrTest = /[&<\\\"\\n]/;\nvar attrReplace = /[&<\\\"\\n]/g;\n\nvar replacements = {\n    '<': '&lt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '\\n': '&#10;' //Preserve new lines so that they don't get normalized as space\n};\n\nfunction replaceChar(match) {\n    return replacements[match];\n}\n\nfunction escapeString(str, regexpTest, regexpReplace) {\n    return regexpTest.test(str) ? str.replace(regexpReplace, replaceChar) : str;\n}\n\nfunction escapeXmlHelper(value, regexpTest, regexpReplace) {\n    // check for most common case first\n    if (typeof value === 'string') {\n        return escapeString(value, regexpTest, regexpReplace);\n    } else if (value == null) {\n        return '';\n    } else if (typeof value === 'object') {\n        if (value.toHTML) {\n            return value.toHTML();\n        }\n    } else if (value === true || value === false || typeof value === 'number') {\n        return value.toString();\n    }\n\n    return escapeString(value.toString(), regexpTest, regexpReplace);\n}\n\nfunction escapeXml(value) {\n    return escapeXmlHelper(value, elTest, elTestReplace);\n}\n\nfunction escapeXmlAttr(value) {\n    return escapeXmlHelper(value, attrTest, attrReplace);\n}\n\nexports.escapeString = escapeString;\nexports.escapeXml = escapeXml;\nexports.escapeXmlAttr = escapeXmlAttr;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/renderable.js":"var defaultCreateOut = require('./createOut');\nvar extend = require('raptor-util/extend');\n\nfunction safeRender(renderFunc, finalData, finalOut, shouldEnd) {\n    try {\n        renderFunc(finalData, finalOut);\n\n        if (shouldEnd) {\n            finalOut.end();\n        }\n    } catch(err) {\n        var actualEnd = finalOut.end;\n        finalOut.end = function() {};\n\n        setTimeout(function() {\n            finalOut.end = actualEnd;\n            finalOut.error(err);\n        }, 0);\n    }\n    return finalOut;\n}\n\nmodule.exports = function(target, renderer) {\n    var renderFunc = renderer && (renderer.renderer || renderer.render || renderer);\n    var createOut = target.createOut || renderer.createOut || defaultCreateOut;\n\n    return extend(target, {\n        createOut: createOut,\n\n        renderToString: function(data, callback) {\n            var localData = data || {};\n            var render = renderFunc || this._;\n            var globalData = localData.$global;\n            var out = createOut(globalData);\n\n            out.global.template = this;\n\n            if (globalData) {\n                localData.$global = undefined;\n            }\n\n            if (callback) {\n                out.on('finish', function() {\n                       callback(null, out.toString(), out);\n                   })\n                   .once('error', callback);\n\n                return safeRender(render, localData, out, true);\n            } else {\n                out.sync();\n                render(localData, out);\n                return out.toString();\n            }\n        },\n\n        renderSync: function(data) {\n            var localData = data || {};\n            var render = renderFunc || this._;\n            var globalData = localData.$global;\n            var out = createOut(globalData);\n            out.sync();\n\n            out.global.template = this;\n\n            if (globalData) {\n                localData.$global = undefined;\n            }\n\n            render(localData, out);\n            return out.$__getResult();\n        },\n\n        /**\n         * Renders a template to either a stream (if the last\n         * argument is a Stream instance) or\n         * provides the output to a callback function (if the last\n         * argument is a Function).\n         *\n         * Supported signatures:\n         *\n         * render(data)\n         * render(data, out)\n         * render(data, stream)\n         * render(data, callback)\n         *\n         * @param  {Object} data The view model data for the template\n         * @param  {AsyncStream/AsyncVDOMBuilder} out A Stream, an AsyncStream/AsyncVDOMBuilder instance, or a callback function\n         * @return {AsyncStream/AsyncVDOMBuilder} Returns the AsyncStream/AsyncVDOMBuilder instance that the template is rendered to\n         */\n        render: function(data, out) {\n            var callback;\n            var finalOut;\n            var finalData;\n            var globalData;\n            var render = renderFunc || this._;\n            var shouldBuffer = this.$__shouldBuffer;\n            var shouldEnd = true;\n\n            if (data) {\n                finalData = data;\n                if ((globalData = data.$global)) {\n                    finalData.$global = undefined;\n                }\n            } else {\n                finalData = {};\n            }\n\n            if (out && out.$__isOut) {\n                finalOut = out;\n                shouldEnd = false;\n                extend(out.global, globalData);\n            } else if (typeof out == 'function') {\n                finalOut = createOut(globalData);\n                callback = out;\n            } else {\n                finalOut = createOut(\n                    globalData, // global\n                    out, // writer(AsyncStream) or parentNode(AsyncVDOMBuilder)\n                    null, // state\n                    shouldBuffer // ignored by AsyncVDOMBuilder\n                );\n            }\n\n            if (callback) {\n                finalOut\n                    .on('finish', function() {\n                        callback(null, finalOut.$__getResult());\n                    })\n                    .once('error', callback);\n            }\n\n            globalData = finalOut.global;\n\n            globalData.template = globalData.template || this;\n\n            return safeRender(render, finalData, finalOut, shouldEnd);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/createOut.js":"var actualCreateOut;\n\nfunction setCreateOut(createOutFunc) {\n    actualCreateOut = createOutFunc;\n}\n\nfunction createOut(globalData) {\n    return actualCreateOut(globalData);\n}\n\ncreateOut.$__setCreateOut = setCreateOut;\n\nmodule.exports = createOut;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/dependencies/html.js":"var patch = require('./').patch;\nvar Template = require('../html/Template');\npatch(Template);\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/dependencies/index.js":"var path = require('path');\nvar defaultResolveFrom = require('resolve-from');\nvar env = process.env.NODE_ENV;\nvar production = !env || env !== 'development';\n\nfunction getDeps(template, context) {\n    if (!template.meta && template.template) {\n        template = template.template;\n    }\n\n    if (typeof template.createOut !== 'function') {\n        return [];\n    }\n\n    if (production && template.deps) {\n        return template.deps;\n    }\n\n    var deps = template.deps = [];\n\n    if (!template.meta) {\n        console.error('Metadata not set for template at ', template.path);\n        return [];\n    }\n\n    var meta = template.meta;\n    var root = path.dirname(template.path);\n\n\n    if (meta.tags) {\n        meta.tags.forEach(tagPath => {\n            var resolveFrom = context.resolveFrom || defaultResolveFrom;\n            var tag = resolveFrom(root, tagPath);\n            var ext = path.extname(tag);\n            var req = context.require || require;\n\n            try {\n                tag = req.resolve(tag.slice(0, 0 - ext.length) + '.js');\n            } catch(e) {}\n\n            var tagDeps = getDeps(req(tag), context);\n            deps.push.apply(deps, tagDeps);\n        });\n    }\n\n    if (meta.deps) {\n        deps.push.apply(deps, meta.deps.map(d => resolveDep(d, root, context)));\n    }\n\n    template.deps = dedupeDeps(deps);\n\n    return deps;\n}\n\nfunction resolveDep(dep, root, context) {\n    if (typeof dep === 'string') {\n        dep = parseDependencyString(dep);\n    }\n\n    if (dep.path) {\n        var resolveFrom = (context && context.resolveFrom) || defaultResolveFrom;\n        dep.path = resolveFrom(root, dep.path);\n\n        if(dep.path && !dep.type) {\n            dep.type = dep.path.slice(dep.path.lastIndexOf('.')+1);\n        }\n    }\n\n    if (dep.virtualPath) {\n        dep.virtualPath = path.resolve(root, dep.virtualPath);\n    }\n\n    return dep;\n}\n\nfunction parseDependencyString(string) {\n    var match = /^(?:([\\w-]+)(?:\\:\\s*|\\s+))?(.*?(?:\\.(\\w+))?)$/.exec(string);\n    return {\n        type: match[1] || match[3],\n        path: match[2]\n    };\n}\n\nfunction dedupeDeps(deps) {\n    return deps;\n}\n\nfunction patch(Template) {\n    Template.prototype.getDependencies = function(context) {\n        context = context || {};\n\n        return getDeps(this, context);\n    };\n}\n\nexports.getDeps = getDeps;\nexports.resolveDep = resolveDep;\nexports.patch = patch;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/browser-refresh/index.js":"var enabled = false;\nvar browserRefreshClient = require('browser-refresh-client');\n\nexports.enable = function() {\n    if (!browserRefreshClient.isBrowserRefreshEnabled()) {\n        return;\n    }\n\n    if (enabled) {\n        return;\n    }\n\n    enabled = true;\n\n    // We set an environment variable so that _all_ marko modules\n    // installed in the project will have browser refresh enabled.\n    process.env.MARKO_BROWSER_REFRESH = 'true';\n\n    var hotReload = require('../hot-reload');\n    hotReload.enable();\n\n    browserRefreshClient\n        .enableSpecialReload('*.marko marko.json marko-tag.json')\n        .onFileModified(function(path) {\n            hotReload.handleFileModified(path);\n        });\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/loader/index.js":"if (process.env.BUNDLE) {\n    // you cannot load templates dynamically within a bundle\n    // all templates should be pre-compiled as part of the bundle\n    module.exports = function(){};\n} else {\n    module.exports = require('./index-default');\n}","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/loader/index-default.js":"'use strict';\n\nvar nodePath = require('path');\nvar fs = require('fs');\nvar Module = require('module').Module;\nvar compilerPath = nodePath.join(__dirname, '../../compiler');\nvar markoCompiler = require(compilerPath);\nvar cwd = process.cwd();\nvar fsOptions = {encoding: 'utf8'};\n\nmodule.exports = function load(templatePath, templateSrc, options) {\n    if (typeof templatePath === 'string' && nodePath.extname(templatePath) === '.js') {\n        // assume compiled template\n        return require(templatePath);\n    }\n\n    if (arguments.length === 1) {\n        return doLoad(templatePath);\n    } else if (arguments.length === 2) {\n        // see if second argument is templateSrc (a String)\n        // or options (an Object)\n        var lastArg = arguments[arguments.length - 1];\n        if (typeof lastArg === 'string') {\n            return doLoad(templatePath, templateSrc);\n        } else {\n            var finalOptions = templateSrc;\n            return doLoad(templatePath, null, finalOptions);\n        }\n    } else if (arguments.length === 3) {\n        // assume function called according to function signature\n        return doLoad(templatePath, templateSrc, options);\n    } else {\n        throw new Error('Illegal arguments');\n    }\n};\n\nfunction loadSource(templatePath, compiledSrc) {\n    templatePath += '.js';\n\n    // Short-circuit loading if the template has already been cached in the Node.js require cache\n    var cached = require.cache[templatePath];\n    if (cached) {\n        return cached.exports;\n    }\n\n    var templateModule = new Module(templatePath, module);\n    templateModule.paths = Module._nodeModulePaths(nodePath.dirname(templatePath));\n    templateModule.filename = templatePath;\n\n    Module._cache[templatePath] = templateModule;\n\n    templateModule._compile(\n        compiledSrc,\n        templatePath);\n\n    return templateModule.exports;\n}\n\nfunction getCachedTemplate(path) {\n    var cached = require.cache[path];\n    return cached && cached.exports.render ? cached.exports : undefined;\n}\n\n/**\n * This helper function will check the Node.js require cache for the previous\n * loaded template and it will also check the disk for the compiled template\n * if `options.assumeUpToDate` is true\n\n * @param  {String} templatePath The fully resolved path to the template\n * @param  {Object} options      The options for the template\n * @return {Template}            The loaded template or undefined\n */\nfunction getPreviousTemplate(templatePath, options) {\n    /*\n    The require.cache is search in the following order:\n    1) /path/to/my-template.js\n    2) /path/to/my-template.marko.js\n    3) /path/to/my-template.marko\n     *\n    If the template is not found in require.cache and `assumeUpToDate` is true\n    then we will check the disk for the precompiled templates in the following\n    order:\n    1) /path/to/my-template.js\n    2) /path/to/my-template.marko.js\n    */\n    var ext = nodePath.extname(templatePath);\n    var targetFilePrecompiled = templatePath.slice(0, 0 - ext.length) + '.js';\n    var targetFileDebug = templatePath + '.js';\n\n    // Short-circuit loading if the template has already been cached in the Node.js require cache\n    var cachedTemplate =\n        getCachedTemplate(targetFilePrecompiled) ||\n        getCachedTemplate(targetFileDebug) ||\n        getCachedTemplate(templatePath);\n\n    if (cachedTemplate) {\n        return cachedTemplate;\n    }\n\n    // Just in case the the path wasn't a fully resolved file system path...\n    templatePath = nodePath.resolve(cwd, templatePath);\n\n    if (options.assumeUpToDate) {\n        if (fs.existsSync(targetFilePrecompiled)) {\n            return require(targetFilePrecompiled);\n        }\n\n        if (fs.existsSync(targetFileDebug)) {\n            return require(targetFileDebug);\n        }\n    }\n\n    return undefined;\n}\n\nfunction createRenderProxy(template) {\n    return function(data, out) {\n        template._(data, out);\n    };\n}\n\nfunction doLoad(templatePath, templateSrc, options) {\n    options = Object.assign({}, markoCompiler.defaultOptions, options);\n\n    var template;\n    if (typeof templatePath.render === 'function') {\n        template = templatePath;\n    } else {\n        templatePath = nodePath.resolve(cwd, templatePath);\n\n        template = getPreviousTemplate(templatePath, options);\n        if (!template) {\n            var writeToDisk = options.writeToDisk;\n\n            if (templateSrc == null) {\n                templateSrc = fs.readFileSync(templatePath, fsOptions);\n            }\n\n            var compiledSrc = markoCompiler.compile(templateSrc, templatePath, options);\n\n            if (writeToDisk === true) {\n                var targetFile = templatePath + '.js';\n                fs.writeFileSync(targetFile, compiledSrc, fsOptions);\n            }\n\n            template = loadSource(templatePath, compiledSrc);\n        }\n    }\n\n    if (options.buffer === false) {\n        var Template = template.constructor;\n\n        template = new Template(\n            template.path,\n            createRenderProxy(template),\n            options);\n    }\n\n    return template;\n}\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/index.js":"'use strict';\n\nvar Compiler = require('./Compiler');\nvar Walker = require('./Walker');\nvar Parser = require('./Parser');\nvar HtmlJsParser = require('./HtmlJsParser');\nvar Builder = require('./Builder');\nvar extend = require('raptor-util/extend');\nvar CompileContext = require('./CompileContext');\nvar globalConfig = require('./config');\nvar CompileContext = require('./CompileContext');\nvar InlineCompiler = require('./InlineCompiler');\nvar ok = require('assert').ok;\nvar fs = require('fs');\nvar taglibLoader = require('./taglib-loader');\n\nvar defaults = extend({}, globalConfig);\n\nObject.defineProperty(exports, 'defaultOptions', {\n    get: function() { return globalConfig;  },\n    enumerable: true,\n    configurable: false\n});\n\nObject.defineProperty(exports, 'config', {\n    get: function() { return globalConfig;  },\n    enumerable: true,\n    configurable: false\n});\n\nvar defaultParser = new Parser(new HtmlJsParser());\nvar rawParser = new Parser(\n    new HtmlJsParser({\n        ignorePlaceholders: true\n    }),\n    {\n        raw: true\n    });\n\nfunction configure(newConfig) {\n    if (!newConfig) {\n        newConfig = {};\n    }\n\n    extend(globalConfig, defaults);\n    extend(globalConfig, newConfig);\n}\n\nvar defaultCompiler = new Compiler({\n    parser: defaultParser,\n    builder: Builder.DEFAULT_BUILDER\n});\n\nfunction createBuilder(options) {\n    return new Builder(options);\n}\n\nfunction createWalker(options) {\n    return new Walker(options);\n}\n\nfunction _compile(src, filename, userOptions, callback) {\n    ok(filename, '\"filename\" argument is required');\n    ok(typeof filename === 'string', '\"filename\" argument should be a string');\n\n    var options = {};\n\n    extend(options, globalConfig);\n\n    if (userOptions) {\n        extend(options, userOptions);\n    }\n\n    var compiler = defaultCompiler;\n\n    var context = new CompileContext(src, filename, compiler.builder, options);\n\n    if (callback) {\n        let compiled;\n\n        try {\n            compiled = compiler.compile(src, context);\n        } catch(e) {\n            return callback(e);\n        }\n\n        callback(null, userOptions.sourceOnly ? compiled.code : compiled);\n    } else {\n        let compiled = compiler.compile(src, context);\n        return userOptions.sourceOnly ? compiled.code : compiled;\n    }\n}\n\nfunction compile(src, filename, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    options = options || {};\n    options.sourceOnly = options.sourceOnly !== false;\n\n    return _compile(src, filename, options, callback);\n}\n\nfunction compileForBrowser(src, filename, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    options = extend({output: 'vdom', meta: false, browser: true, sourceOnly: false}, options);\n\n    return compile(src, filename, options, callback);\n}\n\nfunction compileFile(filename, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    options = options || {};\n    options.sourceOnly = options.sourceOnly !== false;\n\n    if (callback) {\n        fs.readFile(filename, {encoding: 'utf8'}, function(err, templateSrc) {\n            if (err) {\n                return callback(err);\n            }\n\n            _compile(templateSrc, filename, options, callback);\n        });\n    } else {\n        let templateSrc = fs.readFileSync(filename, {encoding: 'utf8'});\n        return _compile(templateSrc, filename, options, callback);\n    }\n}\n\nfunction compileFileForBrowser(filename, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    options = extend({output: 'vdom', meta: false, browser: true, sourceOnly: false}, options);\n    return compileFile(filename, options, callback);\n}\n\n\nfunction createInlineCompiler(filename, userOptions) {\n    var options = {};\n\n    extend(options, globalConfig);\n\n    if (userOptions) {\n        extend(options, userOptions);\n    }\n\n    var compiler = defaultCompiler;\n    var context = new CompileContext('', filename, compiler.builder, options);\n    return new InlineCompiler(context, compiler);\n}\n\nfunction checkUpToDate(templateFile, templateJsFile) {\n    return false; // TODO Implement checkUpToDate\n}\n\nfunction getLastModified(path, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n\n    callback(null, -1); // TODO Implement getLastModified\n}\n\nfunction clearCaches() {\n    exports.taglibLookup.clearCache();\n    exports.taglibFinder.clearCache();\n    exports.taglibLoader.clearCache();\n}\n\nfunction parseRaw(templateSrc, filename) {\n    var context = new CompileContext(templateSrc, filename, Builder.DEFAULT_BUILDER);\n    var parsed = rawParser.parse(templateSrc, context);\n\n    if (context.hasErrors()) {\n        var errors = context.getErrors();\n\n        var message = 'An error occurred while trying to compile template at path \"' + filename + '\". Error(s) in template:\\n';\n        for (var i = 0, len = errors.length; i < len; i++) {\n            let error = errors[i];\n            message += (i + 1) + ') ' + error.toString() + '\\n';\n        }\n        var error = new Error(message);\n        error.errors = errors;\n        throw error;\n    }\n\n    return parsed;\n}\n\nexports.createBuilder = createBuilder;\nexports.compileFile = compileFile;\nexports.compile = compile;\nexports.compileForBrowser = compileForBrowser;\nexports.compileFileForBrowser = compileFileForBrowser;\nexports.parseRaw = parseRaw;\nexports.createInlineCompiler = createInlineCompiler;\n\nexports.checkUpToDate = checkUpToDate;\nexports.getLastModified = getLastModified;\nexports.createWalker = createWalker;\nexports.builder = Builder.DEFAULT_BUILDER;\nexports.configure = configure;\nexports.clearCaches = clearCaches;\n\nvar taglibLookup = require('./taglib-lookup');\nexports.taglibLookup = taglibLookup;\nexports.taglibLoader = taglibLoader;\nexports.taglibFinder = require('./taglib-finder');\n\nfunction buildTaglibLookup(dirname) {\n    return taglibLookup.buildLookup(dirname);\n}\n\nexports.buildTaglibLookup = buildTaglibLookup;\n\nfunction registerTaglib(taglibProps, taglibPath) {\n    var taglib = taglibLoader.createTaglib(taglibPath);\n    taglibLoader.loadTaglibFromProps(taglib, taglibProps);\n    taglibLookup.registerTaglib(taglib);\n}\n\nregisterTaglib(require('../taglibs/core/marko.json'), require.resolve('../taglibs/core/marko.json'));\nregisterTaglib(require('../taglibs/layout/marko.json'), require.resolve('../taglibs/layout/marko.json'));\nregisterTaglib(require('../taglibs/html/marko.json'), require.resolve('../taglibs/html/marko.json'));\nregisterTaglib(require('../taglibs/svg/marko.json'), require.resolve('../taglibs/svg/marko.json'));\nregisterTaglib(require('../taglibs/async/marko.json'), require.resolve('../taglibs/async/marko.json'));\nregisterTaglib(require('../taglibs/cache/marko.json'), require.resolve('../taglibs/cache/marko.json'));\nregisterTaglib(require('../components/taglib/marko.json'), require.resolve('../components/taglib/marko.json'));\n\nexports.registerTaglib = function(filePath) {\n    ok(typeof filePath === 'string', '\"filePath\" shouldbe a string');\n    var taglib = taglibLoader.loadTaglibFromFile(filePath);\n    taglibLookup.registerTaglib(taglib);\n    clearCaches();\n};\n\nexports.isVDOMSupported = true;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/Compiler.js":"'use strict';\nvar ok = require('assert').ok;\nvar path = require('path');\nvar CodeGenerator = require('./CodeGenerator');\nvar CodeWriter = require('./CodeWriter');\nvar createError = require('raptor-util/createError');\nvar resolveDep = require('../runtime/dependencies').resolveDep;\n\nconst FLAG_TRANSFORMER_APPLIED = 'transformerApply';\n\nfunction transformNode(node, context) {\n    try {\n        context.taglibLookup.forEachNodeTransformer(node, function (transformer) {\n            if (node.isDetached()) {\n                return;    //The node might have been removed from the tree\n            }\n            if (!node.isTransformerApplied(transformer)) {\n                //Check to make sure a transformer of a certain type is only applied once to a node\n                node.setTransformerApplied(transformer);\n                //Mark the node as have been transformed by the current transformer\n                context.setFlag(FLAG_TRANSFORMER_APPLIED);\n                //Set the current node\n                context._currentNode = node;\n                //Set the flag to indicate that a node was transformed\n                // node.compiler = this;\n                var transformerFunc = transformer.getFunc();\n                transformerFunc.call(transformer, node, context);    //Have the transformer process the node (NOTE: Just because a node is being processed by the transformer doesn't mean that it has to modify the parse tree)\n            }\n        });\n    } catch (e) {\n        throw createError(new Error('Unable to compile template at path \"' + context.filename + '\". Error: ' + e.message), e);\n    }\n}\n\nfunction transformTreeHelper(node, context) {\n    transformNode(node, context);\n\n    /*\n     * Now process the child nodes by looping over the child nodes\n     * and transforming the subtree recursively\n     *\n     * NOTE: The length of the childNodes array might change as the tree is being performed.\n     *       The checks to prevent transformers from being applied multiple times makes\n     *       sure that this is not a problem.\n     */\n    node.forEachChild(function (childNode) {\n        transformTreeHelper(childNode, context);\n    });\n}\n\nfunction transformTree(rootNode, context) {\n\n    context.taglibLookup.forEachTemplateTransformer((transformer) => {\n        var transformFunc = transformer.getFunc();\n        rootNode = transformFunc(rootNode, context) || rootNode;\n    });\n\n    /*\n     * The tree is continuously transformed until we go through an entire pass where\n     * there were no new nodes that needed to be transformed. This loop makes sure that\n     * nodes added by transformers are also transformed.\n     */\n    do {\n        context.clearFlag(FLAG_TRANSFORMER_APPLIED);\n        //Reset the flag to indicate that no transforms were yet applied to any of the nodes for this pass\n        transformTreeHelper(rootNode, context);    //Run the transforms on the tree\n    } while (context.isFlagSet(FLAG_TRANSFORMER_APPLIED));\n\n    return rootNode;\n}\n\nfunction handleErrors(context) {\n    // If there were any errors then compilation failed.\n    if (context.hasErrors()) {\n        var errors = context.getErrors();\n\n        var message = 'An error occurred while trying to compile template at path \"' + context.filename + '\". Error(s) in template:\\n';\n        for (var i = 0, len = errors.length; i < len; i++) {\n            let error = errors[i];\n            message += (i + 1) + ') ' + error.toString() + '\\n';\n        }\n        var error = new Error(message);\n        error.errors = errors;\n        throw error;\n    }\n}\n\nclass CompiledTemplate {\n    constructor(ast, context, codeGenerator) {\n        this.ast = ast;\n        this.context = context;\n        this.filename = context.filename;\n    }\n\n    get dependencies() {\n        var meta = this.context.meta;\n        if (meta) {\n            var root = path.dirname(this.filename);\n            return (meta.deps || []).map(dep => resolveDep(dep, root));\n        } else {\n            return [];\n        }\n    }\n\n    get code() {\n        // STAGE 3: Generate the code using the final AST\n        handleErrors(this.context);\n\n        // console.log(module.id, 'FINAL AST:' + JSON.stringify(finalAST, null, 4));\n        var codeWriter = new CodeWriter(this.context.options, this.context.builder);\n        codeWriter.write(this.ast);\n\n        handleErrors(this.context);\n\n        // Return the generated code as the compiled output:\n        var compiledSrc = codeWriter.getCode();\n        return compiledSrc;\n    }\n}\n\nclass Compiler {\n    constructor(options, userOptions, inline) {\n        ok(options, '\"options\" is required');\n\n        this.builder = options.builder;\n        this.parser = options.parser;\n\n        ok(this.builder, '\"options.builder\" is required');\n        ok(this.parser, '\"options.parser\" is required');\n    }\n\n    compile(src, context) {\n        ok(typeof src === 'string', '\"src\" argument should be a string');\n\n        var codeGenerator = new CodeGenerator(context);\n\n        // STAGE 1: Parse the template to produce the initial AST\n        var ast = this.parser.parse(src, context);\n        context._parsingFinished = true;\n\n        if (context.unrecognizedTags) {\n            for(let i=0; i<context.unrecognizedTags.length; i++) {\n                let unrecognizedTag = context.unrecognizedTags[i];\n                // See if the tag is a macro\n                if (!context.isMacro(unrecognizedTag.tagName)) {\n                    context.addErrorUnrecognizedTag(unrecognizedTag.tagName, unrecognizedTag.node);\n                }\n            }\n        }\n\n        handleErrors(context);\n\n        context.root = ast;\n        // console.log('ROOT', JSON.stringify(ast, null, 2));\n\n        // STAGE 2: Transform the initial AST to produce the final AST\n        var transformedAST = transformTree(ast, context);\n        // console.log('transformedAST', JSON.stringify(ast, null, 2));\n\n        handleErrors(context);\n\n        var finalAST = codeGenerator.generateCode(transformedAST);\n\n        handleErrors(context);\n\n        return new CompiledTemplate(finalAST, context);\n    }\n}\n\nmodule.exports = Compiler;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/CodeGenerator.js":"'use strict';\n\nconst isArray = Array.isArray;\nconst Node = require('./ast/Node');\nconst Literal = require('./ast/Literal');\nconst Identifier = require('./ast/Identifier');\nconst HtmlElement = require('./ast/HtmlElement');\nconst Html = require('./ast/Html');\nconst ok = require('assert').ok;\nconst Container = require('./ast/Container');\nconst createError = require('raptor-util/createError');\n\nclass GeneratorEvent {\n    constructor(node, codegen) {\n        this.node = node;\n        this.codegen = codegen;\n\n        this.isBefore = true;\n        this.builder = codegen.builder;\n        this.context = codegen.context;\n\n        this.insertedNodes = null;\n    }\n\n    insertCode(newCode) {\n        if (!this.insertedNodes) {\n            this.insertedNodes = [];\n        }\n        this.insertedNodes = this.insertedNodes.concat(newCode);\n    }\n}\n\nclass FinalNodes {\n    constructor() {\n        this.nodes = [];\n        this.nodes._finalNode = true; // Mark the array as a collection of final nodes\n        this.lastNode = null;\n    }\n\n    push(node) {\n        if (!node) {\n            return;\n        }\n\n        if (node instanceof Html) {\n            if (this.lastNode instanceof Html) {\n                this.lastNode.append(node);\n                return;\n            }\n        }\n\n        if (node.setFinalNode) {\n            node.setFinalNode(true);\n        }\n\n        this.lastNode = node;\n        this.nodes.push(node);\n    }\n}\n\nclass CodeGenerator {\n    constructor(context, options) {\n        options = options || {};\n        this.root = null;\n\n        this._code = '';\n        this.currentIndent = '';\n        this.inFunction = false;\n\n        this._doneListeners = [];\n\n\n        this.builder = context.builder;\n\n        this.context = context;\n\n        ok(this.builder, '\"this.builder\" is required');\n\n        this._codegenCodeMethodName = 'generate' +\n            context.outputType.toUpperCase() +\n            'Code';\n    }\n\n    addVar(name, value) {\n        return this.context.addVar(name, value);\n    }\n\n    addStaticVar(name, value) {\n        return this.context.addStaticVar(name, value);\n    }\n\n    addStaticCode(code) {\n        this.context.addStaticCode(code);\n    }\n\n    addDependency(path, type, options) {\n        this.context.addDependency(path, type, options);\n    }\n\n    pushMeta(key, value, unique) {\n        this.context.pushMeta(key, value, unique);\n    }\n\n    setMeta(key, value) {\n        this.context.setMeta(key, value);\n    }\n\n    getEscapeXmlAttrVar() {\n        return this.context.getEscapeXmlAttrVar();\n    }\n\n    importModule(varName, path) {\n        return this.context.importModule(varName, path);\n    }\n\n    _invokeCodeGenerator(func, node, isMethod) {\n        try {\n            if (isMethod) {\n                return func.call(node, this);\n            } else {\n                return func.call(node, node, this);\n            }\n        } catch(err) {\n            var errorMessage = 'Generating code for ';\n\n            if (node instanceof HtmlElement) {\n                errorMessage += '<'+node.tagName+'> tag';\n            } else {\n                errorMessage += node.type + ' node';\n            }\n\n            if (node.pos) {\n                errorMessage += ' ('+this.context.getPosInfo(node.pos)+')';\n            }\n\n            errorMessage += ' failed. Error: ' + err;\n\n            throw createError(errorMessage, err /* cause */);\n        }\n    }\n\n    _generateCode(node, finalNodes) {\n        if (isArray(node)) {\n            node.forEach((child) => {\n                this._generateCode(child, finalNodes);\n            });\n            return;\n        } else if (node instanceof Container) {\n            node.forEach((child) => {\n                if (child.container === node) {\n                    this._generateCode(child, finalNodes);\n                }\n            });\n            return;\n        }\n\n        if (node == null) {\n            return;\n        }\n\n        if (typeof node === 'string' || node._finalNode || !(node instanceof Node)) {\n            finalNodes.push(node);\n            return;\n        }\n\n        if (node._normalizeChildTextNodes) {\n            node._normalizeChildTextNodes(this.context);\n        }\n\n        let oldCurrentNode = this._currentNode;\n        this._currentNode = node;\n\n        var beforeAfterEvent = new GeneratorEvent(node, this);\n\n        var isWhitespacePreserved = node.isPreserveWhitespace();\n\n        if (isWhitespacePreserved) {\n            this.context.beginPreserveWhitespace();\n        }\n\n        beforeAfterEvent.isBefore = true;\n        beforeAfterEvent.node.emit('beforeGenerateCode', beforeAfterEvent);\n        this.context.emit('beforeGenerateCode:' + beforeAfterEvent.node.type, beforeAfterEvent);\n        this.context.emit('beforeGenerateCode', beforeAfterEvent);\n\n        if (beforeAfterEvent.insertedNodes) {\n            this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);\n            beforeAfterEvent.insertedNodes = null;\n        }\n\n        let codeGeneratorFunc;\n        let generatedCode;\n\n        if (node.getCodeGenerator) {\n            codeGeneratorFunc = node.getCodeGenerator(this.outputType);\n\n            if (codeGeneratorFunc) {\n                node.setCodeGenerator(null);\n\n                generatedCode = this._invokeCodeGenerator(codeGeneratorFunc, node, false);\n\n                if (generatedCode === null) {\n                    node = null;\n                } else if (generatedCode !== undefined && generatedCode !== node) {\n                    node = null;\n                    this._generateCode(generatedCode, finalNodes);\n                }\n            }\n        }\n\n        if (node != null) {\n            codeGeneratorFunc = node.generateCode;\n\n            if (!codeGeneratorFunc) {\n                codeGeneratorFunc = node[this._codegenCodeMethodName];\n            }\n\n            if (codeGeneratorFunc) {\n                generatedCode = this._invokeCodeGenerator(codeGeneratorFunc, node, true);\n\n                if (generatedCode === undefined || generatedCode === node) {\n                    finalNodes.push(node);\n                } else if (generatedCode === null) {\n                    // If nothing was returned then don't generate any code\n                } else {\n                    this._generateCode(generatedCode, finalNodes);\n                }\n            } else {\n                finalNodes.push(node);\n            }\n        }\n\n        beforeAfterEvent.isBefore = false;\n        beforeAfterEvent.node.emit('afterGenerateCode', beforeAfterEvent);\n        this.context.emit('afterGenerateCode:' + beforeAfterEvent.node.type, beforeAfterEvent);\n        this.context.emit('afterGenerateCode', beforeAfterEvent);\n\n        if (beforeAfterEvent.insertedNodes) {\n            this._generateCode(beforeAfterEvent.insertedNodes, finalNodes);\n            beforeAfterEvent.insertedNodes = null;\n        }\n\n        if (isWhitespacePreserved) {\n            this.context.endPreserveWhitespace();\n        }\n\n        this._currentNode = oldCurrentNode;\n    }\n\n    generateCode(node) {\n        if (!node) {\n            return null;\n        }\n\n        if (node._finalNode) {\n            return node;\n        }\n\n        let finalNodes = new FinalNodes();\n\n        var isList = typeof node.forEach === 'function';\n\n        this._generateCode(node, finalNodes);\n\n        finalNodes = finalNodes.nodes;\n\n        if (!isList) {\n            if (finalNodes.length === 0) {\n                return null;\n            } else if (finalNodes.length === 1) {\n                return finalNodes[0];\n            }\n        }\n\n        return finalNodes;\n    }\n\n    isLiteralNode(node) {\n        return node instanceof Literal;\n    }\n\n    isIdentifierNode(node) {\n        return node instanceof Identifier;\n    }\n\n    isPreserveWhitespaceEnabled() {\n        return false;\n    }\n\n    addError(message, code) {\n        ok('\"message\" is required');\n\n        let node = this._currentNode;\n\n        if (typeof message === 'object') {\n            let errorInfo = message;\n            errorInfo.node = node;\n            this.context.addError(errorInfo);\n        } else {\n            this.context.addError({node, message, code});\n        }\n    }\n\n    onDone(listenerFunc) {\n        this._doneListeners.push(listenerFunc);\n    }\n\n    getRequirePath(targetFilename) {\n        return this.context.getRequirePath(targetFilename);\n    }\n\n    resolvePath(pathExpression) {\n        return this.context.resolvePath(pathExpression);\n    }\n}\n\nmodule.exports = CodeGenerator;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Node.js":"'use strict';\nvar Container = require('./Container');\nvar ArrayContainer = require('./ArrayContainer');\nvar ok = require('assert').ok;\nvar extend = require('raptor-util/extend');\nvar inspect = require('util').inspect;\nvar EventEmitter = require('events').EventEmitter;\n\nfunction trim(textNode) {\n    if (textNode.preserveWhitespace === true) {\n        return;\n    }\n\n    var text = textNode.argument.value;\n    var isFirst = textNode.isFirst;\n    var isLast = textNode.isLast;\n\n    if (isFirst) {\n        //First child\n        text = text.replace(/^\\r?\\n\\s*/g, '');\n    }\n    if (isLast) {\n        //Last child\n        text = text.replace(/\\r?\\n\\s*$/g, '');\n    }\n    if (/^\\r?\\n\\s*$/.test(text)) {\n        //Whitespace between elements\n        text = '';\n    }\n    text = text.replace(/\\s+/g, ' ');\n    textNode.argument.value = text;\n}\n\nclass Node {\n    constructor(type) {\n        this.type = type;\n        this.statement = false;\n        this.container = null;\n        this.pos = null; // The character index of the node in the original source file\n        this.tagDef = null; // The tag definition associated with this Node\n        this._codeGeneratorFuncs = null;\n        this._flags = {};\n        this._transformersApplied = {};\n        this._preserveWhitespace = null;\n        this._events = null;\n        this._childTextNormalized = undefined;\n        this.data = {};\n        this._finalNode = false;\n        this._trimStartEnd = false;\n    }\n\n    on(event, listener) {\n        if (!this._events) {\n            this._events = new EventEmitter();\n        }\n\n        this._events.on(event, listener);\n    }\n\n    emit(event, args) {\n        if (this._events) {\n            this._events.emit.apply(this._events, arguments);\n        }\n    }\n\n    listenerCount(event) {\n        if (this._events) {\n            return this._events.listenerCount(event);\n        } else {\n            return 0;\n        }\n    }\n\n    onBeforeGenerateCode(listener) {\n        this.on('beforeGenerateCode', listener);\n    }\n\n    onAfterGenerateCode(listener) {\n        this.on('afterGenerateCode', listener);\n    }\n\n    wrapWith(wrapperNode) {\n        ok(this.container, 'Node does not belong to a container: ' + this);\n        var replaced = this.container.replaceChild(wrapperNode, this);\n        ok(replaced, 'Invalid state. Child does not belong to the container');\n        wrapperNode.appendChild(this);\n    }\n\n    replaceWith(newNode) {\n        ok(this.container, 'Node does not belong to a container: ' + this);\n        var replaced = this.container.replaceChild(newNode, this);\n        ok(replaced, 'Invalid state. Child does not belong to the container');\n    }\n\n    insertSiblingBefore(newNode) {\n        ok(this.container, 'Node does not belong to a container: ' + this);\n        this.container.insertChildBefore(newNode, this);\n    }\n\n    insertSiblingAfter(newNode) {\n        ok(this.container, 'Node does not belong to a container: ' + this);\n        this.container.insertChildAfter(newNode, this);\n    }\n\n    /**\n     * Converts the provided `array` into a `ArrayContainer`. If the provided `array` is already an instance of a `Container` then it is simply returned.\n     * @param  {[type]} array [description]\n     * @return {[type]}       [description]\n     */\n    makeContainer(array) {\n        if (array instanceof Container) {\n            return array;\n        }\n\n        return new ArrayContainer(this, array);\n    }\n\n    prependChild(node) {\n        ok(this.body, 'Node does not support child nodes: ' + this);\n        this.body.prependChild(node);\n    }\n\n    appendChild(node) {\n        ok(this.body, 'Node does not support child nodes: ' + this);\n        this.body.appendChild(node);\n    }\n\n    insertBefore(newNode, referenceNode) {\n        ok(this.body, 'Node does not support child nodes: ' + this);\n        this.body.insertBefore(newNode, referenceNode);\n    }\n\n    forEachChild(callback, thisObj) {\n        if (this.body) {\n            this.body.forEach(callback, thisObj);\n        }\n    }\n\n    moveChildrenTo(targetNode) {\n        ok(this.body, 'Node does not support child nodes: ' + this);\n        ok(this !== targetNode, 'Target node cannot be the same as the source node');\n\n        this.body.moveChildrenTo(targetNode);\n    }\n\n    forEachNextSibling(callback, thisObj) {\n        var container = this.container;\n\n        if (container) {\n            container.forEachNextSibling(this, callback, thisObj);\n        }\n    }\n\n    get firstChild() {\n        var body = this.body;\n        return body && body.firstChild;\n    }\n\n    get previousSibling() {\n        var container = this.container;\n\n        if (container) {\n            return container.getPreviousSibling(this);\n        }\n    }\n\n    get nextSibling() {\n        var container = this.container;\n\n        if (container) {\n            return container.getNextSibling(this);\n        }\n    }\n\n    isTransformerApplied(transformer) {\n        return this._transformersApplied[transformer.id] === true;\n    }\n\n    setTransformerApplied(transformer) {\n        this._transformersApplied[transformer.id] = true;\n    }\n\n    toString() {\n        return inspect(this);\n    }\n\n    toJSON() {\n        let result = extend({}, this);\n        delete result.container;\n        delete result.statement;\n        delete result.pos;\n        delete result._transformersApplied;\n        delete result._codeGeneratorFuncs;\n        delete result._flags;\n        delete result.data;\n        delete result.tagDef;\n        delete result._preserveWhitespace;\n        delete result._events;\n        delete result._finalNode;\n        delete result._trimStartEnd;\n        delete result._childTextNormalized;\n        return result;\n    }\n\n    detach() {\n        if (this.container) {\n            this.container.removeChild(this);\n            this.container = null;\n        }\n    }\n\n    /**\n     * Returns true if the current node represents a compound expression (e.g. )\n     * @return {Boolean} [description]\n     */\n    isCompoundExpression() {\n        return false;\n    }\n\n    isDetached() {\n        return this.container == null;\n    }\n\n    /**\n     * Used by the Node.js require('util').inspect function.\n     * We default to inspecting on the simplified version\n     * of this node that is the same version we use when\n     * serializing to JSON.\n     */\n    inspect(depth, opts) {\n        // We inspect in the simplified version of this object t\n        return this.toJSON();\n    }\n\n    setType(newType) {\n        this.type = newType;\n    }\n\n    setCodeGenerator(mode, codeGeneratorFunc) {\n        if (arguments.length === 1) {\n            codeGeneratorFunc = arguments[0];\n            mode = null;\n        }\n\n        if (!this._codeGeneratorFuncs) {\n            this._codeGeneratorFuncs = {};\n        }\n        this._codeGeneratorFuncs[mode || 'DEFAULT'] = codeGeneratorFunc;\n    }\n\n    getCodeGenerator(mode) {\n        if (this._codeGeneratorFuncs) {\n            return this._codeGeneratorFuncs[mode] || this._codeGeneratorFuncs.DEFAULT;\n        } else {\n            return undefined;\n        }\n    }\n\n    setFlag(name) {\n        this._flags[name] = true;\n    }\n\n    clearFlag(name) {\n        delete this._flags[name];\n    }\n\n    isFlagSet(name) {\n        return this._flags.hasOwnProperty(name);\n    }\n\n    get bodyText() {\n        var bodyText = '';\n\n        this.forEachChild((child) => {\n            if (child.type === 'Text') {\n                var childText = child.argument;\n                if (childText && childText.type === 'Literal') {\n                    bodyText += childText.value;\n                }\n            }\n        });\n\n        return bodyText;\n    }\n\n    get parentNode() {\n        return this.container && this.container.node;\n    }\n\n    setPreserveWhitespace(isPreserved) {\n        this._preserveWhitespace = isPreserved;\n    }\n\n    isPreserveWhitespace() {\n        var preserveWhitespace = this._preserveWhitespace;\n        if (preserveWhitespace == null) {\n            preserveWhitespace = this.tagDef && this.tagDef.preserveWhitespace;\n        }\n\n        return preserveWhitespace === true;\n    }\n\n    setFinalNode(isFinal) {\n        this._finalNode = true;\n    }\n\n    setTrimStartEnd(trimStartEnd) {\n        this._trimStartEnd = trimStartEnd;\n    }\n\n    _normalizeChildTextNodes(context, forceTrim) {\n        if (this._childTextNormalized) {\n            return;\n        }\n\n        this._childTextNormalized = true;\n\n        var trimStartEnd = this._trimStartEnd === true;\n\n        var isPreserveWhitespace = false;\n\n        if (!forceTrim) {\n            if (context.isPreserveWhitespace() || this.preserveWhitespace === true || this.isPreserveWhitespace()) {\n                isPreserveWhitespace = true;\n            }\n        }\n\n\n        if (isPreserveWhitespace && trimStartEnd !== true) {\n            return;\n        }\n\n        var body = this.body;\n        if (!body) {\n            return;\n        }\n\n        var isFirst = true;\n\n        var currentTextLiteral = null;\n        var literalTextNodes = [];\n\n        body.forEach((curChild, i) => {\n            if (curChild.noOutput) {\n                // Skip over AST nodes that produce no HTML output\n                return;\n            }\n\n            if (curChild.type === 'Text' && curChild.isLiteral()) {\n                curChild.isFirst  = null;\n                curChild.isLast  = null;\n\n                if (currentTextLiteral &&\n                        currentTextLiteral.preserveWhitespace === curChild.preserveWhitespace &&\n                        currentTextLiteral.escape === curChild.escape) {\n                    currentTextLiteral.argument.value += curChild.argument.value;\n                    curChild.detach();\n                } else {\n                    currentTextLiteral = curChild;\n                    literalTextNodes.push(currentTextLiteral);\n                    if (isFirst) {\n                        currentTextLiteral.isFirst = true;\n                    }\n                }\n            } else {\n                currentTextLiteral = null;\n            }\n\n            isFirst = false;\n        });\n\n        if (currentTextLiteral) {\n            // Last child text\n            currentTextLiteral.isLast = true;\n        }\n\n        if (trimStartEnd) {\n            if (literalTextNodes.length) {\n                // We will only trim the first and last nodes\n                var firstTextNode = literalTextNodes[0];\n                var lastTextNode = literalTextNodes[literalTextNodes.length - 1];\n\n                if (firstTextNode.isFirst) {\n                    firstTextNode.argument.value = firstTextNode.argument.value.replace(/^\\s*/, '');\n                }\n\n                if (lastTextNode.isLast) {\n                    lastTextNode.argument.value = lastTextNode.argument.value.replace(/\\s*$/, '');\n                }\n            }\n        }\n\n        if (!isPreserveWhitespace) {\n            literalTextNodes.forEach(trim);\n        }\n\n        literalTextNodes.forEach((textNode) => {\n            if (textNode.argument.value === '') {\n                textNode.detach();\n            }\n        });\n    }\n\n    get childCount() {\n        ok(this.body, 'Node does not support child nodes: ' + this);\n        return this.body.length;\n    }\n}\n\nmodule.exports = Node;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Container.js":"'use strict';\n\nclass Container {\n    constructor(node) {\n        this.node = node;\n    }\n\n    toJSON() {\n        return this.items;\n    }\n}\n\nmodule.exports = Container;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ArrayContainer.js":"'use strict';\n\nvar ok = require('assert').ok;\nvar isArray = Array.isArray;\nvar Container = require('./Container');\n\nclass ArrayContainer extends Container {\n    constructor(node, array) {\n        super(node);\n        this.items = array;\n    }\n\n    forEach(callback, thisObj) {\n        var array = this.array.concat([]);\n        for (var i=0; i<array.length; i++) {\n            var item = array[i];\n            if (item.container === this) {\n                callback.call(thisObj, item, i);\n            }\n        }\n    }\n\n    replaceChild(newChild, oldChild) {\n        ok(newChild, '\"newChild\" is required\"');\n\n        var array = this.array;\n        var len = array.length;\n        for (var i=0; i<len; i++) {\n            var curChild = array[i];\n            if (curChild === oldChild) {\n                array[i] = newChild;\n                oldChild.detach();\n                newChild.container = this;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    removeChild(child) {\n        var childIndex = this.array.indexOf(child);\n        if (childIndex !== -1) {\n            this.array.splice(childIndex, 1);\n            child.detach();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    prependChild(newChild) {\n        ok(newChild, '\"newChild\" is required\"');\n        this.array.unshift(newChild);\n        newChild.container = this;\n    }\n\n    appendChild(newChild) {\n        ok(newChild, '\"newChild\" is required\"');\n        newChild.detach();\n        this.array.push(newChild);\n        newChild.container = this;\n    }\n\n    insertChildBefore(newChild, referenceNode) {\n        ok(newChild, '\"newChild\" is required\"');\n        ok(referenceNode, 'Invalid reference child');\n\n        var array = this.array;\n        var len = array.length;\n        for (var i=0; i<len; i++) {\n            var curChild = array[i];\n            if (curChild === referenceNode) {\n                array.splice(i, 0, newChild);\n                newChild.container = this;\n                return;\n            }\n        }\n\n        throw new Error('Reference node not found');\n    }\n\n    insertChildAfter(newChild, referenceNode) {\n        ok(newChild, '\"newChild\" is required\"');\n        ok(referenceNode, 'Invalid reference child');\n\n        var array = this.array;\n        var len = array.length;\n        for (var i=0; i<len; i++) {\n            var curChild = array[i];\n            if (curChild === referenceNode) {\n                array.splice(i+1, 0, newChild);\n                newChild.container = this;\n                return;\n            }\n        }\n\n        throw new Error('Reference node not found');\n    }\n\n    moveChildrenTo(target) {\n        ok(target.appendChild, 'Node does not support appendChild(node): ' + target);\n\n        var array = this.array;\n        var len = array.length;\n        for (var i=0; i<len; i++) {\n            var curChild = array[i];\n            curChild.container = null; // Detach the child from this container\n            target.appendChild(curChild);\n        }\n\n        this.array.length = 0; // Clear out this container\n    }\n\n    getPreviousSibling(node) {\n        if (node.container !== this) {\n            throw new Error('Node does not belong to container: ' + node);\n        }\n        var array = this.array;\n\n\n\n        for (var i=0; i<array.length; i++) {\n            var curNode = array[i];\n            if (curNode.container !== this) {\n                continue;\n            }\n\n            if (curNode === node) {\n                return i-1 >= 0 ? array[i-1] : undefined;\n            }\n        }\n    }\n\n    getNextSibling(node) {\n        if (node.container !== this) {\n            throw new Error('Node does not belong to container: ' + node);\n        }\n        var array = this.array;\n\n        for (var i=0; i<array.length; i++) {\n            var curNode = array[i];\n            if (curNode.container !== this) {\n                continue;\n            }\n\n            if (curNode === node) {\n                return i+1 < array.length ? array[i+1] : undefined;\n            }\n        }\n    }\n\n    forEachNextSibling(node, callback, thisObj) {\n        if (node.container !== this) {\n            throw new Error('Node does not belong to container: ' + node);\n        }\n        var array = this.array.concat([]);\n        var found = false;\n\n        for (var i=0; i<array.length; i++) {\n            var curNode = array[i];\n            if (curNode.container !== this) {\n                continue;\n            }\n            if (found) {\n                if (curNode.container === this) {\n                    var keepGoing = callback.call(thisObj, curNode) !== false;\n                    if (!keepGoing) {\n                        return;\n                    }\n                }\n            } else if (curNode === node) {\n                found = true;\n                continue;\n            }\n        }\n    }\n\n    get firstChild() {\n        return this.array[0];\n    }\n\n    get length() {\n        return this.array.length;\n    }\n\n    get items() {\n        return this.array;\n    }\n\n    set items(newItems) {\n        if (newItems) {\n            ok(isArray(newItems), 'Invalid array');\n\n            for (let i=0; i<newItems.length; i++) {\n                newItems[i].container = this;\n            }\n        }\n        this.array = newItems || [];\n    }\n}\n\nmodule.exports = ArrayContainer;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Literal.js":"'use strict';\n\nvar Node = require('./Node');\nvar isArray = Array.isArray;\nconst isValidJavaScriptVarName = require('../util/isValidJavaScriptVarName');\n\nfunction walkValue(value, walker) {\n    if (!value) {\n        return value;\n    } else if (value instanceof Node) {\n        return walker.walk(value);\n    } else if (isArray(value)) {\n        let array = value;\n        for (let i=0; i<array.length; i++) {\n            let el = array[i];\n            array[i] = walkValue(el, walker);\n        }\n        return array;\n    } else if (typeof value === 'object') {\n        let object = value;\n\n        let keys = Object.keys(object);\n        for (let i=0; i<keys.length; i++) {\n            let key = keys[i];\n            let oldValue = object[key];\n            let newValue = walkValue(oldValue, walker);\n            if (newValue !== oldValue) {\n                object[key] = newValue;\n            }\n        }\n\n        return object;\n    } else {\n        return value;\n    }\n}\n\nclass Literal extends Node {\n    constructor(def) {\n        super('Literal');\n        this.value = def.value;\n    }\n\n    generateCode(codegen) {\n        if (this.value != null) {\n            if (isArray(this.value)) {\n                for (var i=0; i<this.value.length; i++) {\n                    this.value[i] = codegen.generateCode(this.value[i]);\n                }\n            } else if (typeof this.value === 'object') {\n                if (!(this.value instanceof RegExp)) {\n                    var newObject = {};\n                    for (var k in this.value) {\n                        if (this.value.hasOwnProperty(k)) {\n                            newObject[k] = codegen.generateCode(this.value[k]);\n                        }\n                    }\n                    this.value = newObject;\n                }\n            }\n        }\n        return this;\n    }\n\n    writeCode(writer) {\n        var value = this.value;\n        writer.writeLiteral(value);\n    }\n\n    toString() {\n        var value = this.value;\n        if (value === null) {\n            return 'null';\n        } else if (value === undefined) {\n            return 'undefined';\n        } else if (typeof value === 'string') {\n            return JSON.stringify(value);\n        } else if (value === true) {\n            return 'true';\n        } else if (value === false) {\n            return 'false';\n        }  else if (isArray(value)) {\n            return '[' + value.join(', ') + ']';\n        } else if (typeof value === 'number') {\n            return value.toString();\n        } else if (value instanceof RegExp) {\n            return value.toString();\n        } else if (typeof value === 'object') {\n            let keys = Object.keys(value);\n            if (keys.length === 0) {\n                return '{}';\n            }\n\n            var result = '{ ';\n\n            for (let i=0; i<keys.length; i++) {\n                let k = keys[i];\n                let v = value[k];\n\n                if (i !== 0) {\n                    result += ', ';\n                }\n\n                if (isValidJavaScriptVarName(k)) {\n                    result += k + ': ';\n                } else {\n                    result += JSON.stringify(k) + ': ';\n                }\n\n                result += v;\n            }\n\n            return result + ' }';\n        }\n    }\n\n    walk(walker) {\n        walkValue(this.value, walker);\n    }\n}\n\nmodule.exports = Literal;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/isValidJavaScriptVarName.js":"var reservedWords = require('./javaScriptReservedWords');\nvar varNameRegExp = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nmodule.exports = function isValidJavaScriptVarName(varName) {\n    if (reservedWords[varName]) {\n        return false;\n    }\n\n    return varNameRegExp.test(varName);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/javaScriptReservedWords.js":"module.exports = {\n    'abstract': true,\n    'arguments': true,\n    'await': true, // Not really a reserved word but we add it here anyway\n    'boolean': true,\n    'break': true,\n    'byte': true,\n    'case': true,\n    'catch': true,\n    'char': true,\n    'class': true,\n    'const': true,\n    'continue': true,\n    'debugger': true,\n    'default': true,\n    'delete': true,\n    'do': true,\n    'double': true,\n    'else': true,\n    'enum*': true,\n    'eval': true,\n    'export': true,\n    'extends': true,\n    'false': true,\n    'final': true,\n    'finally': true,\n    'float': true,\n    'for': true,\n    'function': true,\n    'goto': true,\n    'if': true,\n    'implements': true,\n    'import': true,\n    'in': true,\n    'instanceof': true,\n    'int': true,\n    'interface': true,\n    'let': true,\n    'long': true,\n    'native': true,\n    'new': true,\n    'null': true,\n    'package': true,\n    'private': true,\n    'protected': true,\n    'public': true,\n    'return': true,\n    'short': true,\n    'static': true,\n    'super': true,\n    'switch': true,\n    'synchronized': true,\n    'this': true,\n    'throw': true,\n    'throws': true,\n    'transient': true,\n    'true': true,\n    'try': true,\n    'typeof': true,\n    'var': true,\n    'void': true,\n    'volatile': true,\n    'while': true,\n    'with': true,\n    'yield': true\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Identifier.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass Identifier extends Node {\n    constructor(def) {\n        super('Identifier');\n        this.name = def ? def.name : undefined;\n    }\n\n    generateCode(codegen) {\n        return this;\n    }\n\n    writeCode(writer) {\n        var name = this.name;\n        writer.write(name);\n    }\n\n    toString() {\n        return this.name;\n    }\n}\n\nmodule.exports = Identifier;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/index.js":"'use strict';\n\nvar Node = require('../Node');\nvar Literal = require('../Literal');\nvar HtmlAttributeCollection = require('../HtmlAttributeCollection');\nvar generateHTMLCode = require('./html/generateCode');\nvar generateVDOMCode = require('./vdom/generateCode');\nvar vdomUtil = require('../../util/vdom');\n\nfunction beforeGenerateCode(event) {\n    var tagName = event.node.tagName;\n    var context = event.context;\n\n    var tagDef = typeof tagName === 'string' ? context.getTagDef(tagName) : undefined;\n    if (tagDef && tagDef.htmlType === 'svg') {\n        context.pushFlag('SVG');\n    }\n\n    if (tagName === 'script') {\n        context.pushFlag('SCRIPT_BODY');\n    }\n    if (tagName === 'style') {\n        context.pushFlag('STYLE_BODY');\n    }\n}\n\nfunction afterGenerateCode(event) {\n    var tagName = event.node.tagName;\n    var context = event.context;\n\n    var tagDef = typeof tagName === 'string' ? context.getTagDef(tagName) : undefined;\n\n    if (tagDef && tagDef.htmlType === 'svg') {\n        context.popFlag('SVG');\n    }\n\n    if (tagName === 'script') {\n        context.popFlag('SCRIPT_BODY');\n    }\n    if (tagName === 'style') {\n        context.popFlag('STYLE_BODY');\n    }\n}\n\nclass HtmlElement extends Node {\n    constructor(def) {\n        super('HtmlElement');\n        this.tagName = null;\n        this.tagNameExpression = null;\n        this.setTagName(def.tagName);\n        this.tagString = def.tagString;\n        this._attributes = def.attributes;\n        this._properties = def.properties;\n        this.body = this.makeContainer(def.body);\n        this.argument = def.argument;\n\n        if (!(this._attributes instanceof HtmlAttributeCollection)) {\n            this._attributes = new HtmlAttributeCollection(this._attributes);\n        }\n\n        this.openTagOnly = def.openTagOnly;\n        this.selfClosed = def.selfClosed;\n        this.dynamicAttributes = undefined;\n        this.bodyOnlyIf = undefined;\n\n        this.on('beforeGenerateCode', beforeGenerateCode);\n        this.on('afterGenerateCode', afterGenerateCode);\n    }\n\n    generateHTMLCode(codegen) {\n        if (codegen.context.isMacro(this.tagName)) {\n            // At code generation time, if node tag corresponds to a registered macro\n            // then invoke the macro based on node HTML element instead of generating\n            // the code to render an HTML element.\n            return codegen.builder.invokeMacroFromEl(this);\n        }\n\n        return generateHTMLCode(this, codegen);\n    }\n\n    generateVDOMCode(codegen) {\n        if (codegen.context.isMacro(this.tagName)) {\n            // At code generation time, if node tag corresponds to a registered macro\n            // then invoke the macro based on node HTML element instead of generating\n            // the code to render an HTML element.\n            return codegen.builder.invokeMacroFromEl(this);\n        }\n\n        return generateVDOMCode(this, codegen, vdomUtil);\n    }\n\n    addDynamicAttributes(expression) {\n        if (!this.dynamicAttributes) {\n            this.dynamicAttributes = [];\n        }\n\n        this.dynamicAttributes.push(expression);\n    }\n\n    getAttribute(name) {\n        return this._attributes != null && this._attributes.getAttribute(name);\n    }\n\n    getAttributeValue(name) {\n        var attr = this._attributes != null && this._attributes.getAttribute(name);\n        if (attr) {\n            return attr.value;\n        }\n    }\n\n    addAttribute(attr) {\n        this._attributes.addAttribute(attr);\n    }\n\n    setAttributeValues(attrs) {\n        if (!attrs) {\n            return;\n        }\n\n        for(var attrName in attrs) {\n            var attrValue = attrs[attrName];\n            this.setAttributeValue(attrName, attrValue);\n        }\n    }\n\n    setAttributeValue(name, value, escape) {\n        this._attributes.setAttributeValue(name, value, escape);\n    }\n\n    setPropertyValue(name, value) {\n        if (!this._properties) {\n            this._properties = {};\n        }\n        this._properties[name] = value;\n    }\n\n    getProperties() {\n        return this._properties;\n    }\n\n    replaceAttributes(newAttributes) {\n        this._attributes.replaceAttributes(newAttributes);\n    }\n\n    removeAttribute(name) {\n        if (this._attributes) {\n            this._attributes.removeAttribute(name);\n        }\n    }\n\n    removeAllAttributes() {\n        this._attributes.removeAllAttributes();\n    }\n\n    hasAttribute(name) {\n        return this._attributes != null && this._attributes.hasAttribute(name);\n    }\n\n    getAttributes() {\n        return this._attributes.all;\n    }\n\n    get attributes() {\n        return this._attributes.all;\n    }\n\n    forEachAttribute(callback, thisObj) {\n        var attributes = this._attributes.all.concat([]);\n\n        for (let i=0, len=attributes.length; i<len; i++) {\n            callback.call(thisObj, attributes[i]);\n        }\n    }\n\n    setTagName(tagName) {\n        this.tagName = null;\n        this.tagNameExpression = null;\n\n        if (tagName instanceof Node) {\n            if (tagName instanceof Literal) {\n                this.tagName = tagName.value;\n                this.tagNameExpression = tagName;\n            } else {\n                this.tagNameExpression = tagName;\n            }\n        } else if (typeof tagName === 'string') {\n            this.tagNameExpression = new Literal({value: tagName});\n            this.tagName = tagName;\n        }\n    }\n\n    isLiteralTagName() {\n        return this.tagName != null;\n    }\n\n    toJSON() {\n        return {\n            type: this.type,\n            tagName: this.tagName,\n            attributes: this._attributes,\n            tagString: this.tagString,\n            argument: this.argument,\n            body: this.body,\n            bodyOnlyIf: this.bodyOnlyIf,\n            dynamicAttributes: this.dynamicAttributes\n        };\n    }\n\n    setBodyOnlyIf(condition) {\n        this.bodyOnlyIf = condition;\n    }\n\n    walk(walker) {\n        this.setTagName(walker.walk(this.tagNameExpression));\n        this._attributes.walk(walker);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = HtmlElement;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlAttributeCollection.js":"'use strict';\n\nvar ok = require('assert').ok;\n\nvar HtmlAttribute = require('./HtmlAttribute');\nvar Node = require('./Node');\n\nclass HtmlAttributeCollection {\n    constructor(attributes) {\n        this.replaceAttributes(attributes);\n    }\n\n    addAttribute(newAttr) {\n        if (arguments.length === 2) {\n            let name = arguments[0];\n            let expression = arguments[1];\n            newAttr = new HtmlAttribute(name, expression);\n        } else if (!HtmlAttribute.isHtmlAttribute(newAttr)) {\n            newAttr = new HtmlAttribute(newAttr);\n        }\n\n        var name = newAttr.name;\n\n        if (this.lookup.hasOwnProperty(name)) {\n            for (var i=0; i<this.all.length; i++) {\n                var curAttr = this.all[i];\n                if (curAttr.name === name) {\n                    this.all.splice(i, 1);\n                    break;\n                }\n            }\n        }\n\n        if (name) {\n            this.lookup[name] = newAttr;\n        }\n\n        this.all.push(newAttr);\n    }\n\n    removeAttribute(name) {\n        ok(typeof name === 'string', 'Invalid attribute name');\n\n        if (!this.lookup.hasOwnProperty(name)) {\n            return false;\n        }\n\n        delete this.lookup[name];\n\n        for (var i=0; i<this.all.length; i++) {\n            var curAttr = this.all[i];\n            if (curAttr.name === name) {\n                this.all.splice(i, 1);\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    renameAttribute(oldName, newName) {\n        var key = oldName;\n\n        var attr = this.lookup[key];\n        if (!attr) {\n            return;\n        }\n\n        attr.name = newName;\n        delete this.lookup[key];\n        this.lookup[key] = attr;\n    }\n\n    removeAllAttributes() {\n        this.replaceAttributes([]);\n    }\n\n    hasAttribute(name) {\n        ok(typeof name === 'string', 'Invalid attribute name');\n        return this.lookup.hasOwnProperty(name);\n    }\n\n    hasAttributes() {\n        return this.all.length > 0;\n    }\n\n    getAttribute(name) {\n        return this.lookup[name];\n    }\n\n    setAttributeValue(name, value, escape) {\n        var attr = this.getAttribute(name);\n        if (attr) {\n            attr.value = value;\n            if (typeof escape === 'boolean') {\n                attr.escape = escape;\n            }\n        } else {\n            this.addAttribute({\n                name: name,\n                value: value,\n                escape: escape\n            });\n        }\n    }\n\n    getAttributes() {\n        return this.all;\n    }\n\n    toJSON() {\n        return this.all;\n    }\n\n    toString() {\n        return JSON.stringify(this.all);\n    }\n\n    replaceAttributes(attributes) {\n        this.all = [];\n        this.lookup = {};\n\n        if (attributes) {\n            if (Array.isArray(attributes)) {\n                attributes.forEach((attr) => {\n                    this.addAttribute(attr);\n                });\n            } else {\n                for (var attrName in attributes) {\n                    if (attributes.hasOwnProperty(attrName)) {\n                        let attrValue = attributes[attrName];\n                        let attrDef;\n\n                        if (attrValue != null && typeof attrValue === 'object' && !(attrValue instanceof Node)) {\n                            attrDef = attrValue;\n                            attrDef.name = attrName;\n                        } else {\n                            attrDef = {\n                                name: attrName,\n                                value: attrValue\n                            };\n                        }\n\n                        this.addAttribute(attrDef);\n                    }\n                }\n            }\n        }\n    }\n\n    walk(walker) {\n        var newAttributes = walker.walk(this.all);\n        this.replaceAttributes(newAttributes);\n    }\n}\n\nmodule.exports = HtmlAttributeCollection;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlAttribute/index.js":"'use strict';\n\nvar Node = require('../Node');\nvar Literal = require('../Literal');\nvar ok = require('assert').ok;\nvar compiler = require('../../');\nvar generateHTMLCode = require('./html/generateCode');\nvar generateVDOMCode = require('./vdom/generateCode');\nvar vdomUtil = require('../../util/vdom');\n\nfunction beforeGenerateCode(event) {\n    event.codegen.isInAttribute = true;\n}\n\nfunction afterGenerateCode(event) {\n    event.codegen.isInAttribute = false;\n}\n\nclass HtmlAttribute extends Node {\n    constructor(def) {\n        super('HtmlAttribute');\n\n        ok(def, 'Invalid attribute definition');\n        this.type = 'HtmlAttribute';\n        this.name = def.name;\n        this.value = def.value;\n        this.rawValue = def.rawValue;\n        this.escape = def.escape;\n\n        if (typeof this.value === 'string') {\n            this.value = compiler.builder.parseExpression(this.value);\n        }\n\n        if (this.value && !(this.value instanceof Node)) {\n            throw new Error('\"value\" should be a Node instance');\n        }\n\n        this.argument = def.argument;\n\n        this.def = def.def; // The attribute definition loaded from the taglib (if any)\n\n        this.on('beforeGenerateCode', beforeGenerateCode);\n        this.on('afterGenerateCode', afterGenerateCode);\n    }\n\n    generateHTMLCode(codegen) {\n        return generateHTMLCode(this, codegen);\n    }\n\n    generateVDOMCode(codegen) {\n        return generateVDOMCode(this, codegen, vdomUtil);\n    }\n\n    isLiteralValue() {\n        return this.value instanceof Literal;\n    }\n\n    isLiteralString() {\n        return this.isLiteralValue() &&\n            typeof this.value.value === 'string';\n    }\n\n    isLiteralBoolean() {\n        return this.isLiteralValue() &&\n            typeof this.value.value === 'boolean';\n    }\n\n    walk(walker) {\n        this.value = walker.walk(this.value);\n    }\n\n    get literalValue() {\n        if (this.isLiteralValue()) {\n            return this.value.value;\n        } else {\n            throw new Error('Attribute value is not a literal value. Actual: ' + JSON.stringify(this.value, null, 2));\n        }\n    }\n}\n\nHtmlAttribute.isHtmlAttribute = function(attr) {\n    return (attr instanceof HtmlAttribute);\n};\n\nmodule.exports = HtmlAttribute;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlAttribute/html/generateCode.js":"'use strict';\n\nvar runtimeHtmlHelpers = require('../../../../runtime/html/helpers');\nvar attr = runtimeHtmlHelpers.a;\nvar escapeXmlAttr = runtimeHtmlHelpers.xa;\n\nfunction isStringLiteral(node) {\n    return node.type === 'Literal' && typeof node.value === 'string';\n}\n\nfunction isNoEscapeXml(node) {\n    return node.type === 'AttributePlaceholder' &&\n        node.escape === false;\n}\n\nfunction flattenAttrConcats(node) {\n    // return [node];\n\n    function flattenHelper(node) {\n        if (node.type === 'BinaryExpression' && node.operator === '+') {\n            let left = flattenHelper(node.left);\n            let right = flattenHelper(node.right);\n\n            var isString = left.isString || right.isString;\n\n            if (isString) {\n                return {\n                    isString: true,\n                    concats: left.concats.concat(right.concats)\n                };\n            } else {\n                return {\n                    isString: false,\n                    concats: [node]\n                };\n            }\n\n        }\n\n        return {\n            isString: isStringLiteral(node) || node.type === 'AttributePlaceholder',\n            concats: [node]\n        };\n    }\n\n    var final = flattenHelper(node);\n    return final.concats;\n}\n\nfunction generateCodeForExpressionAttr(name, value, escape, codegen) {\n    var flattenedConcats = flattenAttrConcats(value);\n\n    var hasLiteral = false;\n    var builder = codegen.builder;\n    var finalNodes = [];\n    var context = codegen.context;\n\n    function addHtml(argument) {\n        finalNodes.push(builder.html(argument));\n    }\n\n    function addHtmlLiteral(value) {\n        finalNodes.push(builder.htmlLiteral(value));\n    }\n\n\n    for (let i=0; i<flattenedConcats.length; i++) {\n        if (flattenedConcats[i].type === 'Literal' || flattenedConcats[i].type === 'AttributePlaceholder') {\n            hasLiteral = true;\n            break;\n        }\n    }\n\n    if (hasLiteral) {\n        addHtmlLiteral(' ' + name + '=\"');\n        for (let i=0; i<flattenedConcats.length; i++) {\n            var part = flattenedConcats[i];\n            if (isStringLiteral(part)) {\n                part.value = escapeXmlAttr(part.value);\n            } else if (part.type === 'Literal') {\n            } else if (isNoEscapeXml(part)) {\n                part = codegen.builder.functionCall(context.helper('str'), [part]);\n            } else {\n                if (escape !== false) {\n                    part = builder.functionCall(context.helper('escapeXmlAttr'), [part]);\n                }\n            }\n            addHtml(part);\n        }\n        addHtmlLiteral('\"');\n    } else {\n        if (name === 'class') {\n            addHtml(codegen.builder.functionCall(context.helper('classAttr'), [value]));\n        } else if (name === 'style') {\n            addHtml(codegen.builder.functionCall(context.helper('styleAttr'), [value]));\n        } else {\n            if (escape === false || isNoEscapeXml(value)) {\n                escape = false;\n            }\n\n            let attrArgs = [codegen.builder.literal(name), value];\n\n            if (escape === false) {\n                attrArgs.push(codegen.builder.literal(false));\n            }\n\n            addHtml(codegen.builder.functionCall(context.helper('attr'), attrArgs));\n        }\n    }\n\n    return finalNodes;\n}\n\nmodule.exports = function generateCode(node, codegen) {\n    let name = node.name;\n    let value = node.value;\n    let argument = node.argument;\n    let escape = node.escape !== false;\n    var builder = codegen.builder;\n\n    if (!name) {\n        return null;\n    }\n\n    if (node.isLiteralValue()) {\n        let literalValue = value.value;\n\n        if (literalValue instanceof RegExp) {\n            literalValue = literalValue.source;\n        }\n\n        return builder.htmlLiteral(attr(name, literalValue));\n    } else if (value != null) {\n        return generateCodeForExpressionAttr(name, value, escape, codegen);\n    } else if (argument) {\n        return [\n            builder.htmlLiteral(' ' + name + '('),\n            builder.htmlLiteral(argument),\n            builder.htmlLiteral(')')\n        ];\n    } else {\n        // Attribute with no value is a boolean attribute\n        return builder.htmlLiteral(' ' + name);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/helpers.js":"'use strict';\nvar extend = require('raptor-util/extend');\n\nvar STYLE_ATTR = 'style';\nvar CLASS_ATTR = 'class';\n\nvar escape = require('./escape');\nvar escapeXml = escape.escapeXml;\nvar escapeXmlAttr = escape.escapeXmlAttr;\nvar attrHelper = require('./helper-attr');\nvar attrsHelper = require('./helper-attrs');\n\nvar classList;\n\n\n\n\n\n\n/**\n * Internal method to escape special XML characters\n * @private\n */\nexports.x = escapeXml;\n/**\n * Internal method to escape special XML characters within an attribute\n * @private\n */\nexports.xa = escapeXmlAttr;\n\n/**\n * Escapes the '</' sequence in the body of a <script> body to avoid the `<script>` being\n * ended prematurely.\n *\n * For example:\n * var evil = {\n * \tname:  '</script><script>alert(1)</script>'\n * };\n *\n * <script>var foo = ${JSON.stringify(evil)}</script>\n *\n * Without escaping the ending '</script>' sequence the opening <script> tag would be\n * prematurely ended and a new script tag could then be started that could then execute\n * arbitrary code.\n */\nvar escapeEndingScriptTagRegExp = /<\\/script/g;\nexports.xs = function escapeScriptHelper(val) {\n    return (typeof val === 'string') ? val.replace(escapeEndingScriptTagRegExp, '\\\\u003C/script') : val;\n};\n\n/**\n * Escapes the '</' sequence in the body of a <style> body to avoid the `<style>` being\n * ended prematurely.\n *\n * For example:\n * var color = '</style><script>alert(1)</script>';\n *\n * <style>#foo { background-color:${color} }</style>\n *\n * Without escaping the ending '</style>' sequence the opening <style> tag would be\n * prematurely ended and a script tag could then be started that could then execute\n * arbitrary code.\n */\nvar escapeEndingStyleTagRegExp = /<\\/style/g;\nexports.xc = function escapeScriptHelper(val) {\n    return (typeof val === 'string') ? val.replace(escapeEndingStyleTagRegExp, '\\\\003C/style') : val;\n};\n\n/**\n * Internal method to render a single HTML attribute\n * @private\n */\nexports.a = attrHelper;\n\n/**\n * Internal method to render multiple HTML attributes based on the properties of an object\n * @private\n */\nexports.as = attrsHelper;\n\n/**\n * Internal helper method to handle the \"style\" attribute. The value can either\n * be a string or an object with style propertes. For example:\n *\n * sa('color: red; font-weight: bold') ==> ' style=\"color: red; font-weight: bold\"'\n * sa({color: 'red', 'font-weight': 'bold'}) ==> ' style=\"color: red; font-weight: bold\"'\n */\n\nvar dashedNames = {};\n\nexports.sa = function(style) {\n    if (!style) {\n        return '';\n    }\n\n    var type = typeof style;\n\n    if (type === 'string') {\n        return attrHelper(STYLE_ATTR, style, false);\n    } else if (type === 'object') {\n        var styles = '';\n        for (var name in style) {\n            var value = style[name];\n            if (value != null) {\n                if (typeof value === 'number' && value) {\n                    value += 'px';\n                }\n                var nameDashed = dashedNames[name];\n                if (!nameDashed) {\n                    nameDashed = dashedNames[name] = name.replace(/([A-Z])/g, '-$1').toLowerCase();\n                }\n                styles += nameDashed + ':' + value + ';';\n            }\n        }\n        return styles ? ' ' + STYLE_ATTR + '=\"' + styles +'\"' : '';\n    } else {\n        return '';\n    }\n};\n\n/**\n * Internal helper method to handle the \"class\" attribute. The value can either\n * be a string, an array or an object. For example:\n *\n * ca('foo bar') ==> ' class=\"foo bar\"'\n * ca({foo: true, bar: false, baz: true}) ==> ' class=\"foo baz\"'\n * ca(['foo', 'bar']) ==> ' class=\"foo bar\"'\n */\nexports.ca = function(classNames) {\n    if (!classNames) {\n        return '';\n    }\n\n    if (typeof classNames === 'string') {\n        return attrHelper(CLASS_ATTR, classNames, false);\n    } else {\n        return attrHelper(CLASS_ATTR, classList(classNames), false);\n    }\n};\n\n\nfunction classList(arg) {\n    var len, name, value, str = '';\n\n    if (arg) {\n        if (typeof arg === 'string') {\n            if (arg) {\n                str += ' ' + arg;\n            }\n        } else if (typeof (len = arg.length) === 'number') {\n            for (var i=0; i<len; i++) {\n                value = classList(arg[i]);\n                if (value) {\n                    str += ' ' + value;\n                }\n            }\n        } else if (typeof arg === 'object') {\n            for (name in arg) {\n                value = arg[name];\n                if (value) {\n                    str += ' ' + name;\n                }\n            }\n        }\n    }\n\n    return (str && str.slice(1)) || null;\n}\n\nvar commonHelpers = require('../helpers');\nextend(exports, commonHelpers);\nexports.cl = classList;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helpers.js":"'use strict';\nvar isArray = Array.isArray;\n\nfunction isFunction(arg) {\n    return typeof arg == 'function';\n}\n\nfunction classList(arg, classNames) {\n    var len;\n\n    if (arg) {\n        if (typeof arg == 'string') {\n            if (arg) {\n                classNames.push(arg);\n            }\n        } else if (typeof (len = arg.length) == 'number') {\n            for (var i=0; i<len; i++) {\n                classList(arg[i], classNames);\n            }\n        } else if (typeof arg == 'object') {\n            for (var name in arg) {\n                if (arg.hasOwnProperty(name)) {\n                    var value = arg[name];\n                    if (value) {\n                        classNames.push(name);\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction createDeferredRenderer(handler) {\n    function deferredRenderer(input, out) {\n        deferredRenderer.renderer(input, out);\n    }\n\n    // This is the initial function that will do the rendering. We replace\n    // the renderer with the actual renderer func on the first render\n    deferredRenderer.renderer = function(input, out) {\n        var rendererFunc = handler.renderer || handler._ || handler.render;\n        if (!isFunction(rendererFunc)) {\n            throw Error('Invalid renderer');\n        }\n        // Use the actual renderer from now on\n        deferredRenderer.renderer = rendererFunc;\n        rendererFunc(input, out);\n    };\n\n    return deferredRenderer;\n}\n\nfunction resolveRenderer(handler) {\n    var renderer = handler.renderer || handler._;\n\n    if (renderer) {\n        return renderer;\n    }\n\n    if (isFunction(handler)) {\n        return handler;\n    }\n\n    // If the user code has a circular function then the renderer function\n    // may not be available on the module. Since we can't get a reference\n    // to the actual renderer(input, out) function right now we lazily\n    // try to get access to it later.\n    return createDeferredRenderer(handler);\n}\n\n/**\n * Internal helper method to prevent null/undefined from being written out\n * when writing text that resolves to null/undefined\n * @private\n */\nexports.s = function strHelper(str) {\n    return (str == null) ? '' : str.toString();\n};\n\n/**\n * Internal helper method to handle loops without a status variable\n * @private\n */\nexports.f = function forEachHelper(array, callback) {\n    if (isArray(array)) {\n        for (var i=0; i<array.length; i++) {\n            callback(array[i]);\n        }\n    } else if (isFunction(array)) {\n        // Also allow the first argument to be a custom iterator function\n        array(callback);\n    }\n};\n\n/**\n * Helper to load a custom tag\n */\nexports.t = function loadTagHelper(renderer, targetProperty, isRepeated) {\n    if (renderer) {\n        renderer = resolveRenderer(renderer);\n    }\n\n    return renderer;\n};\n\n/**\n * classList(a, b, c, ...)\n * Joines a list of class names with spaces. Empty class names are omitted.\n *\n * classList('a', undefined, 'b') --> 'a b'\n *\n */\nexports.cl = function classListHelper() {\n    var classNames = [];\n    classList(arguments, classNames);\n    return classNames.join(' ');\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlAttribute/vdom/generateCode.js":"'use strict';\n\nmodule.exports = function generateCode(node, codegen, vdomUtil) {\n    var context = codegen.context;\n    var builder = codegen.builder;\n\n    // node.name = codegen.generateCode(node.name);\n    node.value = codegen.generateCode(node.value);\n    node.isStatic = vdomUtil.isStaticValue(node.value);\n    var name = node.name;\n\n    var attrValue = node.value;\n\n    if (attrValue) {\n        if (attrValue.type === 'Literal') {\n            var literalValue = attrValue.value;\n\n            if (literalValue instanceof RegExp) {\n                node.value = builder.literal(literalValue.source);\n            }\n        } else {\n            if (name === 'class') {\n                node.value = builder.functionCall(context.helper('classAttr'), [attrValue]);\n            } else if (name === 'style') {\n                node.value = builder.functionCall(context.helper('styleAttr'), [attrValue]);\n            }\n        }\n    }\n\n    return node;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/vdom/index.js":"'use strict';\n\nconst VDOMOptimizer = require('./VDOMOptimizer');\nconst isStaticValue = require('./isStaticValue');\n\nconst OPTIMIZER_ADDED_KEY = Symbol();\n\nfunction registerOptimizer(context) {\n    var data = context.data;\n    if (!data[OPTIMIZER_ADDED_KEY]) {\n        data[OPTIMIZER_ADDED_KEY] = true;\n\n        context.addOptimizer(new VDOMOptimizer());\n    }\n}\n\nexports.registerOptimizer = registerOptimizer;\nexports.isStaticValue = isStaticValue;\nexports.registerOptimizer = registerOptimizer;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/vdom/VDOMOptimizer.js":"'use strict';\n\n/*\nAlgorithm:\n\nWalk the DOM tree to find all HtmlElementVDOM and TextVDOM nodes\n\na) If a node is static then move to a static variable. Depending on whether or not the node is a root or nested,\nwe will need to replace it with one of the following:\n- out.n(staticVar)\n- .n(staticVar)\n\nb) If a node is HTML-only then generate code depending on if it is root or not:\n\n- out.e('div', ...) | out.t('foo')\n- .e('div', ...) || .t('foo')\n\nc) Else, generate one of the following:\n\n- out.beginElement()\n\n*/\n\n\nconst Node = require('../../ast/Node');\nconst OPTIMIZER_CONTEXT_KEY = Symbol();\n\nconst OPTIONS_DEFAULT =             { optimizeTextNodes: true, optimizeStaticNodes: true };\nconst OPTIONS_OPTIMIZE_TEXT_NODES = { optimizeTextNodes: true, optimizeStaticNodes: false };\n\nclass OptimizerContext {\n    constructor(context) {\n        this.context = context;\n\n        this.nextAttrsId = 0;\n        this.nextNodeId = 0;\n        this._nextConstIdFunc = null;\n    }\n\n    get nextConstIdFunc() {\n        let nextConstIdFunc = this._nextConstIdFunc;\n        if (!nextConstIdFunc) {\n            let context = this.context;\n            let builder = context.builder;\n            let constId = this.context.helper('const');\n            let fingerprintLiteral = builder.literal(context.getFingerprint(6));\n            nextConstIdFunc = this._nextConstIdFunc = context.addStaticVar(\n                'marko_const_nextId',\n                builder.functionCall(constId, [ fingerprintLiteral ]));\n        }\n        return nextConstIdFunc;\n    }\n}\n\nclass NodeVDOM extends Node {\n    constructor(variableIdentifier) {\n        super('NodeVDOM');\n        this.variableIdentifier = variableIdentifier;\n    }\n\n    writeCode(writer) {\n        var builder = writer.builder;\n\n        let funcCall = builder.functionCall(\n            builder.identifier('n'),\n            [\n                this.variableIdentifier\n            ]);\n\n        if (this.isChild) {\n            writer.write('.');\n        } else {\n            writer.write('out.');\n        }\n\n        writer.write(funcCall);\n    }\n}\n\nfunction generateNodesForArray(nodes, context, options) {\n    let builder = context.builder;\n\n    var optimizerContext = context[OPTIMIZER_CONTEXT_KEY] ||\n        (context[OPTIMIZER_CONTEXT_KEY] = new OptimizerContext(context));\n\n\n    var optimizeStaticNodes = options.optimizeStaticNodes !== false;\n\n    function generateStaticNode(node) {\n        if (node.type === 'HtmlElementVDOM') {\n            node.createElementId = context.helper('createElement');\n        }/* else {\n            node.createTextId = context.importModule('marko_createText', 'marko/vdom/createText');\n        }*/\n\n        node.nextConstId = builder.functionCall(optimizerContext.nextConstIdFunc, []);\n\n        node.isStaticRoot = true;\n        let staticNodeId = context.addStaticVar('marko_node' + (optimizerContext.nextNodeId++), node);\n\n        return new NodeVDOM(staticNodeId);\n    }\n\n    function handleStaticAttributes(node) {\n        var attributesArg = node.attributesArg;\n        if (attributesArg) {\n            node.isStaticRoot = true;\n            let staticAttrsId = context.addStaticVar('marko_attrs' + (optimizerContext.nextAttrsId++), attributesArg);\n            node.attributesArg = staticAttrsId;\n        }\n    }\n\n    let finalNodes = [];\n    let i = 0;\n\n    while (i<nodes.length) {\n        let node = nodes[i];\n        if (node.type === 'HtmlElementVDOM') {\n            if (optimizeStaticNodes) {\n                if (node.isStatic) {\n                    finalNodes.push(generateStaticNode(node));\n                    doOptimizeNode(node, context, OPTIONS_OPTIMIZE_TEXT_NODES);\n                } else {\n                    if (node.isAttrsStatic) {\n                        handleStaticAttributes(node);\n                    }\n\n                    finalNodes.push(node);\n                }\n            } else {\n                finalNodes.push(node);\n            }\n\n        } else {\n            finalNodes.push(node);\n        }\n\n        i++;\n    }\n\n    return finalNodes;\n}\n\nfunction doOptimizeNode(node, context, options) {\n    let walker = context.createWalker({\n        enterArray(nodes) {\n            return generateNodesForArray(nodes, context, options);\n        }\n    });\n\n    return walker.walk(node);\n}\n\nclass VDOMOptimizer {\n    optimize(node, context) {\n        doOptimizeNode(node, context, OPTIONS_DEFAULT);\n    }\n}\n\nmodule.exports = VDOMOptimizer;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/vdom/isStaticValue.js":"'use strict';\nvar Literal = require('../../ast/Literal');\nvar Node = require('../../ast/Node');\n\nfunction isStaticArray(array) {\n    for (let i=0; i<array.length; i++) {\n        if (!isStaticValue(array[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isStaticObject(object) {\n    for (var k in object) {\n        if (object.hasOwnProperty(k)) {\n            let v = object[k];\n            if (!isStaticValue(v)) {\n                return false;\n            }\n        }\n    }\n}\n\nfunction isStaticValue(value) {\n    if (value == null) {\n        return true;\n    }\n\n    if (value instanceof Node) {\n         if (value instanceof Literal) {\n             return isStaticValue(value.value);\n         } else {\n             return false;\n         }\n    } else {\n        if (typeof value === 'object') {\n            if (Array.isArray(value)) {\n                return isStaticArray(value);\n            } else {\n                return isStaticObject(value);\n            }\n        } else {\n            return true;\n        }\n    }\n}\n\nmodule.exports = isStaticValue;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/html/generateCode.js":"'use strict';\n\nvar StartTag = require('./StartTag');\nvar EndTag = require('./EndTag');\n\nmodule.exports = function generateCode(node, codegen) {\n    var builder = codegen.builder;\n    var tagName = node.tagName;\n\n    // Convert the tag name into a Node so that we generate the code correctly\n    if (tagName) {\n        tagName = codegen.builder.literal(tagName);\n    } else {\n        tagName = node.tagNameExpression;\n    }\n\n    var properties = node.getProperties();\n\n    if (properties) {\n        var objectProps = Object.keys(properties).map((propName) => {\n            return builder.property(\n                builder.identifier(propName),\n                properties[propName]);\n        });\n\n        node.setAttributeValue('data-marko',\n            builder.objectExpression(objectProps),\n            false);\n    }\n\n    var attributes = node._attributes && node._attributes.all;\n\n    var body = node.body;\n    var argument = node.argument;\n    var hasBody = body && body.length;\n    var openTagOnly = node.openTagOnly;\n    var bodyOnlyIf = node.bodyOnlyIf;\n    var dynamicAttributes = node.dynamicAttributes;\n    var selfClosed = node.selfClosed === true;\n\n\n\n    if (hasBody) {\n        body = codegen.generateCode(body);\n    }\n\n    if (hasBody || bodyOnlyIf) {\n        openTagOnly = false;\n        selfClosed = false;\n    } else if (selfClosed){\n        openTagOnly = true;\n    }\n\n    var startTag = new StartTag({\n        tagName: tagName,\n        attributes: attributes,\n        properties: properties,\n        argument: argument,\n        selfClosed: selfClosed,\n        dynamicAttributes: dynamicAttributes\n    });\n\n    var endTag;\n\n    if (!openTagOnly) {\n        endTag = new EndTag({\n            tagName: tagName\n        });\n    }\n\n    if (bodyOnlyIf) {\n        var startIf = builder.ifStatement(builder.negate(bodyOnlyIf), [\n            startTag\n        ]);\n\n        var endIf = builder.ifStatement(builder.negate(bodyOnlyIf), [\n            endTag\n        ]);\n\n        return [\n            startIf,\n            body,\n            endIf\n        ];\n    } else {\n        if (openTagOnly) {\n            return codegen.generateCode(startTag);\n        } else {\n            return [\n                startTag,\n                body,\n                endTag\n            ];\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/html/StartTag.js":"'use strict';\n\nvar Node = require('../../Node');\n\nclass StartTag extends Node {\n    constructor(def) {\n        super('StartTag');\n\n        this.tagName = def.tagName;\n        this.attributes = def.attributes;\n        this.properties = def.properties;\n        this.argument = def.argument;\n        this.selfClosed = def.selfClosed;\n        this.dynamicAttributes = def.dynamicAttributes;\n    }\n\n    generateCode(codegen) {\n        var builder = codegen.builder;\n\n        var tagName = this.tagName;\n        var selfClosed = this.selfClosed;\n        var dynamicAttributes = this.dynamicAttributes;\n        var context = codegen.context;\n\n        var nodes = [\n            builder.htmlLiteral('<'),\n            builder.html(tagName),\n        ];\n\n        var attributes = this.attributes;\n\n        if (attributes) {\n            for (let i=0; i<attributes.length; i++) {\n                let attr = attributes[i];\n                nodes.push(codegen.generateCode(attr));\n            }\n        }\n\n        if (dynamicAttributes) {\n            dynamicAttributes.forEach(function(attrsExpression) {\n                let attrsFunctionCall = builder.functionCall(context.helper('attrs'), [attrsExpression]);\n                nodes.push(builder.html(attrsFunctionCall));\n            });\n        }\n\n        if (selfClosed) {\n            nodes.push(builder.htmlLiteral('/>'));\n        } else {\n            nodes.push(builder.htmlLiteral('>'));\n        }\n\n        return nodes;\n    }\n}\n\nmodule.exports = StartTag;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/html/EndTag.js":"'use strict';\n\nvar Node = require('../../Node');\n\nclass EndTag extends Node {\n    constructor(def) {\n        super('EndTag');\n        this.tagName = def.tagName;\n    }\n\n    generateCode(codegen) {\n        var tagName = this.tagName;\n        var builder = codegen.builder;\n\n        return [\n            builder.htmlLiteral('</'),\n            builder.html(tagName),\n            builder.htmlLiteral('>')\n        ];\n    }\n}\n\nmodule.exports = EndTag;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/vdom/generateCode.js":"'use strict';\nvar HtmlElementVDOM = require('./HtmlElementVDOM');\nvar EndElementVDOM = require('./EndElementVDOM');\n\nfunction checkAttributesStatic(attributes) {\n    if (attributes) {\n        for (let i=0; i<attributes.length; i++) {\n            let attr = attributes[i];\n\n            if (!attr.isStatic) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction checkPropertiesStatic(properties, vdomUtil) {\n    if (properties) {\n        var keys = Object.keys(properties);\n        for (var i=0; i<keys.length; i++) {\n            var propName = keys[i];\n            var propValue = properties[propName];\n            var isStatic = vdomUtil.isStaticValue(propValue);\n            if (!isStatic) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nmodule.exports = function(node, codegen, vdomUtil) {\n    var body = codegen.generateCode(node.body);\n    var tagName = codegen.generateCode(node.tagNameExpression);\n    var attributes = codegen.generateCode(node.getAttributes());\n    var properties = codegen.generateCode(node.getProperties());\n    var dynamicAttributes = codegen.generateCode(node.dynamicAttributes);\n    var builder = codegen.builder;\n\n    var isAttrsStatic = checkAttributesStatic(attributes);\n    var isPropsStatic = checkPropertiesStatic(properties, vdomUtil);\n    var isStatic = isAttrsStatic && isPropsStatic && node.isLiteralTagName();\n    var isHtmlOnly = true;\n\n    if (body && body.length) {\n        for (var i=0; i<body.length; i++) {\n            let child = body[i];\n            if (child.type === 'HtmlElementVDOM' || child.type === 'TextVDOM') {\n                if (child.type === 'TextVDOM' && child.escape === false) {\n                    isHtmlOnly = false;\n                }\n                if (!child.isHtmlOnly) {\n                    isStatic = false;\n                    isHtmlOnly = false;\n                } if (!child.isStatic) {\n                    isStatic = false;\n                }\n            } else {\n                isHtmlOnly = false;\n                isStatic = false;\n            }\n        }\n    }\n\n    var bodyOnlyIf = node.bodyOnlyIf;\n    if (bodyOnlyIf) {\n        isHtmlOnly = false;\n    }\n\n    var htmlElVDOM = new HtmlElementVDOM({\n        tagName,\n        attributes,\n        properties,\n        body,\n        isStatic,\n        isAttrsStatic,\n        isHtmlOnly,\n        dynamicAttributes\n    });\n\n\n    if (bodyOnlyIf) {\n        htmlElVDOM.body = null;\n\n        var startIf = builder.ifStatement(builder.negate(bodyOnlyIf), [\n            htmlElVDOM\n        ]);\n\n        var endIf = builder.ifStatement(builder.negate(bodyOnlyIf), [\n            new EndElementVDOM()\n        ]);\n\n        return [\n            startIf,\n            body,\n            endIf\n        ];\n    } else if (isHtmlOnly) {\n        return htmlElVDOM;\n    } else {\n        htmlElVDOM.body = null;\n        return [htmlElVDOM].concat(body, new EndElementVDOM());\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/vdom/HtmlElementVDOM.js":"'use strict';\n\nconst Node = require('../../Node');\nconst vdomUtil = require('../../../util/vdom');\n\nvar FLAG_IS_SVG = 1;\nvar FLAG_IS_TEXTAREA = 2;\nvar FLAG_SIMPLE_ATTRS = 4;\n\nfunction finalizeCreateArgs(createArgs, builder) {\n    var length = createArgs.length;\n    var lastArg;\n\n    for (var i=length-1; i>=0; i--) {\n        var arg = createArgs[i];\n        if (arg) {\n            lastArg = arg;\n        } else {\n            if (lastArg != null) {\n                if (i === 3) {\n                    // Use a literal 0 for the flags\n                    createArgs[i] = builder.literal(0);\n                } else {\n                    createArgs[i] = builder.literalNull();\n                }\n\n            } else {\n                length--;\n            }\n        }\n    }\n\n    createArgs.length = length;\n    return createArgs;\n}\n\nconst MAYBE_SVG = {\n    'a': true,\n    'script': true,\n    'style': true\n};\n\nconst SIMPLE_ATTRS = {\n    'class': true,\n    'style': true,\n    'id': true\n};\n\nclass HtmlElementVDOM extends Node {\n    constructor(def) {\n        super('HtmlElementVDOM');\n        this.tagName = def.tagName;\n        this.isStatic = def.isStatic;\n        this.isAttrsStatic = def.isAttrsStatic;\n        this.isHtmlOnly = def.isHtmlOnly;\n        this.attributes = def.attributes;\n        this.properties = def.properties;\n        this.body = def.body;\n        this.dynamicAttributes = def.dynamicAttributes;\n\n        this.isSVG = false;\n        this.isTextArea = false;\n        this.hasAttributes = false;\n        this.hasSimpleAttrs = false; // This will be set to true if the HTML element\n                                     // only attributes in the following set:\n                                     // ['id', 'style', 'class']\n\n        this.isChild = false;\n        this.createElementId = undefined;\n        this.attributesArg = undefined;\n        this.propertiesArg = undefined;\n        this.nextConstId = undefined;\n    }\n\n    generateCode(codegen) {\n        let context = codegen.context;\n        let builder = codegen.builder;\n\n        vdomUtil.registerOptimizer(context);\n\n        let tagName = this.tagName;\n\n        if (tagName.type === 'Literal' && typeof tagName.value === 'string') {\n            let tagDef = context.getTagDef(tagName.value);\n            if (tagDef) {\n                if (tagDef.htmlType  === 'svg') {\n                    this.isSVG = true;\n                } else {\n                    if (MAYBE_SVG[tagName.value] && context.isFlagSet('SVG')) {\n                        this.isSVG = true;\n                    } else {\n                        this.tagName = tagName = builder.literal(tagName.value.toUpperCase());\n\n                        if (tagName.value === 'TEXTAREA') {\n                            this.isTextArea = true;\n                        }\n                    }\n                }\n            }\n        } else {\n\n            if (context.isFlagSet('SVG')) {\n                this.isSVG = true;\n            } else {\n                this.tagName = builder.functionCall(\n                    builder.memberExpression(\n                        tagName,\n                        builder.identifier('toUpperCase')),\n                    []);\n            }\n\n        }\n\n        let attributes = this.attributes;\n        let properties = this.properties;\n        let dynamicAttributes = this.dynamicAttributes;\n\n        let attributesArg = null;\n\n        var hasNamedAttributes = false;\n        var hasDynamicAttributes = dynamicAttributes != null && dynamicAttributes.length !== 0;\n\n        var hasSimpleAttrs = true;\n\n        if (properties && properties.noupdate) {\n            // Preserving attributes requires extra logic that we cannot\n            // shortcircuit\n            hasSimpleAttrs = false;\n        }\n\n        if (attributes != null && attributes.length !== 0) {\n            let addAttr = function(name, value) {\n                hasNamedAttributes = true;\n\n                if (!SIMPLE_ATTRS[name]) {\n                    hasSimpleAttrs = false;\n                }\n\n                if (!attributesArg) {\n                    attributesArg = {};\n                }\n\n                if (value.type === 'Literal') {\n                    let literalValue = value.value;\n                    if (literalValue == null || literalValue === false) {\n                        return;\n                    } else if (typeof literalValue === 'number') {\n                        value.value = literalValue.toString();\n                    }\n                } else if (value.type === 'AttributePlaceholder') {\n                    value = codegen.builder.functionCall(context.helper('str'), [value]);\n                }\n\n                attributesArg[name] = value;\n            };\n\n            attributes.forEach((attr) => {\n                let value = attr.value;\n\n                if (value == null) {\n                    value = builder.literal(true);\n                }\n\n                if (!attr.name) {\n                    return;\n                }\n\n                addAttr(attr.name, value);\n            });\n\n            if (attributesArg) {\n                attributesArg = builder.literal(attributesArg);\n            }\n        }\n\n        if (hasDynamicAttributes) {\n            dynamicAttributes.forEach((attrs) => {\n                if (attributesArg) {\n                    let mergeVar = context.helper('merge');\n                    attributesArg = builder.functionCall(mergeVar, [\n                        attributesArg, // Input props from the attributes take precedence\n                        attrs\n                    ]);\n                } else {\n                    attributesArg = attrs;\n                }\n            });\n        }\n\n        if (!this.isAttrsStatic && hasNamedAttributes && hasSimpleAttrs && !hasDynamicAttributes) {\n            this.hasSimpleAttrs = true;\n        }\n\n        this.hasAttributes = hasNamedAttributes || hasDynamicAttributes;\n\n        this.attributesArg = attributesArg;\n\n        return this;\n    }\n\n    walk(walker) {\n        this.tagName = walker.walk(this.tagName);\n        this.attributes = walker.walk(this.attributes);\n        this.body = walker.walk(this.body);\n    }\n\n    writeCode(writer) {\n        let builder = writer.builder;\n\n        let body = this.body;\n        let attributesArg = this.attributesArg;\n        let nextConstId = this.nextConstId;\n        let tagName = this.tagName;\n\n        let childCount = body && body.length;\n\n        let createArgs = new Array(5); // tagName, attributes, childCount, const ID, flags\n\n        createArgs[0] = tagName;\n\n        if (attributesArg) {\n            createArgs[1] = attributesArg;\n        }\n\n        if (childCount != null) {\n            createArgs[2] = builder.literal(childCount);\n        }\n\n\n\n        var flags = 0;\n\n        if (this.isSVG) {\n            flags |= FLAG_IS_SVG;\n        }\n\n        if (this.isTextArea) {\n            flags |= FLAG_IS_TEXTAREA;\n        }\n\n        if (this.hasSimpleAttrs) {\n            flags |= FLAG_SIMPLE_ATTRS;\n        }\n\n        if (flags) {\n            createArgs[3] = builder.literal(flags);\n        }\n\n        if (nextConstId) {\n            if (!this.properties) {\n                this.properties = {};\n            }\n            this.properties.c = nextConstId;\n        }\n\n        if (this.properties) {\n            createArgs[4] = builder.literal(this.properties);\n        }\n\n        // Remove trailing undefined arguments and convert non-trailing\n        // undefined elements to a literal null node\n        createArgs = finalizeCreateArgs(createArgs, builder);\n\n        let funcCall;\n\n        if (this.isChild) {\n            writer.write('.');\n\n            funcCall = builder.functionCall(\n                builder.identifier('e'),\n                createArgs);\n        } else if (this.isStatic && this.createElementId) {\n            funcCall = builder.functionCall(\n                this.createElementId,\n                createArgs);\n        } else if (this.isHtmlOnly) {\n            writer.write('out.');\n            funcCall = builder.functionCall(\n                builder.identifier('e'),\n                createArgs);\n        } else {\n            writer.write('out.');\n            funcCall = builder.functionCall(\n                builder.identifier('be'),\n                createArgs);\n        }\n\n        writer.write(funcCall);\n\n        if (body && body.length) {\n            writer.incIndent();\n            for(let i=0; i<body.length; i++) {\n                let child = body[i];\n                child.isChild = true;\n                writer.write('\\n');\n                writer.writeLineIndent();\n                writer.write(child);\n            }\n            writer.decIndent();\n        }\n    }\n}\n\nmodule.exports = HtmlElementVDOM;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlElement/vdom/EndElementVDOM.js":"'use strict';\nconst Node = require('../../Node');\n\nclass EndElementVDOM extends Node {\n    constructor() {\n        super('EndElementVDOM');\n    }\n\n    writeCode(writer) {\n        writer.write('out.ee()');\n    }\n}\n\nmodule.exports = EndElementVDOM;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Html.js":"'use strict';\n\nvar Node = require('./Node');\nvar Literal = require('./Literal');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nclass Html extends Node {\n    constructor(def) {\n        super('Html');\n        this.argument = def.argument;\n    }\n\n    _append(appendArgument) {\n        var argument = this.argument;\n\n        if (Array.isArray(argument)) {\n            var len = argument.length;\n            var last = argument[len-1];\n\n            if (last instanceof Literal && appendArgument instanceof Literal) {\n                last.value += appendArgument.value;\n            } else {\n                this.argument.push(appendArgument);\n            }\n        } else {\n            if (argument instanceof Literal && appendArgument instanceof Literal) {\n                argument.value += appendArgument.value;\n            } else {\n                this.argument = [ this.argument, appendArgument ];\n            }\n        }\n    }\n\n    append(html) {\n        var appendArgument = html.argument;\n        if (!appendArgument) {\n            return;\n        }\n\n        if (Array.isArray(appendArgument)) {\n            appendArgument.forEach(this._append, this);\n        } else {\n            this._append(appendArgument);\n        }\n    }\n\n    generateHTMLCode() {\n        return this;\n    }\n\n    writeCode(writer) {\n        var argument = this.argument;\n\n        if (Array.isArray(argument)) {\n            let args = argument;\n\n            for (let i=0, len=args.length; i<len; i++) {\n                let arg = args[i];\n\n                if (i === 0) {\n                    writer.write('out.w(');\n                } else {\n                    writer.write(' +\\n');\n                    writer.writeLineIndent();\n                    writer.writeIndent();\n                }\n\n                if (isCompoundExpression(arg)) {\n                    writer.write(['(', arg, ')']);\n                } else {\n                    writer.write(arg);\n                }\n            }\n\n            writer.write(')');\n        } else {\n            writer.write('out.w(');\n            writer.write(argument);\n            writer.write(')');\n        }\n    }\n\n    walk(walker) {\n        this.argument = walker.walk(this.argument);\n    }\n}\n\nmodule.exports = Html;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/isCompoundExpression.js":"function isCompoundExpression(expression) {\n    if (typeof expression === 'string') {\n        // TBD: Should we use Esprima to parse the expression string to see if it is a compount expression?\n        return true;\n    }\n\n    return expression.isCompoundExpression();\n}\n\nmodule.exports = isCompoundExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/CodeWriter.js":"'use strict';\n\nconst isArray = Array.isArray;\nconst Node = require('./ast/Node');\nconst Literal = require('./ast/Literal');\nconst Identifier = require('./ast/Identifier');\nconst ok = require('assert').ok;\nconst Container = require('./ast/Container');\nconst Comment = require('./ast/Comment');\nconst isValidJavaScriptVarName = require('./util/isValidJavaScriptVarName');\n\nclass CodeWriter {\n    constructor(options, builder) {\n        ok(builder, '\"builder\" is required');\n        options = options || {};\n        this.builder = builder;\n        this.root = null;\n        this._indentStr = options.indent != null ? options.indent : '  ';\n        this._indentSize = this._indentStr.length;\n\n        this._code = '';\n        this.currentIndent = '';\n    }\n\n    getCode() {\n        return this._code;\n    }\n\n    writeBlock(body) {\n        if (!body) {\n            this.write('{}');\n            return;\n        }\n\n        if (typeof body === 'function') {\n            body = body();\n        }\n\n        if (!body ||\n            (Array.isArray(body) && body.length === 0) ||\n            (body instanceof Container && body.length === 0)) {\n            this.write('{}');\n            return;\n        }\n\n        this.write('{\\n')\n            .incIndent();\n\n        this.writeStatements(body);\n\n        this.decIndent()\n            .writeLineIndent()\n            .write('}');\n    }\n\n    writeStatements(nodes) {\n        if (!nodes) {\n            return;\n        }\n\n        ok(nodes, '\"nodes\" expected');\n        let firstStatement = true;\n\n        var writeNode = (node) => {\n            if (Array.isArray(node) || (node instanceof Container)) {\n                node.forEach(writeNode);\n                return;\n            } else {\n                if (firstStatement) {\n                    firstStatement = false;\n                } else {\n                    this._write('\\n');\n                }\n\n                this.writeLineIndent();\n\n                if (typeof node === 'string') {\n                    this._write(node);\n                } else {\n                    node.statement = true;\n                    this.write(node);\n                }\n\n                if (this._code.endsWith('\\n')) {\n                    // Do nothing\n                } else if (this._code.endsWith(';')) {\n                    this._code += '\\n';\n                }  else if (this._code.endsWith('\\n' + this.currentIndent) || node instanceof Comment) {\n                    // Do nothing\n                } else {\n                    this._code += ';\\n';\n                }\n            }\n        };\n\n        if (nodes instanceof Node) {\n            writeNode(nodes);\n        } else {\n            nodes.forEach(writeNode);\n        }\n    }\n\n    write(code) {\n        if (code == null || code === '') {\n            return;\n        }\n\n        if (code instanceof Node) {\n            let node = code;\n            if (!node.writeCode) {\n                throw new Error('Node does not have a `writeCode` method: ' + JSON.stringify(node, null, 4));\n            }\n            node.writeCode(this);\n        } else if (isArray(code) || code instanceof Container) {\n            code.forEach(this.write, this);\n            return;\n        } else if (typeof code === 'string') {\n            this._code += code;\n        }  else if (typeof code === 'boolean' || typeof code === 'number') {\n            this._code += code.toString();\n        } else {\n            throw new Error('Illegal argument: ' + JSON.stringify(code));\n        }\n\n        return this;\n    }\n\n    _write(code) {\n        this._code += code;\n        return this;\n    }\n\n    incIndent(count) {\n        if (count != null) {\n            for (let i=0; i<count; i++) {\n                this.currentIndent += ' ';\n            }\n        } else {\n            this.currentIndent += this._indentStr;\n        }\n\n        return this;\n    }\n\n    decIndent(count) {\n        if (count == null) {\n            count = this._indentSize;\n        }\n\n        this.currentIndent = this.currentIndent.substring(\n            0,\n            this.currentIndent.length - count);\n\n        return this;\n    }\n\n    writeLineIndent() {\n        this._code += this.currentIndent;\n        return this;\n    }\n\n    writeIndent() {\n        this._code += this._indentStr;\n        return this;\n    }\n\n    isLiteralNode(node) {\n        return node instanceof Literal;\n    }\n\n    isIdentifierNode(node) {\n        return node instanceof Identifier;\n    }\n\n    writeLiteral(value) {\n        if (value === null) {\n            this.write('null');\n        } else if (value === undefined) {\n            this.write('undefined');\n        } else if (typeof value === 'string') {\n            this.write(JSON.stringify(value));\n        } else if (value === true) {\n            this.write('true');\n        } else if (value === false) {\n            this.write('false');\n        }  else if (isArray(value)) {\n            if (value.length === 0) {\n                this.write('[]');\n                return;\n            }\n\n            this.write('[\\n');\n            this.incIndent();\n\n            for (let i=0; i<value.length; i++) {\n                let v = value[i];\n\n                this.writeLineIndent();\n\n                if (v instanceof Node) {\n                    this.write(v);\n                } else {\n                    this.writeLiteral(v);\n                }\n\n                if (i < value.length - 1) {\n                    this.write(',\\n');\n                } else {\n                    this.write('\\n');\n                }\n            }\n\n            this.decIndent();\n            this.writeLineIndent();\n            this.write(']');\n        } else if (typeof value === 'number') {\n            this.write(value.toString());\n        } else if (value instanceof RegExp) {\n            this.write(value.toString());\n        } else if (typeof value === 'object') {\n            let keys = Object.keys(value);\n            if (keys.length === 0) {\n                this.write('{}');\n                return;\n            }\n\n            this.incIndent();\n            this.write('{\\n');\n            this.incIndent();\n\n            for (let i=0; i<keys.length; i++) {\n                let k = keys[i];\n                let v = value[k];\n\n                this.writeLineIndent();\n\n                if (isValidJavaScriptVarName(k)) {\n                    this.write(k + ': ');\n                } else {\n                    this.write(JSON.stringify(k) + ': ');\n                }\n\n                if (v instanceof Node) {\n                    this.write(v);\n                } else {\n                    this.writeLiteral(v);\n                }\n\n                if (i < keys.length - 1) {\n                    this.write(',\\n');\n                } else {\n                    this.write('\\n');\n                }\n            }\n\n            this.decIndent();\n            this.writeLineIndent();\n            this.write('}');\n            this.decIndent();\n        }\n    }\n}\n\nmodule.exports = CodeWriter;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Comment.js":"'use strict';\n\nconst Node = require('./Node');\n\nfunction _isMultilineComment(comment) {\n    return comment && comment.indexOf('\\n') !== -1;\n}\n\nclass Comment extends Node {\n    constructor(def) {\n        super('Comment');\n\n        const comment = def.comment;\n\n        if (_isMultilineComment(comment)) {\n            this.comment = `/*\\n${comment}\\n*/`;\n        } else {\n            this.comment = `// ${comment}`;\n        }\n    }\n\n    generateCode(codegen) {\n        return this;\n    }\n\n    writeCode(writer) {\n        var name = this.comment;\n        writer.write(name);\n    }\n\n    toString() {\n        return this.comment;\n    }\n}\n\nmodule.exports = Comment;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/Walker.js":"'use strict';\nvar isArray = Array.isArray;\nvar Container = require('./ast/Container');\n\nfunction noop() {}\n\nclass Walker {\n    constructor(options) {\n        this._enter = options.enter || noop;\n        this._exit = options.exit || noop;\n        this._enterArray = options.enterArray || noop;\n        this._exitArray = options.exitArray || noop;\n        this._stopped = false;\n        this._reset();\n        this._stack = [];\n    }\n\n    _reset() {\n        this._skipped = false;\n        this._replaced = undefined;\n        this._removed = false;\n    }\n\n    skip() {\n        this._skipped = true;\n    }\n\n    stop() {\n        this._stopped = true;\n    }\n\n    replace(newNode) {\n        this._replaced = newNode;\n    }\n\n    remove() {\n        this._removed = true;\n    }\n\n    _walkArray(array) {\n        var hasRemoval = false;\n\n        array = this._enterArray(array) || array;\n\n        array.forEach((node, i) => {\n            var transformed = this.walk(node);\n            if (transformed == null) {\n                array[i] = null;\n                hasRemoval = true;\n            } else if (transformed !== node) {\n                array[i] = transformed;\n            }\n        });\n\n        if (hasRemoval) {\n            for (let i=array.length-1; i>=0; i--) {\n                if (array[i] == null) {\n                    array.splice(i, 1);\n                }\n            }\n        }\n\n        array = this._exitArray(array) || array;\n\n        return array;\n    }\n\n    _walkContainer(nodes) {\n        nodes.forEach((node) => {\n            var transformed = this.walk(node);\n            if (!transformed) {\n                node.container.removeChild(node);\n            } else if (transformed !== node) {\n                node.container.replaceChild(transformed, node);\n            }\n        });\n    }\n\n    walk(node) {\n        if (!node || this._stopped || typeof node === 'string') {\n            return node;\n        }\n\n        this._reset();\n\n        var parent = this._stack.length ? this._stack[this._stack.length - 1] : undefined;\n\n        this._stack.push(node);\n\n        var replaced = this._enter(node, parent);\n        if (replaced === undefined) {\n            replaced = this._replaced;\n        }\n\n        if (this._removed) {\n            replaced = null;\n        }\n\n        if (replaced !== undefined) {\n            this._stack.pop();\n            return replaced;\n        }\n\n        if (this._skipped || this._stopped) {\n            this._stack.pop();\n            return node;\n        }\n\n        if (isArray(node)) {\n            let array = node;\n            let newArray = this._walkArray(array);\n            this._stack.pop();\n            return newArray;\n        } else if (node instanceof Container) {\n            let container = node;\n            this._walkContainer(container);\n            this._stack.pop();\n            return container;\n        } else {\n            if (node.walk) {\n                node.walk(this);\n            }\n        }\n\n        if (this._stopped) {\n            this._stack.pop();\n            return node;\n        }\n\n        this._reset();\n\n        replaced = this._exit(node, parent);\n        if (replaced === undefined) {\n            replaced = this._replaced;\n        }\n\n        if (this._removed) {\n            replaced = null;\n        }\n\n        if (replaced !== undefined) {\n            this._stack.pop();\n            return replaced;\n        }\n\n        this._stack.pop();\n        return node;\n    }\n}\n\nmodule.exports = Walker;\n\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/Parser.js":"'use strict';\nvar ok = require('assert').ok;\nvar replacePlaceholderEscapeFuncs = require('./util/replacePlaceholderEscapeFuncs');\nvar extend = require('raptor-util/extend');\n\nvar COMPILER_ATTRIBUTE_HANDLERS = {\n    'preserve-whitespace': function(attr, context) {\n        context.setPreserveWhitespace(true);\n    },\n    'preserve-comments': function(attr, context) {\n        context.setPreserveComments(true);\n    }\n};\n\nvar ieConditionalCommentRegExp = /^\\[if [^]*?<!\\[endif\\]$/;\n\nfunction isIEConditionalComment(comment) {\n    return ieConditionalCommentRegExp.test(comment);\n}\n\nfunction mergeShorthandClassNames(el, shorthandClassNames, context) {\n    var builder = context.builder;\n    let classNames = shorthandClassNames.map((className) => {\n        return builder.parseExpression(className.value);\n    });\n\n    var classAttr = el.getAttributeValue('class');\n    if (classAttr) {\n        classNames.push(classAttr);\n    }\n\n    let prevClassName;\n\n    var finalClassNames = [];\n\n    for (var i=0; i<classNames.length; i++) {\n        let className = classNames[i];\n        if (prevClassName && className.type === 'Literal' && prevClassName.type === 'Literal') {\n            prevClassName.value += ' ' + className.value;\n        } else {\n            finalClassNames.push(className);\n            prevClassName = className;\n        }\n    }\n\n    if (finalClassNames.length === 1) {\n        el.setAttributeValue('class', finalClassNames[0]);\n    } else {\n\n        el.setAttributeValue(\n            'class',\n            builder.functionCall(\n                context.helper('classList'),\n                [\n                    builder.literal(finalClassNames)\n                ]));\n    }\n}\n\nfunction getParserStateForTag(parser, el, tagDef) {\n    var attributes = el.attributes;\n    if (attributes) {\n        for (var i=0; i<attributes.length; i++) {\n            var attr = attributes[i];\n            var attrName = attr.name;\n            if (attrName === 'marko-body') {\n                var parseMode;\n\n                if (attr.literalValue) {\n                    parseMode = attr.literalValue;\n                }\n\n                if (parseMode === 'static-text' ||\n                    parseMode === 'parsed-text' ||\n                    parseMode === 'html') {\n                    return parseMode;\n                } else {\n                    parser.context.addError({\n                        message: 'Value for \"marko-body\" should be one of the following: \"static-text\", \"parsed-text\", \"html\"',\n                        code: 'ERR_INVALID_ATTR'\n                    });\n                    return;\n                }\n            } else if (attrName === 'template-helpers') {\n                return 'static-text';\n            } else if (attrName === 'marko-init') {\n                return 'static-text';\n            }\n        }\n    }\n\n    if (tagDef) {\n        var body = tagDef.body;\n        if (body) {\n            return body; // 'parsed-text' | 'static-text' | 'html'\n        }\n    }\n\n    return null; // Default parse state\n}\n\nclass Parser {\n    constructor(parserImpl, options) {\n        ok(parserImpl, '\"parserImpl\" is required');\n\n        this.parserImpl = parserImpl;\n\n        this.prevTextNode = null;\n        this.stack = null;\n\n        this.raw = options && options.raw === true;\n\n        // The context gets provided when parse is called\n        // but we store it as part of the object so that the handler\n        // methods have access\n        this.context = null;\n    }\n\n    _reset() {\n        this.prevTextNode = null;\n        this.stack = [];\n    }\n\n    parse(src, context) {\n        ok(typeof src === 'string', '\"src\" should be a string');\n        ok(context, '\"context\" is required');\n\n        this._reset();\n\n        this.context = context;\n\n        var builder = context.builder;\n        var rootNode = builder.templateRoot();\n\n        this.stack.push({\n            node: rootNode\n        });\n\n        this.parserImpl.parse(src, this, context.filename);\n\n        return rootNode;\n    }\n\n    handleCharacters(text, parseMode) {\n        var builder = this.context.builder;\n\n        var escape = parseMode !== 'html';\n        // NOTE: If parseMode is 'static-text' or 'parsed-text' then that means that special\n        //       HTML characters may not have been escaped on the way in so we need to escape\n        //       them on the way out\n\n        if (this.prevTextNode && this.prevTextNode.isLiteral() && this.prevTextNode.escape === escape) {\n            this.prevTextNode.argument.value += text;\n        } else {\n            this.prevTextNode = builder.text(builder.literal(text), escape);\n            this.parentNode.appendChild(this.prevTextNode);\n        }\n    }\n\n    handleStartElement(el, parser) {\n        var context = this.context;\n        var builder = context.builder;\n\n        var tagName = el.tagName;\n        var tagNameExpression = el.tagNameExpression;\n        var attributes = el.attributes;\n        var argument = el.argument; // e.g. For <for(color in colors)>, argument will be \"color in colors\"\n\n        if (argument) {\n            argument = argument.value;\n        }\n\n        var raw = this.raw;\n\n        if (!raw) {\n            if (tagNameExpression) {\n                tagName = builder.parseExpression(tagNameExpression);\n            } else if (tagName === 'marko-compiler-options') {\n                this.parentNode.setTrimStartEnd(true);\n\n                attributes.forEach(function (attr) {\n                    let attrName = attr.name;\n                    let handler = COMPILER_ATTRIBUTE_HANDLERS[attrName];\n\n                    if (!handler) {\n                        context.addError({\n                            code: 'ERR_INVALID_COMPILER_OPTION',\n                            message: 'Invalid Marko compiler option of \"' + attrName + '\". Allowed: ' + Object.keys(COMPILER_ATTRIBUTE_HANDLERS).join(', '),\n                            pos: el.pos,\n                            node: el\n                        });\n                        return;\n                    }\n\n                    handler(attr, context);\n                });\n\n                return;\n            }\n        }\n\n        this.prevTextNode = null;\n\n        var tagDef = el.tagName ? this.context.getTagDef(el.tagName) : null;\n\n        var attributeParseErrors = [];\n        // <div class=\"foo\"> -> \"div class=foo\"\n        var tagString = parser.substring(el.pos, el.endPos)\n                              .replace(/^<|\\/>$|>$/g, \"\").trim();\n\n        var shouldParsedAttributes = !tagDef || tagDef.parseAttributes !== false;\n\n        var parsedAttributes = [];\n\n        if (shouldParsedAttributes) {\n            attributes.forEach((attr) => {\n                var attrValue;\n                if (attr.hasOwnProperty('literalValue')) {\n                    attrValue = builder.literal(attr.literalValue);\n                } else if (attr.value == null) {\n                    attrValue = undefined;\n                } else {\n                    let parsedExpression;\n                    let valid = true;\n                    try {\n                        parsedExpression = builder.parseExpression(attr.value);\n                    } catch(e) {\n                        if (shouldParsedAttributes) {\n                            valid = false;\n                            attributeParseErrors.push('Invalid JavaScript expression for attribute \"' + attr.name + '\": ' + e);\n                        } else {\n                            // Attribute failed to parse. Skip it...\n                            return;\n                        }\n\n                    }\n\n                    if (valid) {\n                        if (raw) {\n                            attrValue = parsedExpression;\n                        } else {\n                            attrValue = replacePlaceholderEscapeFuncs(parsedExpression, context);\n                        }\n                    } else {\n                        attrValue = null;\n                    }\n                }\n\n                var attrDef = {\n                    name: attr.name,\n                    value: attrValue,\n                    rawValue: attr.value\n                };\n\n                if (attr.argument) {\n                    // TODO Do something with the argument pos\n                    attrDef.argument = attr.argument.value;\n                }\n\n                parsedAttributes.push(attrDef);\n            });\n        }\n\n        var elDef = {\n            tagName: tagName,\n            argument: argument,\n            tagString,\n            openTagOnly: el.openTagOnly === true,\n            selfClosed: el.selfClosed === true,\n            pos: el.pos,\n            attributes: parsedAttributes\n        };\n\n        var node;\n\n        if (raw) {\n            node = builder.htmlElement(elDef);\n            node.pos = elDef.pos;\n            node.tagDef = tagDef;\n        } else {\n            node = this.context.createNodeForEl(elDef);\n        }\n\n        if (attributeParseErrors.length) {\n\n            attributeParseErrors.forEach((e) => {\n                context.addError(node, e);\n            });\n        }\n\n        if (raw) {\n            if (el.shorthandId) {\n                let parsed = builder.parseExpression(el.shorthandId.value);\n                node.rawShorthandId = parsed.value;\n            }\n\n            if (el.shorthandClassNames) {\n                node.rawShorthandClassNames = el.shorthandClassNames.map((className) => {\n                    let parsed = builder.parseExpression(className.value);\n                    return parsed.value;\n                });\n            }\n        } else {\n            if (el.shorthandClassNames) {\n                mergeShorthandClassNames(node, el.shorthandClassNames, context);\n            }\n\n            if (el.shorthandId) {\n                if (node.hasAttribute('id')) {\n                    context.addError(node, 'A shorthand ID cannot be used in conjunction with the \"id\" attribute');\n                } else {\n                    node.setAttributeValue('id', builder.parseExpression(el.shorthandId.value));\n                }\n            }\n        }\n\n        this.parentNode.appendChild(node);\n\n        this.stack.push({\n            node: node,\n            tag: null\n        });\n    }\n\n    handleEndElement(elementName) {\n        if (this.raw !== true) {\n            if (elementName === 'marko-compiler-options') {\n                return;\n            }\n        }\n\n        this.prevTextNode = null;\n        this.stack.pop();\n    }\n\n    handleComment(comment) {\n        this.prevTextNode = null;\n\n        var builder = this.context.builder;\n\n        var preserveComment = this.context.isPreserveComments() ||\n            isIEConditionalComment(comment);\n\n        if (this.raw || preserveComment) {\n            var commentNode = builder.htmlComment(builder.literal(comment));\n            this.parentNode.appendChild(commentNode);\n        }\n    }\n\n    handleDeclaration(value) {\n        this.prevTextNode = null;\n\n        var builder = this.context.builder;\n\n        var declarationNode = builder.declaration(builder.literal(value));\n        this.parentNode.appendChild(declarationNode);\n    }\n\n    handleDocumentType(value) {\n        this.prevTextNode = null;\n\n        var builder = this.context.builder;\n\n        var docTypeNode = builder.documentType(builder.literal(value));\n        this.parentNode.appendChild(docTypeNode);\n    }\n\n    handleBodyTextPlaceholder(expression, escape) {\n        this.prevTextNode = null;\n        var builder = this.context.builder;\n        var parsedExpression = builder.parseExpression(expression);\n        var preserveWhitespace = true;\n\n        var text = builder.text(parsedExpression, escape, preserveWhitespace);\n        this.parentNode.appendChild(text);\n    }\n\n    handleScriptlet(event) {\n        this.prevTextNode = null;\n        var builder = this.context.builder;\n        var scriptlet = builder.scriptlet(event);\n        this.parentNode.appendChild(scriptlet);\n    }\n\n    handleError(event) {\n        this.context.addError({\n            message: event.message,\n            code: event.code,\n            pos: event.pos,\n            endPos: event.endPos\n        });\n    }\n\n    get parentNode() {\n        var last = this.stack[this.stack.length-1];\n        return last.node;\n    }\n\n    getTagParseOptions(el) {\n        var tagName = el.tagName;\n        var tagDef = this.context.getTagDef(tagName);\n\n        var state = getParserStateForTag(this, el, tagDef);\n        var parseOptions = tagDef && tagDef.parseOptions;\n\n        if (!state && !parseOptions) {\n            return;\n        }\n\n        if (parseOptions) {\n            if (state) {\n                // We need to merge in the state to the returned parse options\n                parseOptions = extend({ state: state }, parseOptions);\n            }\n        } else {\n            parseOptions = { state: state };\n        }\n\n        return parseOptions;\n    }\n\n    isOpenTagOnly(tagName) {\n        var tagDef = this.context.getTagDef(tagName);\n        return tagDef && tagDef.openTagOnly;\n    }\n}\n\nmodule.exports = Parser;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/replacePlaceholderEscapeFuncs.js":"var AttributePlaceholder = require('../ast/AttributePlaceholder');\n\nmodule.exports = function replacePlaceholderEscapeFuncs(node, context) {\n    var walker = context.createWalker({\n        exit: function(node, parent) {\n            if (node.type === 'FunctionCall' &&\n                node.callee.type === 'Identifier') {\n\n                if (node.callee.name === '$noEscapeXml') {\n                    return new AttributePlaceholder({escape: false, value: node.args[0]});\n                } else if (node.callee.name === '$escapeXml') {\n                    return new AttributePlaceholder({escape: true, value: node.args[0]});\n                }\n            }\n        }\n    });\n\n    return walker.walk(node);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/AttributePlaceholder.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass AttributePlaceholder extends Node {\n    constructor(def) {\n        super('AttributePlaceholder');\n        this.value = def.value;\n        this.escape = def.escape;\n    }\n\n    generateCode(codegen) {\n        this.value = codegen.generateCode(this.value);\n        return this;\n    }\n\n    writeCode(writer) {\n        writer.write(this.value);\n    }\n\n    walk(walker) {\n        this.value = walker.walk(this.value);\n    }\n\n    isCompoundExpression() {\n        return this.value.isCompoundExpression();\n    }\n\n    /**\n     * \"noOutput\" should be true if the Node.js does not result in any HTML or Text output\n     */\n    get noOutput() {\n        return this.value.noOutput;\n    }\n}\n\nmodule.exports = AttributePlaceholder;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/HtmlJsParser.js":"'use strict';\nvar htmljs = require('htmljs-parser');\n\nclass HtmlJsParser {\n    constructor(options) {\n        this.ignorePlaceholders = options && options.ignorePlaceholders === true;\n    }\n\n    parse(src, handlers, filename) {\n        var listeners = {\n            onText(event) {\n                handlers.handleCharacters(event.value, event.parseMode);\n            },\n\n            onPlaceholder(event) {\n                if (event.withinBody) {\n                    if (!event.withinString) {\n                        handlers.handleBodyTextPlaceholder(event.value, event.escape);\n                    }\n                } else if (event.withinOpenTag) {\n                    // Don't escape placeholder for dynamic attributes. For example: <div ${data.myAttrs}></div>\n                } else {\n                    // placeholder within attribute\n                    if (event.escape) {\n                        event.value = '$escapeXml(' + event.value + ')';\n                    } else {\n                        event.value = '$noEscapeXml(' + event.value + ')';\n                    }\n                }\n                // placeholder within content\n\n            },\n\n            onCDATA(event) {\n                handlers.handleCharacters(event.value, 'static-text');\n            },\n\n            onOpenTagName(event, parser) {\n                event.selfClosed = false; // Don't allow self-closed tags\n\n                var tagParseOptions = handlers.getTagParseOptions(event);\n\n                if (tagParseOptions) {\n                    event.setParseOptions(tagParseOptions);\n                }\n            },\n\n            onOpenTag(event, parser) {\n                event.selfClosed = false; // Don't allow self-closed tags\n                handlers.handleStartElement(event, parser);\n\n                var tagParseOptions = handlers.getTagParseOptions(event);\n                if (tagParseOptions) {\n                    event.setParseOptions(tagParseOptions);\n                }\n            },\n\n            onCloseTag(event) {\n                var tagName = event.tagName;\n                handlers.handleEndElement(tagName);\n            },\n\n            onDocumentType(event) {\n\n                // Document type: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\n                // NOTE: The value will be all of the text between \"<!\" and \">\"\"\n                handlers.handleDocumentType(event.value);\n            },\n\n            onDeclaration(event) {\n                handlers.handleDeclaration(event.value);\n            },\n\n            onComment(event) {\n                // Text within XML comment\n                handlers.handleComment(event.value);\n            },\n\n            onScriptlet(event) {\n                // <% (code) %> or $ {}\n                handlers.handleScriptlet(event);\n            },\n\n            onError(event) {\n                handlers.handleError(event);\n            }\n        };\n\n        var parser = this.parser = htmljs.createParser(listeners, {\n            ignorePlaceholders: this.ignorePlaceholders,\n            isOpenTagOnly: function(tagName) {\n                return handlers.isOpenTagOnly(tagName);\n            }\n        });\n        parser.parse(src, filename);\n    }\n}\n\nmodule.exports = HtmlJsParser;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/Builder.js":"'use strict';\nvar isArray = Array.isArray;\nvar ok = require('assert').ok;\n\nvar Node = require('./ast/Node');\nvar Program = require('./ast/Program');\nvar TemplateRoot = require('./ast/TemplateRoot');\nvar FunctionDeclaration = require('./ast/FunctionDeclaration');\nvar FunctionCall = require('./ast/FunctionCall');\nvar Literal = require('./ast/Literal');\nvar Identifier = require('./ast/Identifier');\nvar Comment = require('./ast/Comment');\nvar If = require('./ast/If');\nvar ElseIf = require('./ast/ElseIf');\nvar Else = require('./ast/Else');\nvar Assignment = require('./ast/Assignment');\nvar BinaryExpression = require('./ast/BinaryExpression');\nvar LogicalExpression = require('./ast/LogicalExpression');\nvar Vars = require('./ast/Vars');\nvar Return = require('./ast/Return');\nvar HtmlElement = require('./ast/HtmlElement');\nvar Html = require('./ast/Html');\nvar Text = require('./ast/Text');\nvar ForEach = require('./ast/ForEach');\nvar ForEachProp = require('./ast/ForEachProp');\nvar ForRange = require('./ast/ForRange');\nvar HtmlComment = require('./ast/HtmlComment');\nvar SelfInvokingFunction = require('./ast/SelfInvokingFunction');\nvar ForStatement = require('./ast/ForStatement');\nvar BinaryExpression = require('./ast/BinaryExpression');\nvar UpdateExpression = require('./ast/UpdateExpression');\nvar UnaryExpression = require('./ast/UnaryExpression');\nvar MemberExpression = require('./ast/MemberExpression');\nvar Code = require('./ast/Code');\nvar InvokeMacro = require('./ast/InvokeMacro');\nvar Macro = require('./ast/Macro');\nvar ConditionalExpression = require('./ast/ConditionalExpression');\nvar NewExpression = require('./ast/NewExpression');\nvar ObjectExpression = require('./ast/ObjectExpression');\nvar ArrayExpression = require('./ast/ArrayExpression');\nvar Property = require('./ast/Property');\nvar VariableDeclarator = require('./ast/VariableDeclarator');\nvar ThisExpression = require('./ast/ThisExpression');\nvar Expression = require('./ast/Expression');\nvar Scriptlet = require('./ast/Scriptlet');\nvar ContainerNode = require('./ast/ContainerNode');\nvar WhileStatement = require('./ast/WhileStatement');\nvar DocumentType = require('./ast/DocumentType');\nvar Declaration = require('./ast/Declaration');\nvar SequenceExpression = require('./ast/SequenceExpression');\nvar CustomTag = require('./ast/CustomTag');\n\nvar parseExpression = require('./util/parseExpression');\nvar parseStatement = require('./util/parseStatement');\nvar parseJavaScriptArgs = require('./util/parseJavaScriptArgs');\nvar replacePlaceholderEscapeFuncs = require('./util/replacePlaceholderEscapeFuncs');\nvar isValidJavaScriptIdentifier = require('./util/isValidJavaScriptIdentifier');\n\nvar DEFAULT_BUILDER;\n\nfunction makeNode(arg) {\n    if (typeof arg === 'string') {\n        return parseExpression(arg, DEFAULT_BUILDER);\n    } else if (arg instanceof Node) {\n        return arg;\n    } else if (arg == null) {\n        return undefined;\n    } else if (Array.isArray(arg)) {\n        return arg.map((arg) => {\n            return makeNode(arg);\n        });\n    } else {\n        throw new Error('Argument should be a string or Node or null. Actual: ' + arg);\n    }\n}\n\nvar literalNull = new Literal({value: null});\nvar literalUndefined = new Literal({value: undefined});\nvar literalTrue = new Literal({value: true});\nvar literalFalse = new Literal({value: false});\nvar identifierOut = new Identifier({name: 'out'});\nvar identifierRequire = new Identifier({name: 'require'});\n\nclass Builder {\n    arrayExpression(elements) {\n        if (elements) {\n            if (!isArray(elements)) {\n                elements = [elements];\n            }\n\n            for (var i=0; i<elements.length; i++) {\n                elements[i] = makeNode(elements[i]);\n            }\n        } else {\n            elements = [];\n        }\n\n        return new ArrayExpression({elements});\n    }\n\n    assignment(left, right, operator) {\n        if (operator == null) {\n            operator = '=';\n        }\n        left = makeNode(left);\n        right = makeNode(right);\n        return new Assignment({left, right, operator});\n    }\n\n    binaryExpression(left, operator, right) {\n        left = makeNode(left);\n        right = makeNode(right);\n        return new BinaryExpression({left, operator, right});\n    }\n\n    sequenceExpression(expressions) {\n        expressions = makeNode(expressions);\n        return new SequenceExpression({expressions});\n    }\n\n    code(value) {\n        return new Code({value});\n    }\n\n    computedMemberExpression(object, property) {\n        object = makeNode(object);\n        property = makeNode(property);\n        let computed = true;\n\n        return new MemberExpression({object, property, computed});\n    }\n\n    concat(args) {\n        var prev;\n        let operator = '+';\n\n        for (var i=1; i<arguments.length; i++) {\n            var left;\n            var right = makeNode(arguments[i]);\n            if (i === 1) {\n                left = makeNode(arguments[i-1]);\n            } else {\n                left = prev;\n            }\n\n            prev = new BinaryExpression({left, operator, right});\n        }\n\n        return prev;\n    }\n\n    conditionalExpression(test, consequent, alternate) {\n        return new ConditionalExpression({test, consequent, alternate});\n    }\n\n    containerNode(type, generateCode) {\n        if (typeof type === 'function') {\n            generateCode = arguments[0];\n            type = 'ContainerNode';\n        }\n\n        var node = new ContainerNode(type);\n        if (generateCode) {\n            node.setCodeGenerator(generateCode);\n        }\n        return node;\n    }\n\n    customTag(el, tagDef) {\n        return new CustomTag(el, tagDef);\n    }\n\n    declaration(declaration) {\n        return new Declaration({declaration});\n    }\n\n    documentType(documentType) {\n        return new DocumentType({documentType});\n    }\n\n    elseStatement(body) {\n        return new Else({body});\n    }\n\n    elseIfStatement(test, body, elseStatement) {\n        test = makeNode(test);\n\n        return new ElseIf({test, body, else: elseStatement});\n    }\n\n    expression(value) {\n        return new Expression({value});\n    }\n\n    forEach(varName, inExpression, body) {\n        if (arguments.length === 1) {\n            var def = arguments[0];\n            return new ForEach(def);\n        } else {\n            varName = makeNode(varName);\n            inExpression = makeNode(inExpression);\n            return new ForEach({varName, in: inExpression, body});\n        }\n    }\n\n    forEachProp(nameVarName, valueVarName, inExpression, body) {\n        if (arguments.length === 1) {\n            var def = arguments[0];\n            return new ForEachProp(def);\n        } else {\n            nameVarName = makeNode(nameVarName);\n            valueVarName = makeNode(valueVarName);\n            inExpression = makeNode(inExpression);\n            return new ForEachProp({nameVarName, valueVarName, in: inExpression, body});\n        }\n    }\n\n    forRange(varName, from, to, step, body) {\n        if (arguments.length === 1) {\n            var def = arguments[0];\n            return new ForRange(def);\n        } else {\n            varName = makeNode(varName);\n            from = makeNode(from);\n            to = makeNode(to);\n            step = makeNode(step);\n            body = makeNode(body);\n\n            return new ForRange({varName, from, to, step, body});\n        }\n    }\n\n    forStatement(init, test, update, body) {\n        if (arguments.length === 1) {\n            var def = arguments[0];\n            return new ForStatement(def);\n        } else {\n            init = makeNode(init);\n            test = makeNode(test);\n            update = makeNode(update);\n            return new ForStatement({init, test, update, body});\n        }\n    }\n\n    functionCall(callee, args) {\n        callee = makeNode(callee);\n\n        if (args) {\n            if (!isArray(args)) {\n                throw new Error('\"args\" should be an array');\n            }\n\n            for (var i=0; i<args.length; i++) {\n                args[i] = makeNode(args[i]);\n            }\n        } else {\n            args = [];\n        }\n\n        return new FunctionCall({callee, args});\n    }\n\n    functionDeclaration(name, params, body) {\n        return new FunctionDeclaration({name, params, body});\n    }\n\n    html(argument) {\n        argument = makeNode(argument);\n\n        return new Html({argument});\n    }\n\n    htmlComment(comment) {\n        return new HtmlComment({comment});\n    }\n\n    comment(comment) {\n        return new Comment({comment});\n    }\n\n    htmlElement(tagName, attributes, body, argument, openTagOnly, selfClosed) {\n        if (typeof tagName === 'object' && !(tagName instanceof Node)) {\n            let def = arguments[0];\n            return new HtmlElement(def);\n        } else {\n            return new HtmlElement({tagName, attributes, body, argument, openTagOnly, selfClosed});\n        }\n    }\n\n    htmlLiteral(htmlCode) {\n        var argument = new Literal({value: htmlCode});\n        return new Html({argument});\n    }\n\n    identifier(name) {\n        ok(typeof name === 'string', '\"name\" should be a string');\n\n        if (!isValidJavaScriptIdentifier(name)) {\n            var error = new Error('Invalid JavaScript identifier: ' + name);\n            error.code = 'INVALID_IDENTIFIER';\n            throw error;\n        }\n        return new Identifier({name});\n    }\n\n    identifierOut(name) {\n        return identifierOut;\n    }\n\n    ifStatement(test, body, elseStatement) {\n        test = makeNode(test);\n\n        return new If({test, body, else: elseStatement});\n    }\n\n    invokeMacro(name, args, body) {\n        return new InvokeMacro({name, args, body});\n    }\n\n    invokeMacroFromEl(el) {\n        return new InvokeMacro({el});\n    }\n\n    literal(value) {\n        return new Literal({value});\n    }\n\n    literalFalse() {\n        return literalFalse;\n    }\n\n    literalNull() {\n        return literalNull;\n    }\n\n    literalTrue() {\n        return literalTrue;\n    }\n\n    literalUndefined() {\n        return literalUndefined;\n    }\n\n    logicalExpression(left, operator, right) {\n        left = makeNode(left);\n        right = makeNode(right);\n        return new LogicalExpression({left, operator, right});\n    }\n\n    macro(name, params, body) {\n        return new Macro({name, params, body});\n    }\n\n    memberExpression(object, property, computed) {\n        object = makeNode(object);\n        property = makeNode(property);\n\n        return new MemberExpression({object, property, computed});\n    }\n\n    moduleExports(value) {\n        let object = new Identifier({name: 'module'});\n        let property = new Identifier({name: 'exports'});\n\n        var moduleExports = new MemberExpression({object, property });\n\n        if (value) {\n            return new Assignment({left: moduleExports, right: value, operator: '='});\n        } else {\n            return moduleExports;\n        }\n    }\n\n    negate(argument) {\n        argument = makeNode(argument);\n\n        var operator = '!';\n        var prefix = true;\n        return new UnaryExpression({argument, operator, prefix});\n    }\n\n    newExpression(callee, args) {\n        callee = makeNode(callee);\n\n        if (args) {\n            if (!isArray(args)) {\n                args = [args];\n            }\n\n            for (var i=0; i<args.length; i++) {\n                args[i] = makeNode(args[i]);\n            }\n        } else {\n            args = [];\n        }\n\n        return new NewExpression({callee, args});\n    }\n\n    node(type, generateCode) {\n        if (typeof type === 'function') {\n            generateCode = arguments[0];\n            type = 'Node';\n        }\n\n        var node = new Node(type);\n        if (generateCode) {\n            node.setCodeGenerator(generateCode);\n        }\n        return node;\n    }\n\n    objectExpression(properties) {\n        if (properties) {\n            if (!isArray(properties)) {\n                properties = [properties];\n            }\n\n            for (var i=0; i<properties.length; i++) {\n                let prop = properties[i];\n                prop.value = makeNode(prop.value);\n            }\n        } else {\n            properties = [];\n        }\n\n        return new ObjectExpression({properties});\n    }\n\n    parseExpression(str, options) {\n        ok(typeof str === 'string', '\"str\" should be a string expression');\n        var parsed = parseExpression(str, DEFAULT_BUILDER);\n        return parsed;\n    }\n\n    parseJavaScriptArgs(args) {\n        ok(typeof args === 'string', '\"args\" should be a string');\n        return parseJavaScriptArgs(args, DEFAULT_BUILDER);\n    }\n\n    parseStatement(str, options) {\n        ok(typeof str === 'string', '\"str\" should be a string expression');\n        var parsed = parseStatement(str, DEFAULT_BUILDER);\n        return parsed;\n    }\n\n    replacePlaceholderEscapeFuncs(node, context) {\n        return replacePlaceholderEscapeFuncs(node, context);\n    }\n\n    program(body) {\n        return new Program({body});\n    }\n\n    property(key, value) {\n        key = makeNode(key);\n        value = makeNode(value);\n\n        return new Property({key, value});\n    }\n\n    renderBodyFunction(body, params) {\n        let name = 'renderBody';\n        if (!params) {\n            params = [new Identifier({name: 'out'})];\n        }\n        return new FunctionDeclaration({name, params, body});\n    }\n\n    require(path) {\n        path = makeNode(path);\n\n        let callee = identifierRequire;\n        let args = [ path ];\n        return new FunctionCall({callee, args});\n    }\n\n    requireResolve(path) {\n        path = makeNode(path);\n\n        let callee = new MemberExpression({\n            object: new Identifier({name: 'require'}),\n            property: new Identifier({name: 'resolve'})\n        });\n\n        let args = [ path ];\n        return new FunctionCall({callee, args});\n    }\n\n    returnStatement(argument) {\n        argument = makeNode(argument);\n\n        return new Return({argument});\n    }\n\n    scriptlet(scriptlet) {\n        return new Scriptlet({\n            code: scriptlet.value,\n            tag: scriptlet.tag,\n            block: scriptlet.block\n        });\n    }\n\n    selfInvokingFunction(params, args, body) {\n        if (arguments.length === 1) {\n            body = arguments[0];\n            params = null;\n            args = null;\n        }\n\n        return new SelfInvokingFunction({params, args, body});\n    }\n\n    strictEquality(left, right) {\n        left = makeNode(left);\n        right = makeNode(right);\n\n        var operator = '===';\n        return new BinaryExpression({left, right, operator});\n    }\n\n    templateRoot(body) {\n        return new TemplateRoot({body});\n    }\n\n    text(argument, escape, preserveWhitespace) {\n        if (typeof argument === 'object' && !(argument instanceof Node)) {\n            var def = arguments[0];\n            return new Text(def);\n        }\n        argument = makeNode(argument);\n\n        return new Text({argument, escape, preserveWhitespace});\n    }\n\n    thisExpression() {\n        return new ThisExpression();\n    }\n\n    unaryExpression(argument, operator, prefix) {\n        argument = makeNode(argument);\n\n        return new UnaryExpression({argument, operator, prefix});\n    }\n\n    updateExpression(argument, operator, prefix) {\n        argument = makeNode(argument);\n        return new UpdateExpression({argument, operator, prefix});\n    }\n\n    variableDeclarator(id, init) {\n        if (typeof id === 'string') {\n            id = new Identifier({name: id});\n        }\n        if (init) {\n            init = makeNode(init);\n        }\n\n        return new VariableDeclarator({id, init});\n    }\n\n    var(id, init, kind) {\n        if (!kind) {\n            kind = 'var';\n        }\n\n        id = makeNode(id);\n        init = makeNode(init);\n\n        var declarations = [\n            new VariableDeclarator({id, init})\n        ];\n\n        return new Vars({declarations, kind});\n    }\n\n    vars(declarations, kind) {\n        if (declarations) {\n            if (Array.isArray(declarations)) {\n                for (let i=0; i<declarations.length; i++) {\n                    var declaration = declarations[i];\n                    if (!declaration) {\n                        throw new Error('Invalid variable declaration');\n                    }\n                    if (typeof declaration === 'string') {\n                        declarations[i] = new VariableDeclarator({\n                            id: new Identifier({name: declaration})\n                        });\n                    } else if (declaration instanceof Identifier) {\n                        declarations[i] = new VariableDeclarator({\n                            id: declaration\n                        });\n                    } else if (typeof declaration === 'object') {\n                        if (!(declaration instanceof VariableDeclarator)) {\n                            let id = declaration.id;\n                            let init = declaration.init;\n\n                            if (typeof id === 'string') {\n                                id = new Identifier({name: id});\n                            }\n\n                            if (!id) {\n                                throw new Error('Invalid variable declaration');\n                            }\n\n                            if (init) {\n                                init = makeNode(init);\n                            }\n\n\n                            declarations[i] = new VariableDeclarator({id, init});\n                        }\n                    }\n                }\n            } else if (typeof declarations === 'object') {\n                // Convert the object into an array of variables\n                declarations = Object.keys(declarations).map((key) => {\n                    let id = new Identifier({name: key});\n                    let init = makeNode(declarations[key]);\n                    return new VariableDeclarator({ id, init });\n                });\n            }\n        }\n\n\n        return new Vars({declarations, kind});\n    }\n\n    whileStatement(test, body) {\n        return new WhileStatement({test, body});\n    }\n}\n\nDEFAULT_BUILDER = new Builder();\n\nBuilder.DEFAULT_BUILDER = DEFAULT_BUILDER;\n\nmodule.exports = Builder;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Program.js":"'use strict';\nvar Node = require('./Node');\n\nclass Program extends Node {\n    constructor(def) {\n        super('Program');\n        this.body = def.body;\n    }\n\n    generateCode(codegen) {\n        this.body = codegen.generateCode(this.body);\n        return this;\n    }\n\n    writeCode(writer) {\n        writer.writeStatements(this.body);\n    }\n\n    walk(walker) {\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = Program;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/TemplateRoot.js":"'use strict';\nvar Node = require('./Node');\n\nfunction createVarsArray(vars) {\n    return Object.keys(vars).map(function(varName) {\n        var varInit = vars[varName];\n        return {\n            id: varName,\n            init: varInit\n        };\n    });\n}\n\nfunction _buildVersionComment(builder, context) {\n    const version = context.compilerVersion;\n    const compilerType = context.compilerType;\n    return builder.comment(`Compiled using ${compilerType}@${version} - DO NOT EDIT`);\n}\n\nclass TemplateRoot extends Node {\n    constructor(def) {\n        super('TemplateRoot');\n        this.body = this.makeContainer(def.body);\n        this.extraRenderParams = null;\n        this.generateAssignRenderCode = null;\n    }\n\n    addRenderFunctionParam(id) {\n        if (!this.extraRenderParams) {\n            this.extraRenderParams = [];\n        }\n\n        this.extraRenderParams.push(id);\n    }\n\n    generateCode(codegen) {\n        var context = codegen.context;\n\n        this.body = codegen.generateCode(this.body);\n\n        context.optimize(this);\n\n        var body = this.body;\n\n        var builder = codegen.builder;\n\n        let renderStatements = [\n            builder.var('data', builder.identifier('input'))\n        ];\n        var vars = createVarsArray(context.getVars());\n        if (vars.length) {\n            renderStatements.push(builder.vars(vars));\n        }\n\n        renderStatements = renderStatements.concat(body);\n\n        if (context.inline) {\n            var createInlineMarkoTemplateVar = context.helper('createInlineTemplate');\n\n            return builder.functionCall(\n                createInlineMarkoTemplateVar,\n                [\n                    builder.identifier('__filename'),\n                    builder.functionDeclaration(\n                        null,\n                        [\n                            builder.identifier('input'),\n                            builder.identifierOut()\n                        ],\n                        renderStatements)\n                ]);\n        } else {\n            var isBrowser = context.options.browser;\n            var createArgs = isBrowser ?\n                [] :\n                [ builder.identifier('__filename') ];\n\n            let templateDeclaration = builder.variableDeclarator('marko_template',\n                builder.assignment(\n                    builder.moduleExports(),\n                    builder.functionCall(\n                        builder.memberExpression(\n                            builder.require(\n                                builder.literal(context.getModuleRuntimeTarget())\n                            ),\n                            builder.identifier('t')\n                        ),\n                        createArgs\n                    )\n                )\n            );\n\n            let body = [];\n\n            if (context.writeVersionComment) {\n                body.push(_buildVersionComment(builder, context));\n            }\n\n            body.push(builder.literal('use strict'));\n\n            let staticNodes = context.getStaticNodes([templateDeclaration]);\n            if (staticNodes.length) {\n                body = body.concat(staticNodes);\n            }\n\n            var renderParams = [builder.identifier('input'), builder.identifierOut()];\n            if (this.extraRenderParams) {\n                renderParams = renderParams.concat(this.extraRenderParams);\n            }\n\n            let renderFunction = builder.functionDeclaration(\n                'render',\n                renderParams,\n                renderStatements);\n\n            body = body.concat([\n                renderFunction,\n            ]);\n\n            var assignRenderCode;\n\n            let templateVar = builder.identifier('marko_template');\n            let renderFunctionVar = builder.identifier('render');\n            let templateRendererMember = builder.memberExpression(\n                builder.identifier('marko_template'),\n                builder.identifier('_'));\n\n            if (this.generateAssignRenderCode) {\n                var eventArgs = {\n                    context,\n                    templateVar,\n                    templateRendererMember,\n                    renderFunctionVar\n                };\n\n                assignRenderCode = this.generateAssignRenderCode(eventArgs);\n            } else {\n\n                assignRenderCode = builder.assignment(\n                    templateRendererMember,\n                    renderFunctionVar);\n            }\n\n            if (assignRenderCode) {\n                body = body.concat(assignRenderCode);\n            }\n\n            if (context.useMeta && context.meta) {\n                body.push(builder.assignment(\n                    builder.memberExpression(builder.identifier('marko_template'), builder.identifier('meta')),\n                    builder.literal(context.meta)));\n            }\n\n            return builder.program(body);\n        }\n    }\n\n    toJSON(prettyPrinter) {\n        return {\n            type: this.type,\n            body: this.body\n        };\n    }\n\n    walk(walker) {\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = TemplateRoot;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/FunctionDeclaration.js":"'use strict';\n\nvar Node = require('./Node');\nvar ok = require('assert').ok;\n\nclass FunctionDeclaration extends Node {\n    constructor(def) {\n        super('FunctionDeclaration');\n        this.name = def.name;\n        this.params = def.params;\n        this.body = this.makeContainer(def.body);\n    }\n\n    generateCode(codegen) {\n        var oldInFunction = codegen.inFunction;\n        codegen.inFunction = true;\n        this.body = codegen.generateCode(this.body);\n        codegen.inFunction = oldInFunction;\n        return this;\n    }\n\n    writeCode(writer) {\n        var name = this.name;\n        var params = this.params;\n        var body = this.body;\n        var statement = this.statement;\n\n        if (name != null) {\n            ok(typeof name === 'string' || name.type === 'Identifier', 'Function name should be a string or Identifier');\n        }\n\n        if (name) {\n            writer.write('function ');\n            writer.write(name);\n            writer.write('(');\n        } else {\n            writer.write('function(');\n        }\n\n        if (params && params.length) {\n            for (let i=0, paramsLen = params.length; i<paramsLen; i++) {\n                if (i !== 0) {\n                    writer.write(', ');\n                }\n                var param = params[i];\n\n                if (typeof param === 'string') {\n                    writer.write(param);\n                } else {\n                    if (param.type !== 'Identifier') {\n                        throw new Error('Illegal param ' + JSON.stringify(param) + ' for FunctionDeclaration: ' + JSON.stringify(this));\n                    }\n                    writer.write(param);\n                }\n            }\n        }\n\n        writer.write(') ');\n\n        writer.writeBlock(body);\n\n        if (statement) {\n            writer.write('\\n');\n        }\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    walk(walker) {\n        this.name = walker.walk(this.name);\n        this.params = walker.walk(this.params);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = FunctionDeclaration;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/FunctionCall.js":"'use strict';\nvar ok = require('assert').ok;\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nclass FunctionCall extends Node {\n    constructor(def) {\n        super('FunctionCall');\n        this.callee = def.callee;\n\n        ok(this.callee, '\"callee\" is required');\n\n        let args = this.args = def.args;\n\n        if (args) {\n            if (!Array.isArray(args)) {\n                throw new Error('Invalid args');\n            }\n\n            for (let i=0; i<args.length; i++) {\n                let arg = args[i];\n                if (!arg) {\n                    throw new Error('Arg ' + i + ' is not valid for function call: ' + JSON.stringify(this.toJSON(), null, 2));\n                }\n            }\n        }\n    }\n\n    generateCode(codegen) {\n        this.callee = codegen.generateCode(this.callee);\n        this.args = codegen.generateCode(this.args);\n\n        return this;\n    }\n\n    writeCode(writer) {\n        var callee = this.callee;\n        var args = this.args;\n\n        var wrapWithParens = isCompoundExpression(callee);\n\n        if (wrapWithParens) {\n            writer.write('(');\n        }\n\n        writer.write(callee);\n\n        if (wrapWithParens) {\n            writer.write(')');\n        }\n\n        writer.write('(');\n\n        if (args && args.length) {\n            for (let i=0, argsLen = args.length; i<argsLen; i++) {\n                if (i !== 0) {\n                    writer.write(', ');\n                }\n\n                let arg = args[i];\n                if (!arg) {\n                    throw new Error('Arg ' + i + ' is not valid for function call: ' + JSON.stringify(this.toJSON()));\n                }\n                writer.write(arg);\n            }\n        }\n\n        writer.write(')');\n\n\n    }\n\n    walk(walker) {\n        this.callee = walker.walk(this.callee);\n        this.args = walker.walk(this.args);\n    }\n\n    toString() {\n        var callee = this.callee;\n        var args = this.args;\n\n        var result = callee.toString() + '(';\n\n        if (args && args.length) {\n            for (let i=0, argsLen = args.length; i<argsLen; i++) {\n                if (i !== 0) {\n                    result += ', ';\n                }\n\n                let arg = args[i];\n                if (!arg) {\n                    throw new Error('Arg ' + i + ' is not valid for function call: ' + JSON.stringify(this.toJSON()));\n                }\n                result += arg;\n            }\n        }\n\n        result += ')';\n        return result;\n    }\n}\n\nmodule.exports = FunctionCall;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/If.js":"'use strict';\n\nvar Node = require('./Node');\n\nfunction removeWhitespaceNodes(whitespaceNodes) {\n    for (var i=0; i<whitespaceNodes.length; i++) {\n        whitespaceNodes[i].detach();\n    }\n    whitespaceNodes.length = 0;\n}\n\nclass If extends Node {\n    constructor(def) {\n        super('If');\n        this.test = def.test;\n        this.body = this.makeContainer(def.body);\n        this.else = def.else;\n    }\n\n    generateCode(codegen) {\n        if (this.else) {\n            this.else.matched = true;\n        } else {\n            // We want to match up any else/else if statements\n            // with this node so that we can generate the code\n            // correctly.\n            let previous = this;\n            let whitespaceNodes = [];\n            this.forEachNextSibling((curNode) => {\n                if (curNode.type === 'Else') {\n                    curNode.detach();\n                    if (whitespaceNodes.length) {\n                        removeWhitespaceNodes(whitespaceNodes);\n                    }\n                    previous.else = curNode;\n                    curNode.matched = true;\n                    return false; // Stop searching\n                } else if (curNode.type === 'ElseIf') {\n                    curNode.detach();\n                    if (whitespaceNodes.length) {\n                        removeWhitespaceNodes(whitespaceNodes);\n                    }\n\n                    previous.else = curNode;\n                    previous = curNode;\n                    curNode.matched = true;\n                    return true; // Keep searching since they may be more ElseIf/Else nodes...\n                } else if (curNode.type === 'Text') {\n                    if (curNode.isWhitespace()) {\n                        whitespaceNodes.push(curNode);\n                        return true; // Just whitespace... keep searching\n                    } else {\n                        return false; // Stop searching\n                    }\n                } else {\n                    return false; // Stop searching\n                }\n            });\n        }\n\n        this.test = codegen.generateCode(this.test);\n        this.body = codegen.generateCode(this.body);\n        this.else = codegen.generateCode(this.else);\n\n        return this;\n    }\n\n    writeCode(writer) {\n        var test = this.test;\n        var body = this.body;\n\n        writer.write('if (');\n        writer.write(test);\n        writer.write(') ');\n        writer.writeBlock(body);\n        if (this.else) {\n            writer.write(' else ');\n            writer.write(this.else);\n        } else {\n            writer.write('\\n');\n        }\n    }\n\n    appendChild(newChild) {\n        this.body.appendChild(newChild);\n    }\n\n    walk(walker) {\n        this.test = walker.walk(this.test);\n        this.body = walker.walk(this.body);\n        this.else = walker.walk(this.else);\n    }\n}\n\nmodule.exports = If;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ElseIf.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ElseIf extends Node {\n    constructor(def) {\n        super('ElseIf');\n        this.test = def.test;\n        this.body = this.makeContainer(def.body);\n        this.else = def.else;\n        this.matched = false;\n    }\n\n    generateCode(codegen) {\n        if (!this.matched) {\n            codegen.addError('Unmatched else statement');\n            return;\n        }\n\n        return codegen.builder.ifStatement(this.test, this.body, this.else);\n    }\n\n    walk(walker) {\n        this.test = walker.walk(this.test);\n        this.body = walker.walk(this.body);\n        this.else = walker.walk(this.else);\n    }\n}\n\nmodule.exports = ElseIf;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Else.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass Else extends Node {\n    constructor(def) {\n        super('Else');\n        this.body = this.makeContainer(def.body);\n        this.matched = false;\n    }\n\n    generateCode(codegen) {\n        if (!this.matched) {\n            codegen.addError('Unmatched else statement');\n            return;\n        }\n\n        this.body = codegen.generateCode(this.body);\n        return this;\n    }\n\n    writeCode(writer) {\n        var body = this.body;\n        writer.writeBlock(body);\n        writer.write('\\n');\n    }\n\n    walk(walker) {\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = Else;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Assignment.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass Assignment extends Node {\n    constructor(def) {\n        super('Assignment');\n        this.left = def.left;\n        this.right = def.right;\n        this.operator = def.operator;\n    }\n\n    generateCode(codegen) {\n        this.left = codegen.generateCode(this.left);\n        this.right = codegen.generateCode(this.right);\n        return this;\n    }\n\n    writeCode(writer) {\n        var left = this.left;\n        var right = this.right;\n        var operator = this.operator;\n\n        writer.write(left);\n        writer.write(' '  + (operator || '=') + ' ');\n\n        var wrap = right instanceof Assignment;\n\n        if (wrap) {\n            writer.write('(');\n        }\n\n        writer.write(right);\n\n        if (wrap) {\n            writer.write(')');\n        }\n    }\n\n    walk(walker) {\n        this.left = walker.walk(this.left);\n        this.right = walker.walk(this.right);\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    /**\n     * \"noOutput\" should be true if the Node.js does not result in any HTML or Text output\n     */\n    get noOutput() {\n        return !(this.body && this.body.length);\n    }\n\n    toString() {\n        var left = this.left;\n        var right = this.right;\n        var operator = this.operator;\n\n        var result = left.toString() + ' ' + (operator || '=') + ' ';\n\n        var wrap = right instanceof Assignment;\n\n        if (wrap) {\n            result += '(';\n        }\n\n        result += right.toString();\n\n        if (wrap) {\n            result += ')';\n        }\n\n        return result;\n    }\n}\n\nmodule.exports = Assignment;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/BinaryExpression.js":"'use strict';\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nfunction writeCodeForOperand(node, writer) {\n    var wrap = isCompoundExpression(node);\n\n    if (wrap) {\n        writer.write('(');\n    }\n\n    writer.write(node);\n\n    if (wrap) {\n        writer.write(')');\n    }\n}\n\nfunction operandToString(node) {\n    var wrap = isCompoundExpression(node);\n\n    var result = '';\n\n    if (wrap) {\n        result += '(';\n    }\n\n    result += node.toString();\n\n    if (wrap) {\n        result += ')';\n    }\n\n    return result;\n}\n\nclass BinaryExpression extends Node {\n    constructor(def) {\n        super('BinaryExpression');\n        this.left = def.left;\n        this.operator = def.operator;\n        this.right = def.right;\n    }\n\n    generateCode(codegen) {\n        this.left = codegen.generateCode(this.left);\n        this.right = codegen.generateCode(this.right);\n\n        var left = this.left;\n        var right = this.right;\n        var operator = this.operator;\n\n        if (!left || !right) {\n            throw new Error('Invalid BinaryExpression: ' + this);\n        }\n\n        var builder = codegen.builder;\n\n        if (left.type === 'Literal' && right.type === 'Literal') {\n            if (operator === '+') {\n                return builder.literal(left.value + right.value);\n            } else if (operator === '-') {\n                return builder.literal(left.value - right.value);\n            } else if (operator === '*') {\n                return builder.literal(left.value * right.value);\n            } else if (operator === '/') {\n                return builder.literal(left.value / right.value);\n            }\n        }\n\n        return this;\n    }\n\n    writeCode(writer) {\n        var left = this.left;\n        var operator = this.operator;\n        var right = this.right;\n\n        if (!left || !right) {\n            throw new Error('Invalid BinaryExpression: ' + this);\n        }\n\n        writeCodeForOperand(left, writer);\n        writer.write(' ');\n        writer.write(operator);\n        writer.write(' ');\n        writeCodeForOperand(right, writer);\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'BinaryExpression',\n            left: this.left,\n            operator: this.operator,\n            right: this.right\n        };\n    }\n\n    walk(walker) {\n        this.left = walker.walk(this.left);\n        this.right = walker.walk(this.right);\n    }\n\n    toString() {\n        var left = this.left;\n        var operator = this.operator;\n        var right = this.right;\n\n        if (!left || !right) {\n            throw new Error('Invalid BinaryExpression: ' + this);\n        }\n\n        return operandToString(left) + ' ' + operator + ' ' + operandToString(right);\n    }\n}\n\nmodule.exports = BinaryExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/LogicalExpression.js":"'use strict';\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nfunction generateCodeForOperand(node, writer) {\n    var wrap = isCompoundExpression(node);\n\n    if (wrap) {\n        writer.write('(');\n    }\n\n    writer.write(node);\n\n    if (wrap) {\n        writer.write(')');\n    }\n}\n\nfunction operandToString(node) {\n    var wrap = isCompoundExpression(node);\n\n    var result = '';\n\n    if (wrap) {\n        result += '(';\n    }\n\n    result += node;\n\n    if (wrap) {\n        result += ')';\n    }\n\n    return result;\n}\n\nclass LogicalExpression extends Node {\n    constructor(def) {\n        super('LogicalExpression');\n        this.left = def.left;\n        this.operator = def.operator;\n        this.right = def.right;\n    }\n\n    generateCode(codegen) {\n        this.left = codegen.generateCode(this.left);\n        this.right = codegen.generateCode(this.right);\n        return this;\n    }\n\n    writeCode(writer) {\n        var left = this.left;\n        var operator = this.operator;\n        var right = this.right;\n\n        if (!left || !right) {\n            throw new Error('Invalid LogicalExpression: ' + this);\n        }\n\n        generateCodeForOperand(left, writer);\n        writer.write(' ');\n        writer.write(operator);\n        writer.write(' ');\n        generateCodeForOperand(right, writer);\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'LogicalExpression',\n            left: this.left,\n            operator: this.operator,\n            right: this.right\n        };\n    }\n\n    walk(walker) {\n        this.left = walker.walk(this.left);\n        this.right = walker.walk(this.right);\n    }\n\n    toString() {\n        var left = this.left;\n        var operator = this.operator;\n        var right = this.right;\n\n        if (!left || !right) {\n            throw new Error('Invalid LogicalExpression: ' + this);\n        }\n\n        return operandToString(left) + ' ' + operator + ' ' + operandToString(right);\n    }\n}\n\nmodule.exports = LogicalExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Vars.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass Vars extends Node {\n    constructor(def) {\n        super('Vars');\n        this.kind = def.kind || 'var';\n        this.declarations = def.declarations;\n        this.body = this.makeContainer(def.body);\n    }\n\n    generateCode(codegen) {\n        var declarations = this.declarations;\n\n        if (!declarations || !declarations.length) {\n            return null;\n        }\n\n        this.declarations = codegen.generateCode(this.declarations);\n\n        if (this.body && this.body.length) {\n            var scopedBody = [this].concat(this.body);\n            this.body = null;\n            return codegen.builder.selfInvokingFunction(scopedBody);\n        }\n\n        return this;\n    }\n\n    writeCode(writer) {\n        var declarations = this.declarations;\n        var kind = this.kind;\n        var isStatement = this.statement;\n\n\n        if (!declarations || !declarations.length) {\n            return;\n        }\n\n        writer.incIndent(4);\n\n        for (let i=0; i<declarations.length; i++) {\n            var declarator = declarations[i];\n\n            if (i === 0) {\n                writer.write(kind + ' ');\n            } else {\n                writer.writeLineIndent();\n            }\n\n            writer.write(declarator);\n\n            if (i < declarations.length - 1) {\n                writer.write(',\\n');\n            } else {\n                if (isStatement) {\n                    writer.write(';\\n');\n                }\n            }\n        }\n\n        writer.decIndent(4);\n    }\n\n    walk(walker) {\n        this.argument = walker.walk(this.argument);\n    }\n\n    /**\n     * \"noOutput\" should be true if the Node.js does not result in any HTML or Text output\n     */\n    get noOutput() {\n        return !(this.body && this.body.length);\n    }\n}\n\nmodule.exports = Vars;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Return.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass Return extends Node {\n    constructor(def) {\n        super('Return');\n        this.argument = def.argument;\n    }\n\n    generateCode(codegen) {\n        if (!codegen.inFunction) {\n            throw new Error('\"return\" not allowed outside a function body');\n        }\n\n        this.argument = codegen.generateCode(this.argument);\n        return this;\n    }\n\n    writeCode(writer) {\n        var argument = this.argument;\n\n        if (argument) {\n            writer.write('return ');\n            writer.write(argument);\n        } else {\n            writer.write('return');\n        }\n    }\n\n    walk(walker) {\n        this.argument = walker.walk(this.argument);\n    }\n}\n\nmodule.exports = Return;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Text/index.js":"'use strict';\n\nvar ok = require('assert').ok;\nvar Node = require('../Node');\nvar Literal = require('../Literal');\n\nvar generateHTMLCode = require('./html/generateCode');\nvar generateVDOMCode = require('./vdom/generateCode');\nvar vdomUtil = require('../../util/vdom');\n\nclass Text extends Node {\n    constructor(def) {\n        super('Text');\n        this.argument = def.argument;\n        this.escape = def.escape !== false;\n        this.normalized = false;\n        this.isFirst = false;\n        this.isLast = false;\n        this.preserveWhitespace = def.preserveWhitespace === true;\n\n        ok(this.argument, 'Invalid argument');\n    }\n\n    generateHTMLCode(codegen) {\n        return generateHTMLCode(this, codegen);\n    }\n\n    generateVDOMCode(codegen) {\n        return generateVDOMCode(this, codegen, vdomUtil);\n    }\n\n    isLiteral() {\n        return this.argument instanceof Node && this.argument.type === 'Literal';\n    }\n\n    isWhitespace() {\n        var argument = this.argument;\n        return (argument instanceof Literal) &&\n            (typeof argument.value === 'string') &&\n            (argument.value.trim() === '');\n    }\n\n    toJSON() {\n        return {\n            type: this.type,\n            argument: this.argument\n        };\n    }\n}\n\nmodule.exports = Text;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Text/html/generateCode.js":"'use strict';\n\nvar escapeXml = require('../../../../runtime/html/helpers').x;\nvar Literal = require('../../Literal');\n\nmodule.exports = function(node, codegen) {\n    var context = codegen.context;\n    var argument = codegen.generateCode(node.argument);\n    var escape = node.escape !== false;\n\n    var htmlArray = [];\n\n    function append(argument) {\n        if (argument instanceof Literal) {\n            if (!argument.value) {\n                return;\n            }\n\n            if (context.isFlagSet('SCRIPT_BODY') || context.isFlagSet('STYLE_BODY')) {\n                escape = false;\n            }\n\n            if (escape === true) {\n                argument.value = escapeXml(argument.value.toString());\n            }\n\n            htmlArray.push(argument);\n        } else {\n            let builder = codegen.builder;\n\n            if (escape) {\n                let escapeIdentifier = context.helper('escapeXml');\n\n                if (context.isFlagSet('SCRIPT_BODY')) {\n                    escapeIdentifier = context.helper('escapeScript');\n                }\n\n                if (context.isFlagSet('STYLE_BODY')) {\n                    escapeIdentifier = context.helper('escapeStyle');\n                }\n\n                // TODO Only escape the parts that need to be escaped if it is a compound expression with static\n                //      text parts\n                argument = builder.functionCall(\n                    escapeIdentifier,\n                    [argument]);\n            } else {\n                argument = builder.functionCall(context.helper('str'), [ argument ]);\n            }\n            htmlArray.push(argument);\n        }\n    }\n\n    if (Array.isArray(argument)) {\n        argument.forEach(append);\n    } else {\n        append(argument);\n    }\n\n    if (htmlArray.length) {\n        return codegen.builder.html(htmlArray);\n    } else {\n        return null;\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Text/vdom/generateCode.js":"'use strict';\n\nvar TextVDOM = require('./TextVDOM');\nvar Literal = require('../../Literal');\nvar he = require('he'); // Used for dealing with HTML entities\n\nmodule.exports = function(node, codegen, vdomUtil) {\n    var argument = codegen.generateCode(node.argument);\n    var escape = node.escape !== false;\n    var isStatic = null;\n\n    if (codegen.context.isFlagSet('SCRIPT_BODY')) {\n        escape = true;\n    }\n\n    if (argument instanceof Literal) {\n        var literalValue = argument.value;\n        if (literalValue == null || literalValue === '') {\n            // Don't add empty text nodes to the final tree\n            return null;\n        }\n\n        if (escape === false) {\n            escape = true;\n\n            if (typeof literalValue === 'string') {\n                if (literalValue.indexOf('<') !== -1) {\n                    escape = false;\n                } else if (literalValue.indexOf('&') !== -1) {\n                    argument = codegen.builder.literal(he.decode(literalValue));\n                }\n            }\n        }\n\n    }\n\n    isStatic = isStatic == null ? vdomUtil.isStaticValue(argument) : isStatic;\n    return new TextVDOM({ argument, isStatic, escape });\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Text/vdom/TextVDOM.js":"'use strict';\n\nconst Node = require('../../Node');\nconst Literal = require('../../Literal');\nconst vdomUtil = require('../../../util/vdom');\n\nclass TextVDOM extends Node {\n    constructor(def) {\n        super('TextVDOM');\n        this.arguments = [def.argument];\n        this.isStatic = def.isStatic;\n        this.escape = def.escape !== false;\n        this.isHtmlOnly = true;\n        this.isChild = false;\n        this.createTextId = undefined;\n        this.strFuncId = undefined;\n    }\n\n    generateCode(codegen) {\n        var context = codegen.context;\n\n        vdomUtil.registerOptimizer(context);\n\n        return this;\n    }\n\n    _append(appendArgument) {\n        let args = this.arguments;\n        let len = args.length;\n        let last = args[len-1];\n\n        if (last instanceof Literal && appendArgument instanceof Literal) {\n            last.value += appendArgument.value;\n        } else {\n            args.push(appendArgument);\n        }\n    }\n\n    append(textVDOMToAppend) {\n        if (textVDOMToAppend.escape !== this.escape) {\n            return false;\n        }\n\n        if (!textVDOMToAppend.isStatic) {\n            this.isStatic = false;\n        }\n\n        if (textVDOMToAppend.strFuncId) {\n            this.strFuncId = textVDOMToAppend.strFuncId;\n        }\n\n        textVDOMToAppend.arguments.forEach(this._append, this);\n\n        return true;\n    }\n\n    writeCode(writer) {\n        let builder = writer.builder;\n        let args = this.arguments;\n        let escape = this.escape;\n\n        var funcName = escape ? 't' : 'h';\n\n        function writeTextArgs() {\n            writer.write('(');\n\n            for (let i=0, len=args.length; i<len; i++) {\n                let arg = args[i];\n\n                if (i !== 0) {\n                    writer.write(' +\\n');\n                    writer.writeLineIndent();\n                    writer.writeIndent();\n                }\n\n                writer.write(arg);\n            }\n\n            writer.write(')');\n        }\n\n        if (this.isChild) {\n            writer.write('.');\n            writer.write(builder.identifier(funcName));\n        } else if (this.isStatic && this.createTextId) {\n            writer.write(this.createTextId);\n        } else {\n            writer.write('out.');\n            writer.write(builder.identifier(funcName));\n        }\n\n        writeTextArgs();\n    }\n}\n\nmodule.exports = TextVDOM;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ForEach.js":"'use strict';\nvar ok = require('assert').ok;\nvar Node = require('./Node');\n\nclass ForEach extends Node {\n    constructor(def) {\n        super('ForEach');\n        this.varName = def.varName;\n        this.in = def.in;\n        this.body = this.makeContainer(def.body);\n        this.separator = def.separator;\n        this.statusVarName = def.statusVarName;\n        this.iterator = def.iterator;\n        this.isArray = def.isArray;\n\n        ok(this.varName, '\"varName\" is required');\n        ok(this.in != null, '\"in\" is required');\n    }\n\n    generateCode(codegen) {\n        var varName = this.varName;\n        var inExpression = this.in;\n        var separator = this.separator;\n        var statusVarName = this.statusVarName;\n        var iterator = this.iterator;\n        var context = codegen.context;\n        var builder = codegen.builder;\n        var isArray = this.isArray;\n\n        if (separator && !statusVarName) {\n            statusVarName = '__loop';\n        }\n\n        if (iterator) {\n            let params = [varName];\n\n            if (statusVarName) {\n                params.push(statusVarName);\n            }\n\n            return builder.functionCall(iterator, [\n                inExpression,\n                builder.functionDeclaration(null, params, this.body)\n            ]);\n        } else if (statusVarName) {\n\n            let body = this.body;\n\n            if (separator) {\n                let isNotLastTest = builder.functionCall(\n                    builder.memberExpression(statusVarName, builder.identifier('isLast')),\n                    []);\n\n                isNotLastTest = builder.negate(isNotLastTest);\n\n                body = body.items.concat([\n                    builder.ifStatement(isNotLastTest, [\n                        builder.text(separator, false)\n                    ])\n                ]);\n            }\n\n            return builder.functionCall(context.helper('forEachWithStatusVar'), [\n                inExpression,\n                builder.functionDeclaration(null, [varName, statusVarName], body)\n            ]);\n        } else {\n            if (isArray) {\n                context.addVar(varName.name);\n                var indexVarId = context.addVar(varName.name + '__i');\n                var arrayVarId = context.addVar(varName.name + '__array');\n                var lengthVarId = context.addVar(varName.name + '__len');\n\n                var init = builder.sequenceExpression([\n                    builder.assignment(indexVarId, builder.literal(0)),\n                    builder.assignment(arrayVarId, inExpression),\n                    builder.assignment(lengthVarId, builder.binaryExpression(arrayVarId, '&&', builder.memberExpression(arrayVarId, builder.identifier('length'))))\n                ]);\n\n                var test = builder.binaryExpression(indexVarId, '<', lengthVarId);\n\n                var update = builder.unaryExpression(indexVarId, '++');\n\n                var loopBody = [\n                        builder.assignment(varName, builder.memberExpression(arrayVarId, indexVarId, true))\n                    ].concat(this.body);\n\n                return builder.forStatement(init, test, update, loopBody);\n            } else {\n                return builder.functionCall(context.helper('forEach'), [\n                    inExpression,\n                    builder.functionDeclaration(null, [varName], this.body)\n                ]);\n            }\n        }\n    }\n\n    walk(walker) {\n        this.varName = walker.walk(this.varName);\n        this.in = walker.walk(this.in);\n        this.body = walker.walk(this.body);\n        this.separator = walker.walk(this.separator);\n        this.statusVarName = walker.walk(this.statusVarName);\n        this.iterator = walker.walk(this.iterator);\n    }\n}\n\nmodule.exports = ForEach;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ForEachProp.js":"'use strict';\nvar ok = require('assert').ok;\nvar Node = require('./Node');\n\nclass ForEachProp extends Node {\n    constructor(def) {\n        super('ForEachProp');\n        this.nameVarName = def.nameVarName;\n        this.valueVarName = def.valueVarName;\n        this.in = def.in;\n        this.separator = def.separator;\n        this.statusVarName = def.statusVarName;\n        this.body = this.makeContainer(def.body);\n\n        ok(this.nameVarName, '\"nameVarName\" is required');\n        ok(this.valueVarName != null, '\"valueVarName\" is required');\n        ok(this.in != null, '\"in\" is required');\n    }\n\n    generateCode(codegen) {\n        var context = codegen.context;\n        var nameVarName = this.nameVarName;\n        var valueVarName = this.valueVarName;\n        var inExpression = this.in;\n        var body = this.body;\n        var separator = this.separator;\n        var statusVarName = this.statusVarName;\n\n        if (separator && !statusVarName) {\n            statusVarName = '__loop';\n        }\n\n        var builder = codegen.builder;\n\n        if (statusVarName) {\n            let helperVar = context.helper('forEachPropStatusVar');\n            let forEachVarName = codegen.addStaticVar('forEacPropStatusVar', helperVar);\n            let body = this.body;\n\n            if (separator) {\n                let isNotLastTest = builder.functionCall(\n                    builder.memberExpression(statusVarName, builder.identifier('isLast')),\n                    []);\n\n                isNotLastTest = builder.negate(isNotLastTest);\n\n                body = body.items.concat([\n                    builder.ifStatement(isNotLastTest, [\n                        builder.text(separator)\n                    ])\n                ]);\n            }\n\n            return builder.functionCall(forEachVarName, [\n                inExpression,\n                builder.functionDeclaration(null, [nameVarName, valueVarName, statusVarName], body)\n            ]);\n        } else {\n            return builder.functionCall(\n                context.helper('forEachProp'),\n                [\n                    inExpression,\n                    builder.functionDeclaration(null, [nameVarName, valueVarName], body)\n                ]);\n        }\n    }\n\n    walk(walker) {\n        this.nameVarName = walker.walk(this.nameVarName);\n        this.valueVarName = walker.walk(this.valueVarName);\n        this.in = walker.walk(this.in);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = ForEachProp;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ForRange.js":"'use strict';\nvar ok = require('assert').ok;\nvar Node = require('./Node');\nvar Literal = require('./Literal');\nvar Identifier = require('./Identifier');\n\nclass ForRange extends Node {\n    constructor(def) {\n        super('ForRange');\n        this.varName = def.varName;\n        this.body = this.makeContainer(def.body);\n        this.from = def.from;\n        this.to = def.to;\n        this.step = def.step;\n\n        ok(this.varName, '\"varName\" is required');\n        ok(this.from != null, '\"from\" is required');\n    }\n\n    generateCode(codegen) {\n        var context = codegen.context;\n\n        var varName = this.varName;\n        var from = this.from;\n        var to = this.to;\n        var step = this.step;\n\n        var builder = codegen.builder;\n\n        if (varName instanceof Identifier) {\n            varName = varName.name;\n        }\n\n        if (step == null) {\n            let fromLiteral = (from instanceof Literal) && from.value;\n            let toLiteral = (to instanceof Literal) && to.value;\n\n            if (typeof fromLiteral === 'number' && typeof toLiteral === 'number') {\n                if (fromLiteral > toLiteral) {\n                    step = builder.literal(-1);\n                } else {\n                    step = builder.literal(1);\n                }\n            }\n        }\n\n        if (step == null) {\n            step = builder.literalNull();\n        }\n\n        return builder.functionCall(context.helper('forRange'), [\n            from,\n            to,\n            step,\n            builder.functionDeclaration(null, [varName], this.body)\n        ]);\n    }\n\n    walk(walker) {\n        this.varName = walker.walk(this.varName);\n        this.body = walker.walk(this.body);\n        this.from = walker.walk(this.from);\n        this.to = walker.walk(this.to);\n        this.step = walker.walk(this.step);\n    }\n}\n\nmodule.exports = ForRange;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/HtmlComment.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass HtmlComment extends Node {\n    constructor(def) {\n        super('HtmlComment');\n        this.comment = def.comment;\n    }\n\n    generateHTMLCode(codegen) {\n        var comment = this.comment;\n        var builder = codegen.builder;\n\n        return [\n            builder.htmlLiteral('<!--'),\n            builder.html(comment),\n            builder.htmlLiteral('-->')\n        ];\n    }\n\n    generateVDOMCode(codegen) {\n        var comment = this.comment;\n        var builder = codegen.builder;\n\n        return builder.functionCall(\n            builder.memberExpression(\n                builder.identifierOut(),\n                builder.identifier('comment')),\n            [\n                comment\n            ]);\n    }\n\n    walk(walker) {\n        this.comment = walker.walk(this.comment);\n    }\n}\n\nmodule.exports = HtmlComment;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/SelfInvokingFunction.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass SelfInvokingFunction extends Node {\n    constructor(def) {\n        super('SelfInvokingFunction');\n        this.params = def.params;\n        this.args = def.args;\n        this.body = this.makeContainer(def.body);\n    }\n\n    generateCode(codegen) {\n        var params = this.params || [];\n        var args = this.args || [];\n        var oldInFunction = codegen.inFunction;\n        codegen.inFunction = true;\n        var body = codegen.generateCode(this.body);\n        codegen.inFunction = oldInFunction;\n\n        var functionDeclaration = codegen.builder.functionDeclaration(null, params, body);\n        var functionCall = codegen.builder.functionCall(functionDeclaration, args);\n\n        return functionCall;\n    }\n\n    walk(walker) {\n        this.params = walker.walk(this.params);\n        this.args = walker.walk(this.args);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = SelfInvokingFunction;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ForStatement.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ForStatement extends Node {\n    constructor(def) {\n        super('ForStatement');\n        this.init = def.init;\n        this.test = def.test;\n        this.update = def.update;\n        this.body = this.makeContainer(def.body);\n    }\n\n    generateCode(codegen) {\n        this.init = codegen.generateCode(this.init);\n        this.test = codegen.generateCode(this.test);\n        this.update = codegen.generateCode(this.update);\n        this.body = codegen.generateCode(this.body);\n        return this;\n    }\n\n    writeCode(writer) {\n        var init = this.init;\n        var test = this.test;\n        var update = this.update;\n        var body = this.body;\n\n        writer.write('for (');\n\n        if (init) {\n            writer.write(init);\n        }\n\n        writer.write('; ');\n\n        if (test) {\n            writer.write(test);\n        }\n\n        writer.write('; ');\n\n        if (update) {\n            writer.write(update);\n        }\n\n        writer.write(') ');\n\n        writer.writeBlock(body);\n\n        writer.write('\\n');\n    }\n\n    walk(walker) {\n        this.init = walker.walk(this.init);\n        this.test = walker.walk(this.test);\n        this.update = walker.walk(this.update);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = ForStatement;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/UpdateExpression.js":"'use strict';\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nclass UpdateExpression extends Node {\n    constructor(def) {\n        super('UpdateExpression');\n        this.argument = def.argument;\n        this.operator = def.operator;\n        this.prefix = def.prefix === true;\n    }\n\n    generateCode(codegen) {\n        this.argument = codegen.generateCode(this.argument);\n        return this;\n    }\n\n    writeCode(writer) {\n        var argument = this.argument;\n        var operator = this.operator;\n        var prefix = this.prefix;\n\n        if (prefix) {\n            writer.write(operator);\n        }\n\n        var wrap = isCompoundExpression(argument);\n\n        if (wrap) {\n            writer.write('(');\n        }\n\n        writer.write(argument);\n\n        if (wrap) {\n            writer.write(')');\n        }\n\n        if (!prefix) {\n            writer.write(operator);\n        }\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'UpdateExpression',\n            argument: this.argument,\n            operator: this.operator,\n            prefix: this.prefix\n        };\n    }\n\n    walk(walker) {\n        this.argument = walker.walk(this.argument);\n    }\n\n    toString() {\n        var argument = this.argument;\n        var operator = this.operator;\n        var prefix = this.prefix;\n\n        let result = '';\n\n        if (prefix) {\n            result += operator;\n        }\n\n        var wrap = isCompoundExpression(argument);\n\n        if (wrap) {\n            result += '(';\n        }\n\n        result += argument;\n\n        if (wrap) {\n            result += ')';\n        }\n\n        if (!prefix) {\n            result += operator;\n        }\n\n        return result;\n    }\n}\n\nmodule.exports = UpdateExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/UnaryExpression.js":"'use strict';\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nclass UnaryExpression extends Node {\n    constructor(def) {\n        super('UnaryExpression');\n        this.argument = def.argument;\n        this.operator = def.operator;\n        this.prefix = def.prefix === true;\n    }\n\n    generateCode(codegen) {\n        this.argument = codegen.generateCode(this.argument);\n        return this;\n    }\n\n    writeCode(writer) {\n        var argument = this.argument;\n        var operator = this.operator;\n        var prefix = this.prefix;\n\n        if (prefix) {\n            writer.write(operator);\n\n            if (operator === 'typeof' || operator === 'delete') {\n                writer.write(' ');\n            }\n        }\n\n        var wrap = isCompoundExpression(argument);\n\n        if (wrap) {\n            writer.write('(');\n        }\n\n        writer.write(argument);\n\n        if (wrap) {\n            writer.write(')');\n        }\n\n        if (!prefix) {\n            writer.write(operator);\n        }\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'UnaryExpression',\n            argument: this.argument,\n            operator: this.operator,\n            prefix: this.prefix\n        };\n    }\n\n    walk(walker) {\n        this.argument = walker.walk(this.argument);\n    }\n\n    toString() {\n        var argument = this.argument;\n        var operator = this.operator;\n        var prefix = this.prefix;\n\n        let result = '';\n\n        if (prefix) {\n            result += operator;\n\n            if (operator === 'typeof' || operator === 'delete') {\n                result += ' ';\n            }\n        }\n\n        var wrap = isCompoundExpression(argument);\n\n        if (wrap) {\n            result += '(';\n        }\n\n        result += argument;\n\n        if (wrap) {\n            result += ')';\n        }\n\n        if (!prefix) {\n            result += operator;\n        }\n\n        return result;\n    }\n}\n\nmodule.exports = UnaryExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/MemberExpression.js":"'use strict';\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\nvar ok = require('assert').ok;\n\nclass MemberExpression extends Node {\n    constructor(def) {\n        super('MemberExpression');\n        this.object = def.object;\n        this.property = def.property;\n        this.computed = def.computed;\n\n        ok(this.object, '\"object\" is required');\n        ok(this.property, '\"property\" is required');\n    }\n\n    generateCode(codegen) {\n        this.object = codegen.generateCode(this.object);\n        this.property = codegen.generateCode(this.property);\n        return this;\n    }\n\n    writeCode(writer) {\n        var object = this.object;\n        var property = this.property;\n        var computed = this.computed;\n\n        var wrapWithParens = isCompoundExpression(object);\n\n        if (wrapWithParens) {\n            writer.write('(');\n        }\n\n        writer.write(object);\n\n        if (wrapWithParens) {\n            writer.write(')');\n        }\n\n        if (computed) {\n            writer.write('[');\n            writer.write(property);\n            writer.write(']');\n        } else {\n            writer.write('.');\n            writer.write(property);\n        }\n    }\n\n    toJSON() {\n        return {\n            type: 'MemberExpression',\n            object: this.object,\n            property: this.property,\n            computed: this.computed\n        };\n    }\n\n    walk(walker) {\n        this.object = walker.walk(this.object);\n        this.property = walker.walk(this.property);\n    }\n\n    toString() {\n        var object = this.object;\n        var property = this.property;\n        var computed = this.computed;\n\n        var result = object.toString();\n\n        if (computed) {\n            result += '[' + property + ']';\n        } else {\n            result += '.' + property;\n        }\n\n        return result;\n    }\n}\n\nmodule.exports = MemberExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Code.js":"'use strict';\n\nvar Node = require('./Node');\nvar adjustIndent = require('../util/adjustIndent');\n\nclass Code extends Node {\n    constructor(def) {\n        super('Code');\n        this.value = def.value;\n    }\n\n    generateCode(codegen) {\n        return this;\n    }\n\n    writeCode(writer) {\n        var code = this.value;\n\n        if (!code) {\n            return;\n        }\n\n        code = adjustIndent(code, writer.currentIndent);\n\n        writer.write(code);\n    }\n}\n\nmodule.exports = Code;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/adjustIndent.js":"var splitLinesRegExp = /\\r?\\n/;\nvar initialIndentationRegExp = /^\\s+/;\n\nfunction removeInitialEmptyLines(lines) {\n    var i;\n\n    for (i=0; i<lines.length; i++) {\n        if (lines[i].trim() !== '') {\n            break;\n        }\n    }\n\n    if (i !== 0) {\n        lines = lines.slice(i);\n    }\n\n    return lines;\n}\n\nfunction removeTrailingEmptyLines(lines) {\n    var i;\n    var last = lines.length-1;\n\n    for (i=last; i>=0; i--) {\n        if (lines[i].trim() !== '') {\n            break;\n        }\n    }\n\n    if (i !== last) {\n        lines = lines.slice(0, i+1);\n    }\n\n    return lines;\n}\n\nfunction adjustIndent(str, newIndentation) {\n    if (!str) {\n        return str;\n    }\n\n    var lines = str.split(splitLinesRegExp);\n    lines = removeInitialEmptyLines(lines);\n    lines = removeTrailingEmptyLines(lines);\n\n    if (lines.length === 0) {\n        return '';\n    }\n\n    var initialIndentationMatches = initialIndentationRegExp.exec(lines[0]);\n\n    var indentation = initialIndentationMatches ? initialIndentationMatches[0] : '';\n    if (!indentation && !newIndentation) {\n        return str;\n    }\n\n    lines.forEach((line, i) => {\n        if (line.startsWith(indentation)) {\n            line = line.substring(indentation.length);\n        }\n\n        lines[i] = line;\n    });\n\n    return newIndentation ?\n        lines.join('\\n' + newIndentation) :\n        lines.join('\\n');\n}\n\nmodule.exports = adjustIndent;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/InvokeMacro.js":"'use strict';\n\nvar Node = require('./Node');\nvar ok = require('assert').ok;\n\nfunction removeTrailingUndefineds(args) {\n    var i;\n    var last = args.length-1;\n\n    for (i=last; i>=0; i--) {\n        if (args[i].type !== 'Literal' || args[i].value !== undefined) {\n            break;\n        }\n    }\n\n    if (i !== last) {\n        args = args.slice(0, i+1);\n    }\n\n    return args;\n}\n\n\nclass InvokeMacro extends Node {\n    constructor(def) {\n        super('InvokeMacro');\n        this.el = def.el;\n        this.name = def.name;\n        this.args = def.args;\n        this.body = this.makeContainer(def.body);\n\n        if (this.name != null) {\n            ok(typeof this.name === 'string', 'Invalid macro name: ' + this.name);\n        }\n    }\n\n    generateCode(codegen) {\n        var el = this.el;\n        var name = this.name;\n        var args = this.args;\n        var body = this.body;\n\n        var builder = codegen.builder;\n\n        var macroDef;\n\n        if (el) {\n            name = el.tagName;\n            body = el.body;\n\n            if (typeof name !== 'string') {\n                codegen.context.addError(el, 'Element node with a dynamic tag name cannot be used to invoke a macro', 'ERR_INVOKE_MACRO');\n                return;\n            }\n\n            macroDef = codegen.context.getRegisteredMacro(name);\n\n            if (!macroDef) {\n                codegen.context.addError(el, 'Element node does not correspond to a macro', 'ERR_INVOKE_MACRO');\n                return;\n            }\n\n            if (el.argument) {\n                args = builder.parseJavaScriptArgs(el.argument);\n            } else {\n                args = new Array(macroDef.params.length);\n                for (let i=0; i<args.length; i++) {\n                    args[i] = builder.literal(undefined);\n                }\n\n                el.forEachAttribute((attr) => {\n                    var paramName = attr.name;\n                    var paramIndex = macroDef.getParamIndex(paramName);\n                    if (paramIndex == null) {\n                        codegen.context.addError(el, 'The \"' + name + '\" macro does not have a parameter named \"' + paramName + '\"', 'ERR_INVOKE_MACRO');\n                        return;\n                    }\n\n                    var value = attr.value;\n                    if (value == null) {\n                        value = builder.literal(true);\n                    }\n                    args[paramIndex] = value;\n                });\n            }\n        } else {\n            macroDef = codegen.context.getRegisteredMacro(name);\n            if (!macroDef) {\n                codegen.addError('Macro not found with name \"' + name + '\"', 'ERR_INVOKE_MACRO');\n                return;\n            }\n        }\n\n        if (!args) {\n            args = [];\n        }\n\n        while (args.length < macroDef.params.length) {\n            args.push(builder.literal(undefined));\n        }\n\n        if (body && body.length) {\n            args[macroDef.getParamIndex('renderBody')] = builder.renderBodyFunction(body);\n        }\n\n        args[macroDef.getParamIndex('out')] = builder.identifier('out');\n\n        args = removeTrailingUndefineds(args);\n\n        return builder.functionCall(builder.identifier(macroDef.functionName), args);\n    }\n\n    walk(walker) {\n        this.el = walker.walk(this.el);\n        this.name = walker.walk(this.name);\n        this.args = walker.walk(this.args);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = InvokeMacro;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Macro.js":"'use strict';\n\nvar Node = require('./Node');\nvar ok = require('assert').ok;\n\nclass Macro extends Node {\n    constructor(def) {\n        super('Macro');\n        this.name = def.name;\n        this.params = def.params;\n        this.body = this.makeContainer(def.body);\n\n        if (this.params == null) {\n            this.params = [];\n        } else {\n            ok(Array.isArray(this.params), '\"params\" should be an array');\n        }\n    }\n\n    generateCode(codegen) {\n        var name = this.name;\n        var params = this.params || [];\n        var builder = codegen.builder;\n        var macroDef = codegen.context.registerMacro(name, params);\n        var functionName = macroDef.functionName;\n\n        // Walk the body after registering the macro\n        var body = codegen.generateCode(this.body);\n\n        return builder.functionDeclaration(functionName, macroDef.params, body);\n    }\n\n    walk(walker) {\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = Macro;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ConditionalExpression.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ConditionalExpression extends Node {\n    constructor(def) {\n        super('ConditionalExpression');\n        this.test = def.test;\n        this.consequent = def.consequent;\n        this.alternate = def.alternate;\n    }\n\n    generateCode(codegen) {\n        this.test = codegen.generateCode(this.test);\n        this.consequent = codegen.generateCode(this.consequent);\n        this.alternate = codegen.generateCode(this.alternate);\n        return this;\n    }\n\n    writeCode(writer) {\n        var test = this.test;\n        var consequent = this.consequent;\n        var alternate = this.alternate;\n\n        writer.write(test);\n        writer.write(' ? ');\n        writer.write(consequent);\n        writer.write(' : ');\n        writer.write(alternate);\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'ConditionalExpression',\n            test: this.test,\n            consequent: this.consequent,\n            alternate: this.alternate\n        };\n    }\n\n    walk(walker) {\n        this.test = walker.walk(this.test);\n        this.consequent = walker.walk(this.consequent);\n        this.alternate = walker.walk(this.alternate);\n    }\n\n    toString() {\n        var test = this.test;\n        var consequent = this.consequent;\n        var alternate = this.alternate;\n        return test.toString() + ' ? ' + consequent + ' : ' + alternate;\n    }\n}\n\nmodule.exports = ConditionalExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/NewExpression.js":"'use strict';\n\nvar Node = require('./Node');\nvar isCompoundExpression = require('../util/isCompoundExpression');\n\nclass NewExpression extends Node {\n    constructor(def) {\n        super('NewExpression');\n        this.callee = def.callee;\n        this.args = def.args;\n    }\n\n    generateCode(codegen) {\n        this.callee = codegen.generateCode(this.callee);\n        this.args = codegen.generateCode(this.args);\n        return this;\n    }\n\n    writeCode(writer) {\n        var callee = this.callee;\n        var args = this.args;\n\n        writer.write('new ');\n\n        var wrap = isCompoundExpression(callee);\n\n        if (wrap) {\n            writer.write('(');\n        }\n\n        writer.write(callee);\n\n        if (wrap) {\n            writer.write(')');\n        }\n\n        writer.write('(');\n\n        if (args && args.length) {\n            for (let i=0, argsLen = args.length; i<argsLen; i++) {\n                if (i !== 0) {\n                    writer.write(', ');\n                }\n\n                let arg = args[i];\n                if (!arg) {\n                    throw new Error('Arg ' + i + ' is not valid for new expression: ' + JSON.stringify(this.toJSON()));\n                }\n                writer.write(arg);\n            }\n        }\n\n        writer.write(')');\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'NewExpression',\n            callee: this.callee,\n            args: this.args\n        };\n    }\n\n    walk(walker) {\n        this.callee = walker.walk(this.callee);\n        this.args = walker.walk(this.args);\n    }\n\n    toString() {\n        var callee = this.callee;\n        var args = this.args;\n\n        let result = 'new ';\n\n        var wrap = isCompoundExpression(callee);\n\n        if (wrap) {\n            result += '(';\n        }\n\n        result += callee;\n\n        if (wrap) {\n            result += ')';\n        }\n\n\n        result += '(';\n\n        if (args && args.length) {\n            for (let i=0, argsLen = args.length; i<argsLen; i++) {\n                if (i !== 0) {\n                    result += ', ';\n                }\n\n                let arg = args[i];\n                result += arg;\n            }\n        }\n\n        result += ')';\n\n        return result;\n    }\n}\n\nmodule.exports = NewExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ObjectExpression.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ObjectExpression extends Node {\n    constructor(def) {\n        super('ObjectExpression');\n        this.properties = def.properties;\n    }\n\n    generateCode(codegen) {\n        this.properties = codegen.generateCode(this.properties);\n\n        return this;\n    }\n\n    writeCode(writer) {\n        var properties = this.properties;\n\n        if (!properties || !properties.length) {\n            writer.write('{}');\n            return;\n        }\n\n        writer.incIndent();\n        writer.write('{\\n');\n        writer.incIndent();\n\n        properties.forEach((prop, i) => {\n            writer.writeLineIndent();\n            writer.write(prop);\n\n            if (i < properties.length - 1) {\n                writer.write(',\\n');\n            } else {\n                writer.write('\\n');\n            }\n        });\n\n        writer.decIndent();\n        writer.writeLineIndent();\n        writer.write('}');\n        writer.decIndent();\n    }\n\n    toJSON() {\n        return {\n            type: 'ObjectExpression',\n            properties: this.properties\n        };\n    }\n\n    walk(walker) {\n        this.properties = walker.walk(this.properties);\n    }\n\n    toString(codegen) {\n        var properties = this.properties;\n\n        if (!properties || !properties.length) {\n            return '{}';\n        }\n\n        let result = '{';\n\n        properties.forEach((prop, i) => {\n            if (i !== 0) {\n                result += ', ';\n            }\n            result += prop;\n        });\n\n        return result + '}';    }\n}\n\nmodule.exports = ObjectExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ArrayExpression.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ArrayExpression extends Node {\n    constructor(def) {\n        super('ArrayExpression');\n        this.elements = def.elements;\n    }\n\n    generateCode(codegen) {\n        this.elements = codegen.generateCode(this.elements);\n        return this;\n    }\n\n    writeCode(writer) {\n        var elements = this.elements;\n\n        if (!elements || !elements.length) {\n            writer.write('[]');\n            return;\n        }\n\n        writer.incIndent();\n        writer.write('[\\n');\n        writer.incIndent();\n\n        elements.forEach((element, i) => {\n            writer.writeLineIndent();\n            writer.write(element);\n\n            if (i < elements.length - 1) {\n                writer.write(',\\n');\n            } else {\n                writer.write('\\n');\n            }\n        });\n\n        writer.decIndent();\n        writer.writeLineIndent();\n        writer.write(']');\n        writer.decIndent();\n    }\n\n    walk(walker) {\n        this.elements = walker.walk(this.elements);\n    }\n\n    toJSON() {\n        return {\n            type: 'ArrayExpression',\n            elements: this.elements\n        };\n    }\n\n    toString() {\n        var result = '[';\n        var elements = this.elements;\n        if (elements) {\n            elements.forEach((element, i) => {\n                if (i !== 0) {\n                    result += ', ';\n                }\n                result += element.toString();\n            });\n        }\n\n        return result + ']';\n    }\n}\n\nmodule.exports = ArrayExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Property.js":"'use strict';\nconst isValidJavaScriptIdentifier = require('../util/isValidJavaScriptIdentifier');\nconst Node = require('./Node');\n\nclass Property extends Node {\n    constructor(def) {\n        super('Property');\n        this.key = def.key;\n        this.value = def.value;\n    }\n\n    generateCode(codegen) {\n        var key = this.key;\n        var value = this.value;\n\n        if (key.type === 'Literal') {\n            var propName = key.value;\n            if (isValidJavaScriptIdentifier(propName)) {\n                key = codegen.builder.identifier(propName);\n            }\n        }\n\n        this.key = codegen.generateCode(key);\n        this.value = codegen.generateCode(value);\n\n        return this;\n    }\n\n    writeCode(writer) {\n        var key = this.key;\n        var value = this.value;\n        writer.write(key);\n        writer.write(': ');\n        writer.write(value);\n    }\n\n    toJSON() {\n        return {\n            type: 'Property',\n            key: this.key,\n            value: this.value\n        };\n    }\n\n    walk(walker) {\n        this.key = walker.walk(this.key);\n        this.value = walker.walk(this.value);\n    }\n\n    toString() {\n        var key = this.key;\n        var value = this.value;\n\n        if (key.type === 'Literal') {\n            var propName = key.value;\n            if (isValidJavaScriptIdentifier(propName)) {\n                key = propName;\n            }\n        }\n\n        return key + ': ' + value;\n    }\n}\n\nmodule.exports = Property;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/isValidJavaScriptIdentifier.js":"var idRegExp = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nmodule.exports = function isValidJavaScriptIdentifier(varName) {\n    return idRegExp.test(varName);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/VariableDeclarator.js":"'use strict';\n\nvar Node = require('./Node');\nvar Identifier = require('./Identifier');\nvar isValidJavaScriptVarName = require('../util/isValidJavaScriptVarName');\n\nclass VariableDeclarator extends Node {\n    constructor(def) {\n        super('VariableDeclarator');\n        this.id = def.id;\n        this.init = def.init;\n\n        let name = this.id.name;\n        if (!name) {\n            throw new Error('\"name\" is required');\n        }\n\n        if (!isValidJavaScriptVarName(name)) {\n            var error = new Error('Invalid JavaScript variable name: ' + name);\n            error.code = 'INVALID_VAR_NAME';\n            throw error;\n        }\n    }\n\n    generateCode(codegen) {\n        this.id = codegen.generateCode(this.id);\n        this.init = codegen.generateCode(this.init);\n        return this;\n    }\n\n    writeCode(writer) {\n        var id = this.id;\n        var init = this.init;\n\n        if (!(id instanceof Identifier) && typeof id !== 'string') {\n            throw new Error('Invalid variable name: ' + id);\n        }\n\n        writer.write(id);\n\n        if (init != null) {\n            writer.write(' = ');\n            writer.write(init);\n        }\n    }\n\n    walk(walker) {\n        this.id = walker.walk(this.id);\n        this.init = walker.walk(this.init);\n    }\n}\n\nmodule.exports = VariableDeclarator;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ThisExpression.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ThisExpression extends Node {\n    constructor(def) {\n        super('ThisExpression');\n    }\n\n    generateCode(codegen) {\n        return this;\n    }\n\n    writeCode(writer) {\n        writer.write('this');\n    }\n\n    toString() {\n        return 'this';\n    }\n}\n\nmodule.exports = ThisExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Expression.js":"'use strict';\n\nvar Node = require('./Node');\nvar ok = require('assert').ok;\n\nclass Expression extends Node {\n    constructor(def) {\n        super('Expression');\n        this.value = def.value;\n        ok(this.value != null, 'Invalid expression');\n    }\n\n    generateCode(codegen) {\n        return this;\n    }\n\n    writeCode(writer) {\n        writer.write(this.value);\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toString() {\n        return this.value;\n    }\n}\n\nmodule.exports = Expression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Scriptlet.js":"'use strict';\n\nvar Node = require('./Node');\nvar adjustIndent = require('../util/adjustIndent');\n\nclass Scriptlet extends Node {\n    constructor(def) {\n        super('Scriptlet');\n        this.code = def.code;\n        this.tag = def.tag;\n        this.block = def.block;\n    }\n\n    generateCode(codegen) {\n        return this;\n    }\n\n    writeCode(writer) {\n        var code = this.code;\n\n        if (!code) {\n            return;\n        }\n\n        code = adjustIndent(code, writer.currentIndent);\n\n        writer.write(code);\n        writer.write('\\n');\n    }\n}\n\nmodule.exports = Scriptlet;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/ContainerNode.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass ContainerNode extends Node {\n    constructor(type) {\n        super(type);\n        this.body = this.makeContainer([]);\n    }\n\n    generateCode(codegen) {\n        return codegen.generateCode(this.body);\n    }\n\n    walk(walker) {\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = ContainerNode;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/WhileStatement.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass WhileStatement extends Node {\n    constructor(def) {\n        super('WhileStatement');\n        this.test = def.test;\n        this.body = this.makeContainer(def.body);\n    }\n\n    generateCode(codegen) {\n        this.test = codegen.generateCode(this.test);\n        this.body = codegen.generateCode(this.body);\n        return this;\n    }\n\n    writeCode(writer) {\n        var test = this.test;\n        var body = this.body;\n\n        writer.write('while (');\n        writer.write(test);\n        writer.write(') ');\n\n        writer.write(body);\n\n        writer.write('\\n');\n    }\n\n    walk(walker) {\n        this.test = walker.walk(this.test);\n        this.body = walker.walk(this.body);\n    }\n}\n\nmodule.exports = WhileStatement;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/DocumentType.js":"'use strict';\nvar Node = require('./Node');\n\nclass DocumentType extends Node {\n    constructor(def) {\n        super('DocumentType');\n        this.documentType = def.documentType;\n    }\n\n    generateHTMLCode(codegen) {\n        var builder = codegen.builder;\n\n        return [\n            builder.htmlLiteral('<!'),\n            builder.html(codegen.generateCode(this.documentType)),\n            builder.htmlLiteral('>')\n        ];\n    }\n\n    generateVDOMCode(codegen) {\n        return null;\n    }\n\n    toJSON() {\n        return {\n            type: this.type,\n            value: this.value\n        };\n    }\n}\n\nmodule.exports = DocumentType;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/Declaration.js":"'use strict';\nvar Node = require('./Node');\n\nclass Declaration extends Node {\n    constructor(def) {\n        super('Declaration');\n        this.declaration = def.declaration;\n    }\n\n    generateHTMLCode(codegen) {\n        var builder = codegen.builder;\n\n        return [\n            builder.htmlLiteral('<?'),\n            codegen.generateCode(builder.text(this.declaration)),\n            builder.htmlLiteral('?>')\n        ];\n    }\n\n    toJSON() {\n        return {\n            type: this.type,\n            value: this.value\n        };\n    }\n}\n\nmodule.exports = Declaration;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/SequenceExpression.js":"'use strict';\n\nvar Node = require('./Node');\n\nclass SequenceExpression extends Node {\n    constructor(def) {\n        super('SequenceExpression');\n        this.expressions = def.expressions;\n    }\n\n    generateCode(codegen) {\n        this.expressions = codegen.generateCode(this.expressions);\n        return this;\n    }\n\n    writeCode(writer) {\n\n        for (var i=0; i<this.expressions.length; i++) {\n            var expression = this.expressions[i];\n\n            if (i !== 0) {\n                writer.write(', ');\n            }\n\n            writer.write(expression);\n        }\n    }\n\n    isCompoundExpression() {\n        return true;\n    }\n\n    toJSON() {\n        return {\n            type: 'SequenceExpression',\n            expressions: this.expressions\n        };\n    }\n\n    walk(walker) {\n        this.expressions = walker.walk(this.expressions);\n    }\n\n    toString() {\n        var code = '';\n\n        for (var i=0; i<this.expressions.length; i++) {\n            var expression = this.expressions[i];\n\n            if (i !== 0) {\n                code += ', ';\n            }\n\n            code += expression;\n        }\n\n        return code;\n    }\n}\n\nmodule.exports = SequenceExpression;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/ast/CustomTag.js":"'use strict';\n\nvar HtmlElement = require('./HtmlElement');\nvar removeDashes = require('../util/removeDashes');\nvar safeVarName = require('../util/safeVarName');\nvar ok = require('assert').ok;\nvar Node = require('./Node');\n\nvar CUSTOM_TAG_KEY = Symbol('CustomTag');\n\nfunction getNestedVariables(elNode, tagDef, codegen) {\n    var variableNames = [];\n    if (tagDef.forEachVariable) {\n        tagDef.forEachVariable((nestedVar) => {\n            var varName;\n            if (nestedVar.nameFromAttribute) {\n                var possibleNameAttributes = nestedVar.nameFromAttribute.split(/\\s+or\\s+|\\s*,\\s*/i);\n                for (var i = 0, len = possibleNameAttributes.length; i < len; i++) {\n                    var attrName = possibleNameAttributes[i];\n                    var keep = false;\n                    if (attrName.endsWith('|keep')) {\n                        keep = true;\n                        attrName = attrName.slice(0, 0 - '|keep'.length);\n                        possibleNameAttributes[i] = attrName;\n                    }\n                    varName = elNode.getAttributeValue(attrName);\n                    if (varName) {\n                        if (varName.type !== 'Literal' || typeof varName.value !== 'string') {\n                            codegen.addError('The value of the ' + attrName + ' is expected to be a string');\n                            codegen.addError('Attribute ' + possibleNameAttributes.join(' or ') + ' is required');\n                            varName = '_var';    // Let it continue with errors\n                        }\n\n                        varName = varName.value;\n\n                        if (!keep) {\n                            elNode.removeAttribute(attrName);\n                        }\n                        break;\n                    }\n                }\n                if (!varName) {\n                    codegen.addError('Attribute ' + possibleNameAttributes.join(' or ') + ' is required');\n                    varName = '_var';    // Let it continue with errors\n                }\n            } else {\n                varName = nestedVar.name;\n                if (!varName) {\n                    codegen.addError('Variable name is required');\n                    varName = '_var';    // Let it continue with errors\n                }\n            }\n            variableNames.push(codegen.builder.identifier(varName));\n        });\n    }\n\n    if (elNode.additionalNestedVars.length) {\n        elNode.additionalNestedVars.forEach((varName) => {\n            variableNames.push(codegen.builder.identifier(varName));\n        });\n    }\n\n    return variableNames;\n}\n\nfunction getAllowedAttributesString(tagName, context) {\n    var attrNames = [];\n\n    var tagDef = context.taglibLookup.getTag(tagName);\n    if (tagDef) {\n        tagDef.forEachAttribute((attrDef) => {\n            attrNames.push(attrDef.name);\n        });\n\n        return attrNames.length ? attrNames.join(', ') : '(none)';\n    } else {\n        return null;\n    }\n}\n\nfunction checkIfNestedTagCanBeAddedDirectlyToInput(nestedTag, parentCustomTag) {\n    if (!nestedTag._isDirectlyNestedTag) {\n        return false;\n    }\n\n    var isRepeated = nestedTag.tagDef.isRepeated;\n    if (!isRepeated) {\n        return true;\n    }\n\n    let tagName = nestedTag.tagDef.name;\n    let previousMatchingNestedTags = parentCustomTag._foundNestedTagsByName[tagName];\n    if (!previousMatchingNestedTags) {\n        return true;\n    }\n\n    for (let i=0; i<previousMatchingNestedTags.length; i++) {\n        let previousNestedTag = previousMatchingNestedTags[i];\n        if (!previousNestedTag._isDirectlyNestedTag) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getNextNestedTagVarName(tagDef, context) {\n    var key = 'customTag' + tagDef.name;\n\n    var nestedTagVarInfo = context.data[key] || (context.data[key] = {\n        next: 0\n    });\n\n\n    return safeVarName(tagDef.name) + (nestedTagVarInfo.next++);\n}\n\nfunction getNextRenderBodyVar(context) {\n    var key = 'CustomTag_renderBodyVar';\n    var nextVarInfo = context.data[key] || (context.data[key] = {\n        next: 0\n    });\n\n    return 'renderBodyConditional'+ (nextVarInfo.next++);\n}\n\nfunction processDirectlyNestedTags(node, codegen) {\n    node.forEachChild((child) => {\n        if (child.type === 'CustomTag') {\n            let customTag = child;\n\n            var tagDef = customTag.resolveTagDef(codegen);\n            if (tagDef.isNestedTag) {\n                customTag._isDirectlyNestedTag = true;\n            }\n        } else if (child.type === 'If') {\n            if (child.nextSibling && child.nextSibling.type === 'Else') {\n                return;\n            }\n\n            let ifNode = child;\n\n            let childChild = child.childCount === 1 && child.firstChild;\n            if (childChild && childChild.type === 'CustomTag') {\n                let customTag = childChild;\n\n                let tagDef = customTag.resolveTagDef(codegen);\n                if (tagDef.isNestedTag && !tagDef.isRepeated) {\n                    let condition = codegen.generateCode(ifNode.test);\n                    customTag._isDirectlyNestedTag = true;\n                    customTag._condition = condition;\n                    ifNode.replaceWith(customTag);\n                }\n            }\n        }\n    });\n}\n\nfunction merge(props1, props2, context) {\n    if (!props2) {\n        return props1;\n    }\n\n    if (!(props2 instanceof Node)) {\n        if (Object.keys(props2).length === 0) {\n            return props1;\n        }\n    }\n\n    if (props1 instanceof Node) {\n        let mergeVar = context.helper('merge');\n        if (!(props2 instanceof Node)) {\n            props2 = context.builder.literal(props2);\n        }\n\n        return context.builder.functionCall(mergeVar, [\n            props2, // Input props from the attributes take precedence\n            props1\n        ]);\n    } else {\n        if (props2 instanceof Node) {\n            let mergeVar = context.helper('merge');\n\n            return context.builder.functionCall(mergeVar, [\n                props2, // Input props from the attributes take precedence\n                props1\n\n            ]);\n        } else {\n            if (props1._arg) {\n                let mergeVar = context.helper('merge');\n                props1._arg = context.builder.functionCall(mergeVar, [\n                    context.builder.literal(props2), // Input props from the attributes take precedence\n                    props1._arg\n                ]);\n                return props1;\n            } else {\n                return Object.assign(props1, props2);\n            }\n        }\n    }\n}\n\nclass CustomTag extends HtmlElement {\n    constructor(el, tagDef) {\n        super(el);\n        this.type = 'CustomTag';\n        this.tagDef = tagDef;\n        this.additionalNestedVars = [];\n        this._nestedTagVar = null;\n        this._inputProps = null;\n        this._isDirectlyNestedTag = false;\n        this._condition = null;\n        this._foundNestedTagsByName = {};\n        this._hasDynamicNestedTags = false;\n        this._additionalProps = null;\n        this._rendererPath = null;\n        this.dynamicAttributes = undefined;\n    }\n\n    buildInputProps(codegen) {\n        var inputProps = this._inputProps;\n        if (inputProps) {\n            return inputProps;\n        }\n\n        var context = codegen.context;\n        var tagDef = this.resolveTagDef(codegen);\n        inputProps = {};\n\n        function handleAttr(attrName, attrValue, attrDef) {\n            if (!attrDef) {\n                return; // Skip over attributes that are not supported\n            }\n\n            if (attrValue == null) {\n                attrValue = context.builder.literalTrue();\n            }\n\n            var propName;\n            var parentPropName;\n\n            if (attrDef.dynamicAttribute) {\n                // Dynamic attributes are allowed attributes\n                // that are not declared (i.e. \"*\" attributes)\n                //\n                if (attrDef.removeDashes === true || attrDef.preserveName === false) {\n                    propName = removeDashes(attrName);\n                } else {\n                    propName = attrName;\n                }\n\n                if (attrDef.targetProperty) {\n                    parentPropName = attrDef.targetProperty;\n                }\n            } else {\n                // Attributes map to properties and we allow the taglib\n                // author to control how an attribute name resolves\n                // to a property name.\n                if (attrDef.targetProperty) {\n                    propName = attrDef.targetProperty;\n                } else if (attrDef.preserveName === true) {\n                    propName = attrName;\n                } else {\n                    propName = removeDashes(attrName);\n                }\n            }\n\n            if (attrDef.type === 'path') {\n                attrValue = context.resolvePath(attrValue);\n            } else if (attrDef.type === 'template') {\n                attrValue = context.resolveTemplate(attrValue);\n            }\n\n            if (parentPropName) {\n                let parent = inputProps[parentPropName] || (inputProps[parentPropName] = {});\n                parent[propName] = attrValue;\n            } else {\n                inputProps[propName] = attrValue;\n            }\n        }\n\n        if (tagDef.forEachAttribute) {\n            // Add default values for any attributes from the tag definition. These added properties may get overridden\n            // by get overridden from the attributes found on the actual HTML element.\n            tagDef.forEachAttribute(function (attrDef) {\n                if (attrDef.hasOwnProperty('defaultValue')) {\n                    handleAttr(\n                        attrDef.name,\n                        context.builder.literal(attrDef.defaultValue),\n                        attrDef);\n                }\n            });\n        }\n\n        let tagName = tagDef.isNestedTag ? tagDef.name : this.tagName;\n\n        // Loop over the attributes found on the HTML element and add the corresponding properties\n        // to the input object for the custom tag\n        this.forEachAttribute((attr) => {\n            var attrName = attr.name;\n            if (!attrName) {\n                return; // Skip attributes with no names\n            }\n\n            var attrDef = attr.def || context.taglibLookup.getAttribute(tagName, attrName) || tagDef.getAttribute(attr.name);\n\n            if (!attrDef) {\n                var errorMessage = 'Unsupported attribute of \"' + attrName + '\" found on the <' + this.tagName + '> custom tag.';\n                let allowedAttributesString = getAllowedAttributesString(tagName, context);\n                if (allowedAttributesString) {\n                    errorMessage += ' Allowed attributes: ' + allowedAttributesString;\n                }\n\n                context.addError(this,  errorMessage);\n                return; // Skip over attributes that are not supported\n            }\n\n            handleAttr(attrName, attr.value, attrDef);\n        });\n\n\n        if (tagDef.forEachImportedVariable) {\n            // Imported variables are used to add input properties to a custom tag based on data/variables\n            // found in the compiled template\n            tagDef.forEachImportedVariable(function(importedVariable) {\n                let propName = importedVariable.targetProperty;\n                let propExpression = importedVariable.expression;\n\n                inputProps[propName] = propExpression;\n            });\n        }\n\n        this._inputProps = inputProps;\n\n        return inputProps;\n    }\n\n    resolveTagDef(codegen) {\n        var context = codegen.context;\n        var tagDef = this.tagDef;\n        if (!tagDef) {\n            if (this.tagName && this.tagName.startsWith('@')) {\n                var parentCustomTag = context.getData(CUSTOM_TAG_KEY);\n\n                if (!parentCustomTag) {\n                    codegen.addError('Invalid usage of the <' + this.tagName + '> nested tag. Tag not nested within a custom tag.');\n                    return null;\n                }\n\n                var parentTagDef = parentCustomTag.tagDef;\n                if (!parentTagDef) {\n                    throw new Error('\"tagDef\" is expected for CustomTag: ' + parentCustomTag.tagName);\n                }\n\n                var nestedTagName = this.tagName.substring(1);\n\n                var fullyQualifiedName = parentCustomTag.tagDef.name + ':' + nestedTagName;\n                tagDef = this.tagDef = context.getTagDef(fullyQualifiedName);\n                if (!tagDef) {\n                    // This nested tag is not declared, but we will allow it to go through\n                    var taglibLoader = require('../taglib-loader');\n                    tagDef = this.tagDef = taglibLoader.loadTag({\n                        name: fullyQualifiedName,\n                        attributes: {\n                            '*': {\n                                targetProperty: null\n                            }\n                        }\n                    }, context.filename);\n\n                    tagDef.isNestedTag = true;\n                    tagDef.isRepeated = false;\n                    tagDef.targetProperty = nestedTagName;\n                }\n            } else {\n                throw new Error('\"tagDef\" is required for CustomTag');\n            }\n            this.tagDef = tagDef;\n        }\n        return tagDef;\n    }\n\n    addNestedVariable(name) {\n        ok(name, '\"name\" is required');\n        this.additionalNestedVars.push(name);\n    }\n\n    addNestedTag(nestedTag) {\n        var tagName = nestedTag.tagDef.name;\n\n        var byNameArray = this._foundNestedTagsByName[tagName] ||\n            (this._foundNestedTagsByName[tagName] = []);\n\n        byNameArray.push(nestedTag);\n    }\n\n    addProps(additionalProps) {\n        if (!this._additionalProps) {\n            this._additionalProps = {};\n        }\n\n        Object.assign(this._additionalProps, additionalProps);\n    }\n\n    hasProp(name) {\n        return this._additionalProps && this._additionalProps.hasOwnProperty(name);\n    }\n\n    addProp(name, value) {\n        if (!this._additionalProps) {\n            this._additionalProps = {};\n        }\n        this._additionalProps[name] = value;\n    }\n\n    setRendererPath(path) {\n        ok(typeof path === 'string', '\"path\" should be a string');\n        this._rendererPath = path;\n    }\n\n    getNestedTagVar(context) {\n        if (!this._nestedTagVar) {\n            var tagDef = this.tagDef;\n            var builder = context.builder;\n\n            var nextNestedTagVarName = getNextNestedTagVarName(tagDef, context);\n\n            this._nestedTagVar = builder.identifier(nextNestedTagVarName);\n        }\n\n        return this._nestedTagVar;\n    }\n\n    generateRenderTagCode(codegen, tagVar, tagArgs) {\n        return codegen.builder.functionCall(tagVar, tagArgs);\n    }\n\n    generateCode(codegen) {\n        if (this.type !== 'CustomTag') {\n            throw new Error(this.type);\n        }\n        var builder = codegen.builder;\n        var context = codegen.context;\n\n        var tagDef = this.resolveTagDef(codegen);\n\n        if (!tagDef) {\n            // The tag def was not able to be resolved and an error should have already\n            // been added to the context\n            return null;\n        }\n\n        var parentCustomTag;\n\n        context.pushData(CUSTOM_TAG_KEY, this);\n        processDirectlyNestedTags(this, codegen);\n        var body = codegen.generateCode(this.body);\n        context.popData(CUSTOM_TAG_KEY);\n\n        var isNestedTag = tagDef.isNestedTag === true;\n        if (isNestedTag) {\n            parentCustomTag = context.getData(CUSTOM_TAG_KEY);\n            if (!parentCustomTag) {\n                if (tagDef.parentTagName) {\n                    codegen.addError(`Invalid usage of the <${this.tagName}> nested tag. Tag not nested within a <${tagDef.parentTagName}> tag.`);\n                } else {\n                    codegen.addError(`Invalid usage of the <${this.tagName}> nested tag. Tag not nested within a custom tag.`);\n                }\n\n                return null;\n            }\n\n            parentCustomTag.addNestedTag(this);\n\n            if (checkIfNestedTagCanBeAddedDirectlyToInput(this, parentCustomTag)) {\n                let inputProps = this.buildInputProps(codegen);\n\n                if (body && body.length) {\n                    inputProps.renderBody = codegen.builder.renderBodyFunction(body);\n                }\n\n                if (tagDef.isRepeated) {\n                    var currentValue = parentCustomTag.getAttributeValue(tagDef.targetProperty);\n                    if (currentValue) {\n                        currentValue.value.push(inputProps);\n                    } else {\n                        parentCustomTag.setAttributeValue(tagDef.targetProperty, builder.literal([\n                            inputProps\n                        ]));\n                    }\n                } else {\n                    let nestedTagValue = builder.literal(inputProps);\n                    if (this._condition) {\n                        nestedTagValue = builder.binaryExpression(this._condition, '&&', nestedTagValue);\n                    }\n                    parentCustomTag.setAttributeValue(tagDef.targetProperty, nestedTagValue);\n                }\n\n                return null;\n            } else {\n                this._isDirectlyNestedTag = false;\n                parentCustomTag._hasDynamicNestedTags = true;\n            }\n        }\n\n        var hasDynamicNestedTags = this._hasDynamicNestedTags;\n\n        var bodyOnlyIf = this.bodyOnlyIf;\n        // let parentTagVar;\n\n        var nestedVariableNames = getNestedVariables(this, tagDef, codegen);\n\n        var inputProps = this.buildInputProps(codegen);\n\n        var renderBodyFunction;\n\n        if (body && body.length) {\n            if (tagDef.bodyFunction) {\n                let bodyFunction = tagDef.bodyFunction;\n                let bodyFunctionName = bodyFunction.name;\n                let bodyFunctionParams = bodyFunction.params.map(function(param) {\n                    return builder.identifier(param);\n                });\n\n                inputProps[bodyFunctionName] = builder.functionDeclaration(bodyFunctionName, bodyFunctionParams, body);\n            } else {\n                renderBodyFunction = context.builder.renderBodyFunction(body);\n                if (hasDynamicNestedTags) {\n                    renderBodyFunction.params.push(this._nestedTagVar);\n                } else {\n                    if (nestedVariableNames && nestedVariableNames.length) {\n                        renderBodyFunction.params = renderBodyFunction.params.concat(nestedVariableNames);\n                    }\n                }\n            }\n        }\n\n        var renderBodyFunctionVarIdentifier;\n        var renderBodyFunctionVar;\n        // Store the renderBody function with the input, but only if the body does not have\n        // nested tags\n        if (renderBodyFunction) {\n            if (bodyOnlyIf) {\n                // Move the renderBody function into a local variable\n                renderBodyFunctionVarIdentifier = builder.identifier(getNextRenderBodyVar(context));\n                renderBodyFunctionVar = builder.var(renderBodyFunctionVarIdentifier, renderBodyFunction);\n                inputProps.renderBody = renderBodyFunctionVarIdentifier;\n            } else {\n                inputProps.renderBody = renderBodyFunction;\n            }\n        } else {\n            bodyOnlyIf = null;\n        }\n\n        var argExpression;\n\n        if (this.argument) {\n            argExpression = builder.parseExpression(this.argument);\n        }\n\n        var additionalProps = this._additionalProps;\n\n        if (additionalProps) {\n            inputProps = merge(additionalProps, inputProps, context);\n        }\n\n        if (argExpression) {\n            inputProps = merge(argExpression, inputProps, context);\n        }\n\n        if (this.dynamicAttributes) {\n            this.dynamicAttributes.forEach((dynamicAttributesExpression) => {\n                inputProps = merge(dynamicAttributesExpression, inputProps, context);\n            });\n        }\n\n        if (!(inputProps instanceof Node)) {\n            inputProps = builder.literal(inputProps);\n        }\n\n        if (hasDynamicNestedTags) {\n            inputProps = builder.functionCall(context.helper('mergeNestedTagsHelper'), [ inputProps ]);\n        }\n\n        var rendererPath = this._rendererPath || tagDef.renderer;\n        var rendererRequirePath;\n        var requireRendererFunctionCall;\n\n        if (rendererPath) {\n            rendererRequirePath = context.getRequirePath(rendererPath);\n            requireRendererFunctionCall = builder.require(JSON.stringify(rendererRequirePath));\n        } else {\n            requireRendererFunctionCall = builder.literal(null);\n        }\n\n        var finalNode;\n\n        var tagVarName = tagDef.name + (tagDef.isNestedTag ? '_nested_tag' : '_tag');\n\n        if (tagDef.template) {\n            var templateRequirePath = context.getRequirePath(tagDef.template);\n            var templateVar = context.importTemplate(templateRequirePath, tagDef.name + '_template');\n\n            let loadTag = builder.functionCall(context.helper('loadTag'), [templateVar]);\n            let tagVar = codegen.addStaticVar(tagVarName, loadTag);\n\n            finalNode = this.generateRenderTagCode(codegen, tagVar, [ inputProps, builder.identifierOut() ]);\n        } else {\n            if (rendererRequirePath) {\n                codegen.pushMeta('tags', builder.literal(rendererRequirePath), true);\n            }\n\n            let loadTag;\n            let tagArgs;\n\n            if (isNestedTag) {\n                let loadTagArgs = [ builder.literal(tagDef.targetProperty) ];\n\n                if (tagDef.isRepeated) {\n                    loadTagArgs.push(builder.literal(1)); // isRepeated\n                }\n\n                loadTag = builder.functionCall(context.helper('loadNestedTag'), loadTagArgs);\n\n                tagArgs = [inputProps, parentCustomTag.getNestedTagVar(context) ];\n            } else {\n                loadTag = builder.functionCall(context.helper('loadTag'), [\n                    requireRendererFunctionCall // The first param is the renderer\n                ]);\n\n                tagArgs = [inputProps, builder.identifierOut() ];\n            }\n\n            let tagVar = codegen.addStaticVar(tagVarName, loadTag);\n\n            if (isNestedTag) {\n                finalNode = builder.functionCall(tagVar, tagArgs);\n            } else {\n                finalNode = this.generateRenderTagCode(codegen, tagVar, tagArgs);\n            }\n        }\n\n        if (bodyOnlyIf && renderBodyFunctionVar) {\n            var ifStatement = builder.ifStatement(\n                bodyOnlyIf,\n                [\n\n                    builder.functionCall(renderBodyFunctionVarIdentifier, [builder.identifierOut()])\n                ],\n                builder.elseStatement([\n                    finalNode\n                ]));\n\n            return [\n                renderBodyFunctionVar,\n                ifStatement\n            ];\n        } else {\n            return finalNode;\n        }\n    }\n\n    addDynamicAttributes(expression) {\n        if (!this.dynamicAttributes) {\n            this.dynamicAttributes = [];\n        }\n\n        this.dynamicAttributes.push(expression);\n    }\n}\n\nmodule.exports = CustomTag;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/removeDashes.js":"module.exports = function removeDashes(str) {\n    return str.replace(/-([a-z])/g, function (match, lower) {\n        return lower.toUpperCase();\n    });\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/safeVarName.js":"function safeVarName(varName) {\n    var parts = varName.split(/[\\\\/]/);\n    if (parts.length >= 2) {\n        // The varname looks like it was based on a path.\n        // Let's just use the last two parts\n        varName = parts.slice(-2).join('_');\n    }\n\n    return varName.replace(/[^A-Za-z0-9_]/g, '_').replace(/^[0-9]+/, function(match) {\n        var str = '';\n        for (var i=0; i<match.length; i++) {\n            str += '_';\n        }\n        return str;\n    });\n}\n\nmodule.exports = safeVarName;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/parseExpression.js":"var parseJavaScript = require('./parseJavaScript');\n\nmodule.exports = function(src, builder) {\n    return parseJavaScript(src, builder, true /* isExpression */ );\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/parseJavaScript.js":"'use strict';\nvar ok = require('assert').ok;\n\nconst esprima = require('esprima');\n\nfunction parseExpression(src, builder, isExpression) {\n    ok(typeof src === 'string', '\"src\" should be a string expression');\n    ok(builder, '\"builder\" is required');\n\n    function convert(node) {\n        if (Array.isArray(node)) {\n            let nodes = node;\n            for (let i=0; i<nodes.length; i++) {\n                var converted = convert(nodes[i]);\n                if (converted == null) {\n                    return null;\n                }\n                nodes[i] = converted;\n            }\n            return nodes;\n        }\n\n        switch(node.type) {\n            case 'ArrayExpression': {\n                let elements = convert(node.elements);\n                if (!elements) {\n                    return null;\n                }\n                return builder.arrayExpression(elements);\n            }\n            case 'AssignmentExpression': {\n                let left = convert(node.left);\n                if (!left) {\n                    return null;\n                }\n\n                let right = convert(node.right);\n                if (!right) {\n                    return null;\n                }\n\n                return builder.assignment(left, right, node.operator);\n            }\n            case 'BinaryExpression': {\n                let left = convert(node.left);\n                if (!left) {\n                    return null;\n                }\n\n                let right = convert(node.right);\n                if (!right) {\n                    return null;\n                }\n\n                return builder.binaryExpression(left, node.operator, right);\n            }\n            case 'BlockStatement': {\n                let body = convert(node.body);\n                if (!body) {\n                    return null;\n                }\n\n                return body;\n            }\n            case 'CallExpression': {\n                let callee = convert(node.callee);\n\n                if (!callee) {\n                    return null;\n                }\n\n                let args = convert(node.arguments);\n                if (!args) {\n                    return null;\n                }\n\n                return builder.functionCall(callee, args);\n            }\n            case 'ConditionalExpression': {\n                let test = convert(node.test);\n\n                if (!test) {\n                    return null;\n                }\n\n                let consequent = convert(node.consequent);\n\n                if (!consequent) {\n                    return null;\n                }\n\n                let alternate = convert(node.alternate);\n\n                if (!alternate) {\n                    return null;\n                }\n\n                return builder.conditionalExpression(test, consequent, alternate);\n            }\n            case 'ExpressionStatement': {\n                return convert(node.expression);\n            }\n            case 'FunctionDeclaration':\n            case 'FunctionExpression': {\n                let name = null;\n\n                if (node.id) {\n                    name = convert(node.id);\n                    if (name == null) {\n                        return null;\n                    }\n                }\n\n                let params = convert(node.params);\n                if (!params) {\n                    return null;\n                }\n\n                let body = convert(node.body);\n                if (!body) {\n                    return null;\n                }\n\n                return builder.functionDeclaration(name, params, body);\n            }\n            case 'Identifier': {\n                return builder.identifier(node.name);\n            }\n            case 'Literal': {\n                let literalValue;\n\n                if (node.regex) {\n                    literalValue = new RegExp(node.regex.pattern, node.regex.flags);\n                } else {\n                    literalValue = node.value;\n                }\n\n                return builder.literal(literalValue);\n            }\n            case 'LogicalExpression': {\n                let left = convert(node.left);\n                if (!left) {\n                    return null;\n                }\n\n                let right = convert(node.right);\n                if (!right) {\n                    return null;\n                }\n\n                return builder.logicalExpression(left, node.operator, right);\n            }\n            case 'MemberExpression': {\n                let object = convert(node.object);\n                if (!object) {\n                    return null;\n                }\n\n                let property = convert(node.property);\n                if (!property) {\n                    return null;\n                }\n\n                return builder.memberExpression(object, property, node.computed);\n            }\n            case 'NewExpression': {\n                let callee = convert(node.callee);\n\n                if (!callee) {\n                    return null;\n                }\n\n                let args = convert(node.arguments);\n                if (!args) {\n                    return null;\n                }\n\n                return builder.newExpression(callee, args);\n            }\n            case 'Program': {\n                if (node.body && node.body.length === 1) {\n                    return convert(node.body[0]);\n                }\n                return null;\n            }\n            case 'ObjectExpression': {\n                let properties = convert(node.properties);\n                if (!properties) {\n                    return null;\n                }\n                return builder.objectExpression(properties);\n            }\n            case 'Property': {\n                let key = convert(node.key);\n                if (!key) {\n                    return null;\n                }\n                let value = convert(node.value);\n                if (!value) {\n                    return null;\n                }\n                return builder.property(key, value);\n            }\n            case 'ReturnStatement': {\n                var argument = node.argument;\n\n                if (argument != null) {\n                    argument = convert(node.argument);\n                    if (!argument) {\n                        return null;\n                    }\n                }\n\n                return builder.returnStatement(argument);\n            }\n            case 'ThisExpression': {\n                return builder.thisExpression();\n            }\n            case 'UnaryExpression': {\n                let argument = convert(node.argument);\n                if (!argument) {\n                    return null;\n                }\n\n                return builder.unaryExpression(argument, node.operator, node.prefix);\n            }\n            case 'UpdateExpression': {\n                let argument = convert(node.argument);\n                if (!argument) {\n                    return null;\n                }\n\n                return builder.updateExpression(argument, node.operator, node.prefix);\n            }\n            case 'VariableDeclarator': {\n                var id = convert(node.id);\n                if (!id) {\n                    return null;\n                }\n\n                var init;\n\n                if (node.init) {\n                    init = convert(node.init);\n                    if (!init) {\n                        return null;\n                    }\n                }\n\n                return builder.variableDeclarator(id, init);\n            }\n            case 'VariableDeclaration': {\n                var kind = node.kind;\n\n                var declarations = convert(node.declarations);\n\n                if (!declarations) {\n                    return null;\n                }\n                return builder.vars(declarations, kind);\n            }\n            default:\n                return null;\n        }\n    }\n\n    let jsAST;\n    try {\n        if (isExpression) {\n            src = '(' + src + ')';\n        }\n        jsAST = esprima.parse(src);\n    } catch(e) {\n        if (e.index == null) {\n            // Doesn't look like an Esprima parse error... just rethrow the exception\n            throw e;\n        }\n        var errorIndex = e.index;\n        var errorMessage = '\\n' + e.description;\n        if (errorIndex != null && errorIndex >= 0) {\n            if (isExpression) {\n                errorIndex--; // Account for extra paren added to start\n            }\n            errorMessage += ': ';\n            errorMessage += src + '\\n'+ new Array(errorMessage.length + errorIndex + 1).join(\" \") + '^';\n        }\n        var wrappedError = new Error(errorMessage);\n        wrappedError.index = errorIndex;\n        wrappedError.src = src;\n        wrappedError.code = 'ERR_INVALID_JAVASCRIPT_EXPRESSION';\n        throw wrappedError;\n    }\n\n    var converted = convert(jsAST);\n    if (converted == null) {\n        converted = builder.expression(src);\n    }\n\n    return converted;\n}\n\nmodule.exports = parseExpression;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/parseStatement.js":"var parseJavaScript = require('./parseJavaScript');\n\nmodule.exports = function(src, builder) {\n    return parseJavaScript(src, builder, false /* isExpression */ );\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/parseJavaScriptArgs.js":"'use strict';\n\nvar ok = require('assert').ok;\n\nfunction parseJavaScriptArgs(args, builder) {\n    ok(typeof args === 'string', '\"args\" should be a string');\n    ok(builder, '\"builder\" is required');\n\n    var parsed = builder.parseExpression('[' + args + ']');\n    return parsed.elements;\n}\n\nmodule.exports = parseJavaScriptArgs;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/CompileContext.js":"'use strict';\n\nvar ok = require('assert').ok;\nvar path = require('path');\nvar complain = require('complain');\nvar taglibLookup = require('./taglib-lookup');\nvar charProps = require('char-props');\n\nvar UniqueVars = require('./util/UniqueVars');\nvar PosInfo = require('./util/PosInfo');\nvar CompileError = require('./CompileError');\nvar path = require('path');\nvar Node = require('./ast/Node');\nvar macros = require('./util/macros');\nvar extend = require('raptor-util/extend');\nvar Walker = require('./Walker');\nvar EventEmitter = require('events').EventEmitter;\nvar utilFingerprint = require('./util/finger-print');\nvar htmlElements = require('./util/html-elements');\nvar markoModules = require('./modules');\n\nconst markoPkgVersion = require('../package.json').version;\n\nconst FLAG_PRESERVE_WHITESPACE = 'PRESERVE_WHITESPACE';\n\n\n\nfunction getTaglibPath(taglibPath) {\n    if (typeof window === 'undefined') {\n        return path.relative(process.cwd(), taglibPath);\n    } else {\n        return taglibPath;\n    }\n}\n\nfunction removeExt(filename) {\n    var ext = path.extname(filename);\n    if (ext) {\n        return filename.slice(0, 0 - ext.length);\n    } else {\n        return filename;\n    }\n}\n\nfunction requireResolve(builder, path) {\n    var requireResolveNode = builder.memberExpression(\n        builder.identifier('require'),\n        builder.identifier('resolve'));\n\n\n    return builder.functionCall(requireResolveNode, [ path ]);\n}\n\nconst helpers = {\n    'attr': 'a',\n    'attrs': 'as',\n    'classAttr': 'ca',\n    'classList': 'cl',\n    'const': 'const',\n    'createElement': 'e',\n    'createInlineTemplate': {\n        vdom: { module: 'marko/runtime/vdom/helper-createInlineTemplate'},\n        html: { module: 'marko/runtime/html/helper-createInlineTemplate'}\n    },\n    'escapeXml': 'x',\n    'escapeXmlAttr': 'xa',\n    'escapeScript': 'xs',\n    'escapeStyle': 'xc',\n    'forEach': 'f',\n    'forEachProp': { module: 'marko/runtime/helper-forEachProperty' },\n    'forEachPropStatusVar': { module: 'marko/runtime/helper-forEachPropStatusVar' },\n    'forEachWithStatusVar': { module: 'marko/runtime/helper-forEachWithStatusVar' },\n    'forRange': { module: 'marko/runtime/helper-forRange' },\n    'include': 'i',\n    'loadNestedTag': { module: 'marko/runtime/helper-loadNestedTag' },\n    'loadTag': 't',\n    'loadTemplate': { module: 'marko/runtime/helper-loadTemplate' },\n    'mergeNestedTagsHelper': { module: 'marko/runtime/helper-mergeNestedTags' },\n    'merge': { module: 'marko/runtime/helper-merge' },\n    'renderComponent': { module: 'marko/components/taglib/helpers/renderComponent' },\n    'str': 's',\n    'styleAttr': {\n        vdom: { module: 'marko/runtime/vdom/helper-styleAttr'},\n        html: 'sa'\n    },\n    'createText': 't'\n};\n\nclass CompileContext extends EventEmitter {\n    constructor(src, filename, builder, options) {\n        super();\n        ok(typeof src === 'string', '\"src\" string is required');\n        ok(filename, '\"filename\" is required');\n\n        this.src = src;\n        this.filename = filename;\n        this.builder = builder;\n\n        this.dirname = path.dirname(filename);\n        this.taglibLookup = taglibLookup.buildLookup(this.dirname);\n        this.data = {};\n        this._dataStacks = {};\n        this.meta = {};\n\n        this.options = options || {};\n\n        const writeVersionComment = this.options.writeVersionComment;\n\n        this.outputType = this.options.output || 'html';\n        this.compilerType = this.options.compilerType || 'marko';\n        this.compilerVersion = this.options.compilerVersion || markoPkgVersion;\n        this.writeVersionComment = writeVersionComment !== 'undefined' ? writeVersionComment : true;\n\n        this._vars = {};\n        this._uniqueVars = new UniqueVars();\n        this._staticVars = {};\n        this._staticCode = null;\n        this._uniqueStaticVars = new UniqueVars();\n        this._srcCharProps = null;\n        this._flags = {};\n        this._errors = [];\n        this._macros = null;\n        this._preserveWhitespace = null;\n        this._preserveComments = null;\n        this.inline = this.options.inline === true;\n        this.useMeta = this.options.meta !== false;\n        this._moduleRuntimeTarget = this.outputType === 'vdom' ? 'marko/vdom' : 'marko/html';\n        this.unrecognizedTags = [];\n        this._parsingFinished = false;\n\n        this._helpersIdentifier = null;\n\n        if (this.options.preserveWhitespace) {\n            this.setPreserveWhitespace(true);\n        }\n\n        this._helpers = {};\n        this._imports = {};\n        this._fingerprint = undefined;\n        this._optimizers = undefined;\n    }\n\n    setInline(isInline) {\n        this.inline = isInline === true;\n    }\n\n    getPosInfo(pos) {\n        var srcCharProps = this._srcCharProps || (this._srcCharProps = charProps(this.src));\n        let line = srcCharProps.lineAt(pos)+1;\n        let column = srcCharProps.columnAt(pos);\n        return new PosInfo(this.filename, line, column);\n    }\n\n    getNodePos(node) {\n        if (node.pos) {\n            return this.getPosInfo(node.pos);\n        } else {\n            return new PosInfo(this.filename);\n        }\n    }\n\n    setFlag(name) {\n        this.pushFlag(name);\n    }\n\n    clearFlag(name) {\n        delete this._flags[name];\n    }\n\n    isFlagSet(name) {\n        return this._flags.hasOwnProperty(name);\n    }\n\n    pushFlag(name) {\n        if (this._flags.hasOwnProperty(name)) {\n            this._flags[name]++;\n        } else {\n            this._flags[name] = 1;\n        }\n    }\n\n    popFlag(name) {\n        if (!this._flags.hasOwnProperty(name)) {\n            throw new Error('popFlag() called for \"' + name + '\" when flag was not set');\n        }\n\n        if (--this._flags[name] === 0) {\n            delete this._flags[name];\n        }\n    }\n\n    pushData(key, data) {\n        var dataStack = this._dataStacks[key];\n        if (!dataStack) {\n            dataStack = this._dataStacks[key] = [];\n        }\n\n        dataStack.push(data);\n\n        return {\n            pop: () => {\n                this.popData(key);\n            }\n        };\n    }\n\n    popData(key) {\n        var dataStack = this._dataStacks[key];\n\n        if (!dataStack || dataStack.length === 0) {\n            throw new Error('No data pushed for \"' + key + '\"');\n        }\n\n        dataStack.pop();\n\n        if (dataStack.length === 0) {\n            delete this.data[key];\n        }\n    }\n\n    getData(name) {\n        var dataStack = this._dataStacks[name];\n        if (dataStack) {\n            return dataStack[dataStack.length - 1];\n        }\n\n        return this.data[name];\n    }\n\n    deprecate(message, node) {\n        var currentNode = node || this._currentNode;\n        var location = currentNode && currentNode.pos;\n\n        if (location != null) {\n            location = this.getPosInfo(location).toString();\n        }\n\n        complain(message, { location });\n    }\n\n    addError(errorInfo) {\n        if (errorInfo instanceof Node) {\n            let node = arguments[0];\n            let message = arguments[1];\n            let code = arguments[2];\n            let pos = arguments[3];\n            errorInfo = {\n                node,\n                message,\n                code,\n                pos\n            };\n        } else if (typeof errorInfo === 'string') {\n            let message = arguments[0];\n            let code = arguments[1];\n            let pos = arguments[2];\n\n            errorInfo = {\n                message,\n                code,\n                pos\n            };\n        }\n\n        if(errorInfo && !errorInfo.node) {\n            errorInfo.node = this._currentNode;\n        }\n\n        this._errors.push(new CompileError(errorInfo, this));\n    }\n\n    hasErrors() {\n        return this._errors.length !== 0;\n    }\n\n    getErrors() {\n        return this._errors;\n    }\n\n    getRequirePath(targetFilename) {\n        return markoModules.deresolve(targetFilename, this.dirname);\n    }\n\n    importModule(varName, path) {\n        if (typeof path !== 'string') {\n            throw new Error('\"path\" should be a string');\n        }\n\n        var varId = this._imports[path];\n\n        if (!varId) {\n            var builder = this.builder;\n            var requireFuncCall = this.builder.require(builder.literal(path));\n            this._imports[path] = varId = this.addStaticVar(varName, requireFuncCall);\n        }\n\n        return varId;\n    }\n\n    addVar(name, init) {\n        var actualVarName = this._uniqueVars.addVar(name, init);\n        this._vars[actualVarName] = init;\n        return this.builder.identifier(actualVarName);\n    }\n\n    getVars() {\n        return this._vars;\n    }\n\n    addStaticVar(name, init) {\n        var actualVarName = this._uniqueStaticVars.addVar(name, init);\n        this._staticVars[actualVarName] = init;\n        return this.builder.identifier(actualVarName);\n    }\n\n    getStaticVars() {\n        return this._staticVars;\n    }\n\n    addStaticCode(code) {\n        if (!code) {\n            return;\n        }\n\n        if (typeof code === 'string') {\n            // Wrap the String code in a Code AST node so that\n            // the code will be indented properly\n            code = this.builder.code(code);\n        }\n\n        if (this._staticCode == null) {\n            this._staticCode = [code];\n        } else {\n            this._staticCode.push(code);\n        }\n    }\n\n    getStaticCode() {\n        return this._staticCode;\n    }\n\n    getTagDef(tagName) {\n        var taglibLookup = this.taglibLookup;\n\n        if (typeof tagName === 'string') {\n            return taglibLookup.getTag(tagName);\n        } else {\n            let elNode = tagName;\n            if (elNode.tagDef) {\n                return elNode.tagDef;\n            }\n\n            return taglibLookup.getTag(elNode.tagName);\n        }\n    }\n\n    addErrorUnrecognizedTag(tagName, elNode) {\n        this.addError({\n            node: elNode,\n            message: 'Unrecognized tag: ' + tagName + ' - More details: https://github.com/marko-js/marko/wiki/Error:-Unrecognized-Tag'\n        });\n    }\n\n    createNodeForEl(tagName, attributes, argument, openTagOnly, selfClosed) {\n        var elDef;\n        var builder = this.builder;\n\n        if (typeof tagName === 'object') {\n            elDef = tagName;\n            tagName = elDef.tagName;\n            attributes = elDef.attributes;\n        } else {\n            elDef = { tagName, argument, attributes, openTagOnly, selfClosed };\n        }\n\n        if (elDef.tagName === '') {\n            elDef.tagName = tagName = 'assign';\n        }\n\n        if (!attributes) {\n            attributes = elDef.attributes = [];\n        } else if (typeof attributes === 'object') {\n            if (!Array.isArray(attributes)) {\n                attributes = elDef.attributes = Object.keys(attributes).map((attrName) => {\n                    var attrDef = {\n                        name: attrName\n                    };\n\n                    var val = attributes[attrName];\n                    if (val == null) {\n\n                    } if (val instanceof Node) {\n                        attrDef.value = val;\n                    } else {\n                        extend(attrDef, val);\n                    }\n\n                    return attrDef;\n                });\n            }\n        } else {\n            throw new Error('Invalid attributes');\n        }\n\n        var node;\n        var elNode = builder.htmlElement(elDef);\n        elNode.pos = elDef.pos;\n\n        this._currentNode = elNode;\n\n        var tagDef;\n\n        var taglibLookup = this.taglibLookup;\n\n        if (typeof tagName === 'string' && tagName.startsWith('@')) {\n            // NOTE: The tag definition can't be determined now since it will be\n            //       determined by the parent custom tag.\n            node = builder.customTag(elNode);\n            node.body = node.makeContainer(node.body.items);\n        } else {\n            if (typeof tagName === 'string') {\n                tagDef = taglibLookup.getTag(tagName);\n                if (!tagDef &&\n                        !this.isMacro(tagName) &&\n                        tagName.indexOf(':') === -1 &&\n                        !htmlElements.isRegisteredElement(tagName, this.dirname)) {\n\n                    if (this._parsingFinished) {\n                        this.addErrorUnrecognizedTag(tagName, elNode);\n                    } else {\n                        // We don't throw an error right away since the tag\n                        // may be a macro that gets registered later\n                        this.unrecognizedTags.push({\n                            node: elNode,\n                            tagName: tagName\n                        });\n                    }\n\n                }\n            }\n\n            if (tagDef) {\n                var nodeFactoryFunc = tagDef.getNodeFactory();\n                if (nodeFactoryFunc) {\n                    var newNode = nodeFactoryFunc(elNode, this);\n                    if (!(newNode instanceof Node)) {\n                        throw new Error('Invalid node returned from node factory for tag \"' + tagName + '\".');\n                    }\n\n                    if (newNode != node) {\n                        // Make sure the body container is associated with the correct node\n                        if (newNode.body && newNode.body !== node) {\n                            newNode.body = newNode.makeContainer(newNode.body.items);\n                        }\n                        node = newNode;\n                    }\n                }\n            }\n\n            if (!node) {\n                node = elNode;\n            }\n        }\n\n        if (tagDef && tagDef.noOutput) {\n            node.noOutput = true;\n        }\n\n        node.pos = elDef.pos;\n\n        var foundAttrs = {};\n\n        // Validate the attributes\n        attributes.forEach((attr) => {\n            let attrName = attr.name;\n            if (!attrName) {\n                // Attribute will be name for placeholder attributes. For example: <div ${data.myAttrs}>\n                return;\n            }\n            let attrDef = taglibLookup.getAttribute(tagName, attrName);\n            if (!attrDef) {\n                if (tagDef) {\n                    if (node.removeAttribute) {\n                        node.removeAttribute(attrName);\n                    }\n\n                    // var isAttrForTaglib = compiler.taglibs.isTaglib(attrUri);\n                    //Tag doesn't allow dynamic attributes\n                    this.addError({\n                        node: node,\n                        message: 'The tag \"' + tagName + '\" in taglib \"' + getTaglibPath(tagDef.taglibId) + '\" does not support attribute \"' + attrName + '\"'\n                    });\n\n                }\n                return;\n            }\n\n            if (attrDef.setFlag) {\n                node.setFlag(attrDef.setFlag);\n            }\n\n            attr.def = attrDef;\n\n            foundAttrs[attrName] = true;\n        });\n\n        if (tagDef) {\n            // Add default values for any attributes. If an attribute has a declared\n            // default value and the attribute was not found on the element\n            // then add the attribute with the specified default value\n            tagDef.forEachAttribute((attrDef) => {\n                var attrName = attrDef.name;\n\n                if (attrDef.hasOwnProperty('defaultValue') && !foundAttrs.hasOwnProperty(attrName)) {\n                    attributes.push({\n                        name: attrName,\n                        value: builder.literal(attrDef.defaultValue)\n                    });\n                } else if (attrDef.required === true) {\n                    // TODO Only throw an error if there is no data argument provided (just HTML attributes)\n                    if (!foundAttrs.hasOwnProperty(attrName)) {\n                        this.addError({\n                            node: node,\n                            message: 'The \"' + attrName + '\" attribute is required for tag \"' + tagName + '\" in taglib \"' + getTaglibPath(tagDef.taglibId) + '\".'\n                        });\n                    }\n                }\n            });\n\n            node.tagDef = tagDef;\n        }\n\n        return node;\n    }\n\n    isMacro(name) {\n        if (!this._macros) {\n            return false;\n        }\n\n        return this._macros.isMacro(name);\n    }\n\n    getRegisteredMacro(name) {\n        if (!this._macros) {\n            return undefined;\n        }\n\n        return this._macros.getRegisteredMacro(name);\n    }\n\n    registerMacro(name, params) {\n        if (!this._macros) {\n            this._macros = macros.createMacrosContext();\n        }\n\n        return this._macros.registerMacro(name, params);\n    }\n\n    importTemplate(relativePath, varName) {\n        ok(typeof relativePath === 'string', '\"path\" should be a string');\n        var builder = this.builder;\n\t\tvarName = varName || removeExt(path.basename(relativePath)) + '_template';\n\n        var templateVar;\n\n        if (this.options.browser || this.options.requireTemplates) {\n            // When compiling a Marko template for the browser we just use `require('./template.marko')`\n            templateVar = this.addStaticVar(varName, builder.require(builder.literal(relativePath)));\n        } else {\n            // When compiling a Marko template for the server we just use `loadTemplate(require.resolve('./template.marko'))`\n            let loadTemplateArg = requireResolve(builder, builder.literal(relativePath));\n            let loadFunctionCall = builder.functionCall(this.helper('loadTemplate'), [ loadTemplateArg ]);\n            templateVar = this.addStaticVar(varName, loadFunctionCall);\n        }\n\n        this.pushMeta('tags', builder.literal(relativePath), true);\n\n        return templateVar;\n    }\n\n    addDependency(path, type, options) {\n        var dependency;\n        if(typeof path === 'object') {\n            dependency = path;\n        } else {\n            dependency = (type ? type+':' : '') + path;\n        }\n        this.pushMeta('deps', dependency, true);\n    }\n\n    pushMeta(key, value, unique) {\n        var property;\n\n        property = this.meta[key];\n\n        if(!property) {\n            this.meta[key] = [value];\n        } else if(!unique || !property.some(e => JSON.stringify(e) === JSON.stringify(value))) {\n            property.push(value);\n        }\n    }\n\n    setMeta(key, value) {\n        this.meta[key] = value;\n    }\n\n    setPreserveWhitespace(preserveWhitespace) {\n        this._preserveWhitespace = preserveWhitespace;\n    }\n\n    beginPreserveWhitespace() {\n        this.pushFlag(FLAG_PRESERVE_WHITESPACE);\n    }\n\n    endPreserveWhitespace() {\n        this.popFlag(FLAG_PRESERVE_WHITESPACE);\n    }\n\n    isPreserveWhitespace() {\n        if (this.isFlagSet(FLAG_PRESERVE_WHITESPACE) || this._preserveWhitespace === true) {\n            return true;\n        }\n    }\n\n    setPreserveComments(preserveComments) {\n        this._preserveComments = preserveComments;\n    }\n\n    isPreserveComments() {\n        return this._preserveComments === true;\n    }\n\n    createWalker(options) {\n        return new Walker(options);\n    }\n\n    /**\n     * Statically resolves a path if it is a literal string. Otherwise, it returns the input expression.\n     */\n    resolvePath(pathExpression) {\n        ok(pathExpression, '\"pathExpression\" is required');\n\n        if (pathExpression.type === 'Literal') {\n            let path = pathExpression.value;\n            if (typeof path === 'string') {\n                return this.addStaticVar(path, this.builder.requireResolve(pathExpression));\n            }\n        }\n        return pathExpression;\n    }\n\n    resolveTemplate(pathExpression) {\n        ok(pathExpression, '\"pathExpression\" is required');\n\n        if (pathExpression.type === 'Literal') {\n            let path = pathExpression.value;\n            if (typeof path === 'string') {\n                return this.importTemplate(path);\n            }\n        }\n\n        return pathExpression;\n    }\n\n    getStaticNodes(additionalVars) {\n        let builder = this.builder;\n        let staticNodes = [];\n        let staticVars = this.getStaticVars();\n\n        let staticVarNodes = Object.keys(staticVars).map((varName) => {\n            var varInit = staticVars[varName];\n            return builder.variableDeclarator(varName, varInit);\n        });\n\n        if(additionalVars) {\n            staticVarNodes = additionalVars.concat(staticVarNodes);\n        }\n\n        if (staticVarNodes.length) {\n            staticNodes.push(this.builder.vars(staticVarNodes));\n        }\n\n        var staticCodeArray = this.getStaticCode();\n\n        if (staticCodeArray) {\n            staticNodes = staticNodes.concat(staticCodeArray);\n        }\n\n        return staticNodes;\n    }\n\n    get helpersIdentifier() {\n        if (!this._helpersIdentifier) {\n            var target = this.outputType === 'vdom' ? 'marko/runtime/vdom/helpers' : 'marko/runtime/html/helpers';\n            this._helpersIdentifier = this.importModule('marko_helpers', target);\n        }\n        return this._helpersIdentifier;\n    }\n\n    helper(name) {\n        var helperIdentifier = this._helpers[name];\n        if (!helperIdentifier) {\n            var helperInfo = helpers[name];\n\n            if (helperInfo && typeof helperInfo === 'object') {\n                if (!helperInfo.module) {\n                    helperInfo = helperInfo[this.outputType];\n                }\n            }\n\n            if (!helperInfo) {\n                throw new Error('Invalid helper: ' + name);\n            }\n\n            if (typeof helperInfo === 'string') {\n                let methodName = helperInfo;\n                var methodIdentifier = this.builder.identifier(methodName);\n\n                helperIdentifier = this.addStaticVar(\n                    'marko_' + name,\n                    this.builder.memberExpression(this.helpersIdentifier, methodIdentifier));\n            } else if (helperInfo && helperInfo.module) {\n                helperIdentifier = this.addStaticVar(\n                    'marko_' + name,\n                    this.builder.require(this.builder.literal(helperInfo.module)));\n            } else {\n                throw new Error('Invalid helper: ' + name);\n            }\n\n            this._helpers[name] = helperIdentifier;\n        }\n\n        return helperIdentifier;\n    }\n\n    getFingerprint(len) {\n        var fingerprint = this._fingerprint;\n        if (!fingerprint) {\n            this._fingerprint = fingerprint = utilFingerprint(this.src);\n        }\n\n        if (len == null || len >= this._fingerprint) {\n            return fingerprint;\n        } else {\n            return fingerprint.substring(0, len);\n        }\n    }\n\n    addOptimizer(optimizer) {\n        if (this._optimizers) {\n            this._optimizers.push(optimizer);\n        } else {\n            this._optimizers = [optimizer];\n        }\n    }\n\n    optimize(rootNode) {\n        if (this._optimizers) {\n            this._optimizers.forEach((optimizer) => {\n                optimizer.optimize(rootNode, this);\n            });\n        }\n    }\n\n    getModuleRuntimeTarget() {\n        return this._moduleRuntimeTarget;\n    }\n}\n\nCompileContext.prototype.util = {\n    isValidJavaScriptIdentifier: require('./util/isValidJavaScriptIdentifier'),\n    isJavaScriptReservedWord: require('./util/isJavaScriptReservedWord')\n};\n\nmodule.exports = CompileContext;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-lookup/index.js":"'use strict';\nexports.registerTaglib = registerTaglib;\nexports.buildLookup = buildLookup;\nexports.clearCache = clearCache;\n\nvar taglibLoader;\nvar taglibFinder;\nvar TaglibLookup;\n\nexports.registeredTaglibs = [];\n\nvar lookupCache = {};\n\nfunction handleImports(lookup, taglib) {\n\tif (taglib.imports) {\n\t\tfor (var i=0; i<taglib.imports.length; i++) {\n\t\t\tvar importedTaglib = taglib.imports[i];\n\n\t\t\tif (!lookup.hasTaglib(importedTaglib)) {\n\t\t\t\tlookup.addTaglib(importedTaglib);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction buildLookup(dirname) {\n\tvar taglibs = taglibFinder.find(dirname, exports.registeredTaglibs);\n\n\tvar lookupCacheKey = taglibs\n\t\t.map(function(taglib) {\n\t\t\treturn taglib.id;\n\t\t})\n\t\t.join(',');\n\n\tvar lookup = lookupCache[lookupCacheKey];\n\tif (lookup === undefined) {\n\t\tlookup = new TaglibLookup();\n\t\t// The taglibs \"closer\" to the template will be earlier in the list\n\t\t// and the taglibs \"farther\" from the template will be later. We\n\t\t// want closer taglibs to take precedence (especially when de-duping)\n\t\t// so we loop from beginning to end. We used to loop from the end\n\t\t// to the beginning, but that appears to have been a mistake.\n        for (var i=0; i<taglibs.length; i++) {\n\t\t\tvar taglib = taglibs[i];\n\t\t\tlookup.addTaglib(taglib);\n\t\t\thandleImports(lookup, taglib);\n\t\t}\n\n\t\tlookupCache[lookupCacheKey] = lookup;\n\t}\n\n\treturn lookup;\n}\n\nfunction registerTaglib(taglib) {\n    if (typeof taglib === 'string') {\n        let taglibPath = taglib;\n        taglib = taglibLoader.loadFromFile(taglibPath);\n    }\n\n    exports.registeredTaglibs.push(taglib);\n}\n\nfunction clearCache() {\n\tlookupCache = {};\n}\n\ntaglibLoader = require('../taglib-loader');\ntaglibFinder = require('../taglib-finder');\nTaglibLookup = require('./TaglibLookup');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/index.js":"var cache = require('./cache');\n\nvar types = require('./types');\nvar loaders = require('./loaders');\nvar DependencyChain = require('./DependencyChain');\n\nfunction loadTaglibFromProps(taglib, taglibProps) {\n    return loaders.loadTaglibFromProps(taglib, taglibProps);\n}\n\nfunction loadTaglibFromFile(filePath) {\n    return loaders.loadTaglibFromFile(filePath);\n}\n\nfunction clearCache() {\n    cache.clear();\n}\n\nfunction createTaglib(filePath) {\n    return new types.Taglib(filePath);\n}\n\nfunction loadTag(tagProps, filePath) {\n    var tag = new types.Tag(filePath);\n    loaders.loadTagFromProps(tag, tagProps, new DependencyChain(filePath ? [filePath] : []));\n    return tag;\n}\n\nexports.clearCache = clearCache;\nexports.createTaglib = createTaglib;\nexports.loadTaglibFromProps = loadTaglibFromProps;\nexports.loadTaglibFromFile = loadTaglibFromFile;\nexports.loadTag = loadTag;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/cache.js":"var cache = {};\n\nfunction get(key) {\n    return cache[key];\n}\n\nfunction put(key, value) {\n    cache[key] = value;\n}\n\nfunction clear() {\n    cache = {};\n}\n\nexports.get = get;\nexports.put = put;\nexports.clear = clear;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/types.js":"exports.Taglib = require('./Taglib');\nexports.Tag = require('./Tag');\nexports.Attribute = require('./Attribute');\nexports.Property = require('./Property');\nexports.NestedVariable = require('./NestedVariable');\nexports.ImportedVariable = require('./ImportedVariable');\nexports.Transformer = require('./Transformer');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/Taglib.js":"'use strict';\nvar forEachEntry = require('raptor-util/forEachEntry');\nvar ok = require('assert').ok;\nvar path = require('path');\nvar loaders = require('./loaders');\n\nfunction handleImport(taglib, importedTaglib) {\n    var importsLookup = taglib.importsLookup || (taglib.importsLookup = {});\n    if (importsLookup.hasOwnProperty(importedTaglib.path)) {\n        return;\n    }\n\n    importsLookup[importedTaglib.path] = importedTaglib;\n\n    if (!taglib.imports) {\n        taglib.imports = [];\n    }\n\n    taglib.imports.push(importedTaglib);\n\n    if (importedTaglib.imports) {\n        importedTaglib.imports.forEach(function(nestedImportedTaglib) {\n            handleImport(taglib, nestedImportedTaglib);\n        });\n    }\n}\n\nclass Taglib {\n    constructor(filePath) {\n        ok(filePath, '\"filePath\" expected');\n        this.filePath = this.path /* deprecated */ = this.id = filePath;\n        this.dirname = path.dirname(this.filePath);\n        this.tags = {};\n        this.textTransformers = [];\n        this.transformers = [];\n        this.attributes = {};\n        this.patternAttributes = [];\n        this.inputFilesLookup = {};\n        this.imports = null;\n        this.importsLookup = null;\n    }\n\n    addAttribute(attribute) {\n        ok(attribute.key, '\"key\" is required for global attributes');\n\n        attribute.filePath = this.filePath;\n\n        if (!attribute.pattern && !attribute.name) {\n            throw new Error('Invalid attribute: ' + require('util').inspect(attribute));\n        }\n\n        this.attributes[attribute.key] = attribute;\n    }\n    getAttribute(name) {\n        var attribute = this.attributes[name];\n        if (!attribute) {\n            for (var i = 0, len = this.patternAttributes.length; i < len; i++) {\n                var patternAttribute = this.patternAttributes[i];\n                if (patternAttribute.pattern.test(name)) {\n                    attribute = patternAttribute;\n                }\n            }\n        }\n        return attribute;\n    }\n    addTag(tag) {\n        ok(arguments.length === 1, 'Invalid args');\n        if (!tag.name) {\n            throw new Error('\"tag.name\" is required: ' + JSON.stringify(tag));\n        }\n        this.tags[tag.name] = tag;\n        tag.taglibId = this.id || this.path;\n    }\n    addTextTransformer(transformer) {\n        this.textTransformers.push(transformer);\n    }\n    addTransformer(transformer) {\n        this.transformers.push(transformer);\n    }\n    forEachTag(callback, thisObj) {\n        forEachEntry(this.tags, function (key, tag) {\n            callback.call(thisObj, tag);\n        }, this);\n    }\n\n    addImport(path) {\n        var importedTaglib = loaders.loadTaglibFromFile(path);\n        handleImport(this, importedTaglib);\n    }\n\n    toJSON() {\n        return {\n            path: this.path,\n            tags: this.tags,\n            textTransformers: this.textTransformers,\n            attributes: this.attributes,\n            patternAttributes: this.patternAttributes,\n            imports: this.imports\n        };\n    }\n}\n\nmodule.exports = Taglib;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loaders.js":"var types = require('./types');\n\nfunction isSupportedAttributeProperty(propertyName) {\n    return exports.loadAttributeFromProps.isSupportedProperty(propertyName);\n}\n\nfunction isSupportedTagProperty(propertyName) {\n    return exports.loadTagFromProps.isSupportedProperty(propertyName);\n}\n\nfunction createTaglib(taglibPath) {\n    return new types.Taglib(taglibPath);\n}\n\nexports.createTaglib = createTaglib;\nexports.loadAttributeFromProps = require('./loadAttributeFromProps');\nexports.loadTagFromProps = require('./loadTagFromProps');\nexports.loadTagFromFile = require('./loadTagFromFile');\nexports.loadTaglibFromProps = require('./loadTaglibFromProps');\nexports.loadTaglibFromFile = require('./loadTaglibFromFile');\nexports.loadAttributes = require('./loadAttributes');\nexports.isSupportedAttributeProperty = isSupportedAttributeProperty;\nexports.isSupportedTagProperty = isSupportedTagProperty;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loadAttributeFromProps.js":"'use strict';\n\nvar assert = require('assert');\nvar raptorRegexp = require('raptor-regexp');\nvar propertyHandlers = require('property-handlers');\nvar types = require('./types');\nvar createError = require('raptor-util/createError');\n\nclass AttrLoader {\n    constructor(attr, dependencyChain) {\n        assert.ok(attr, '\"attr\" is required');\n        assert.ok(dependencyChain, '\"dependencyChain\" is required');\n\n        this.attr = attr;\n        this.dependencyChain = dependencyChain;\n    }\n\n    load(attrProps) {\n        assert.ok(arguments.length === 1);\n\n        if (attrProps == null) {\n            attrProps = {};\n        } else if (typeof attrProps === 'string') {\n            attrProps = {\n                type: attrProps\n            };\n        } else {\n            assert.ok(typeof attrProps === 'object', 'Invalid \"attrProps\"');\n        }\n\n        propertyHandlers(attrProps, this, this.dependencyChain.toString());\n    }\n\n    /**\n     * The attribute type. One of the following:\n     * - string (the default)\n     * - expression (a JavaScript expression)\n     * - number\n     * - integer\n     * - int\n     * - boolean\n     * - float\n     * - double\n     * - object\n     * - array\n     *\n     */\n    type(value) {\n        var attr = this.attr;\n        if (value.charAt(0) === '#') {\n            attr.ref = value.substring(1);\n        } else {\n            attr.type = value;\n        }\n    }\n\n    /**\n     * The name of the target property to use when mapping\n     * the attribute to a property on the target object.\n     */\n    targetProperty(value) {\n        var attr = this.attr;\n        attr.targetProperty = value;\n    }\n    /**\n     * The \"default-value\" property allows a default value\n     * to be provided when the attribute is not declared\n     * on the custom tag.\n     */\n    defaultValue(value) {\n        var attr = this.attr;\n        attr.defaultValue = value;\n    }\n    /**\n     * The \"pattern\" property allows the attribute\n     * to be matched based on a simplified regular expression.\n     *\n     * Example:\n     *\n     * \"pattern\": \"myprefix-*\"\n     */\n    pattern(value) {\n        var attr = this.attr;\n        if (value === true) {\n            var patternRegExp = raptorRegexp.simple(attr.name);\n            attr.pattern = patternRegExp;\n        }\n    }\n\n    /**\n     * If \"allow-expressions\" is set to true (the default) then\n     * the the attribute value will be parsed to find any dynamic\n     * parts.\n     */\n    allowExpressions(value) {\n        var attr = this.attr;\n        attr.allowExpressions = value;\n    }\n\n    /**\n     * By default, the Marko compiler maps an attribute\n     * to a property by removing all dashes from the attribute\n     * name and converting each character after a dash to\n     * an uppercase character (e.g. \"my-attr\" --> \"myAttr\").\n     *\n     * Setting \"preserve-name\" to true will prevent this from\n     * happening for the attribute.\n     */\n    preserveName(value) {\n        var attr = this.attr;\n        attr.preserveName = value;\n    }\n    /**\n     * Declares an attribute as required. Currently, this is\n     * not enforced and is only used for documentation purposes.\n     *\n     * Example:\n     * \"required\": true\n     */\n    required(value) {\n        var attr = this.attr;\n        attr.required = value === true;\n    }\n    /**\n     * This is the opposite of \"preserve-name\" and will result\n     * in dashes being removed from the attribute if set to true.\n     */\n    removeDashes(value) {\n        var attr = this.attr;\n        attr.removeDashes = value === true;\n    }\n    /**\n     * The description of the attribute. Only used for documentation.\n     */\n    description() {\n\n    }\n\n    /**\n     * The \"set-flag\" property allows a \"flag\" to be added to a Node instance\n     * at compile time if the attribute is found on the node. This is helpful\n     * if an attribute uses a pattern and a transformer wants to have a simple\n     * check to see if the Node has an attribute that matched the pattern.\n     *\n     * Example:\n     *\n     * \"set-flag\": \"myCustomFlag\"\n     *\n     * A Node instance can be checked if it has a flag set as shown below:\n     *\n     * if (node.hasFlag('myCustomFlag')) { ... }\n     *\n     *\n     */\n    setFlag(value) {\n        var attr = this.attr;\n        attr.setFlag = value;\n    }\n    /**\n     * An attribute can be marked for ignore. Ignored attributes\n     * will be ignored during compilation.\n     */\n    ignore(value) {\n        var attr = this.attr;\n        if (value === true) {\n            attr.ignore = true;\n        }\n    }\n\n    autocomplete(value) {\n        this.attr.autocomplete = value;\n    }\n\n    enum(value) {\n        this.attr.enum = value;\n    }\n\n    deprecated(value) {\n        this.attr.deprecated = value;\n    }\n\n    name(value) {\n        this.attr.name = value;\n    }\n\n    html(value) {\n        this.attr.html = value === true;\n    }\n}\n\n\nfunction loadAttributeFromProps(attrName, attrProps, dependencyChain) {\n    assert.ok(typeof attrName === 'string');\n    assert.ok(dependencyChain, '\"dependencyChain\" is required');\n\n    var attr = new types.Attribute(attrName);\n\n    var attrLoader = new AttrLoader(attr, dependencyChain);\n\n    try {\n        attrLoader.load(attrProps);\n    } catch(err) {\n        throw createError('Unable to load attribute \"' + attrName + '\" (' + dependencyChain + '): ' + err, err);\n    }\n\n    return attr;\n}\n\nloadAttributeFromProps.isSupportedProperty = function(name) {\n    return AttrLoader.prototype.hasOwnProperty(name);\n};\n\n\nmodule.exports = loadAttributeFromProps;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loadTagFromProps.js":"'use strict';\n\nvar ok = require('assert').ok;\nvar propertyHandlers = require('property-handlers');\nvar isObjectEmpty = require('raptor-util/isObjectEmpty');\nvar nodePath = require('path');\nvar markoModules = require('../modules'); // NOTE: different implementation for browser\nvar ok = require('assert').ok;\nvar bodyFunctionRegExp = /^([A-Za-z_$][A-Za-z0-9_]*)(?:\\(([^)]*)\\))?$/;\nvar safeVarName = /^[A-Za-z_$][A-Za-z0-9_]*$/;\nvar propertyHandlers = require('property-handlers');\nvar forEachEntry = require('raptor-util/forEachEntry');\nvar markoCompiler = require('../');\nvar createError = require('raptor-util/createError');\nvar types = require('./types');\nvar loaders = require('./loaders');\n\n\nfunction exists(path) {\n    try {\n        markoModules.resolve(path);\n        return true;\n    } catch(e) {\n        return false;\n    }\n}\n\nfunction removeDashes(str) {\n    return str.replace(/-([a-z])/g, function (match, lower) {\n        return lower.toUpperCase();\n    });\n}\n\nfunction hasAttributes(tagProps) {\n    if (tagProps.attributes != null) {\n        return true;\n    }\n\n    for (var name in tagProps) {\n        if (tagProps.hasOwnProperty(name) && name.startsWith('@')) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\n/**\n * We load tag definition using this class. Properties in the taglib\n * definition (which is just a JavaScript object with properties)\n * are mapped to handler methods in an instance of this type.\n *\n * @param {Tag} tag The initially empty Tag instance that we populate\n * @param {String} dirname The full file system path associated with the tag being loaded\n * @param {String} path An informational path associated with this tag (used for error reporting)\n */\nclass TagLoader {\n    constructor(tag, dependencyChain) {\n        this.tag = tag;\n        this.dependencyChain = dependencyChain;\n\n        this.filePath = tag.filePath;\n        this.dirname = tag.dir || tag.dirname;\n    }\n\n    load(tagProps) {\n        if (!hasAttributes(tagProps)) {\n            // allow any attributes if no attributes are declared\n            tagProps.attributes = {\n                '*': {\n                    type: 'string',\n                    targetProperty: null,\n                    preserveName: false\n                }\n            };\n        }\n\n\n\n        propertyHandlers(tagProps, this, this.dependencyChain.toString());\n    }\n\n    _handleVar(value, dependencyChain) {\n        var tag = this.tag;\n\n        var nestedVariable;\n\n        if (typeof value === 'string') {\n            nestedVariable = {\n                name: value\n            };\n        } else {\n            nestedVariable = {};\n\n            propertyHandlers(value, {\n\n                name: function(value) {\n                    nestedVariable.name = value;\n                },\n\n                nameFromAttribute: function(value) {\n                    nestedVariable.nameFromAttribute = value;\n                }\n\n            }, dependencyChain.toString());\n\n            if (!nestedVariable.name && !nestedVariable.nameFromAttribute) {\n                throw new Error('The \"name\" or \"name-from-attribute\" attribute is required for a nested variable (' + dependencyChain + ')');\n            }\n        }\n\n        tag.addNestedVariable(nestedVariable);\n    }\n\n    /**\n     * This is handler is for any properties that didn't match\n     * one of the default property handlers. This is used to\n     * match properties in the form of \"@attr_name\" or\n     * \"<nested_tag_name>\"\n     */\n    '*'(name, value) {\n        var tag = this.tag;\n        var dependencyChain = this.dependencyChain;\n        var parts = name.split(/\\s+|\\s+[,]\\s+/);\n\n        var i;\n        var part;\n\n        var hasNestedTag = false;\n        var hasAttr = false;\n        var nestedTagTargetProperty = null;\n\n        // We do one pass to figure out if there is an\n        // attribute or nested tag or both\n        for (i=0; i<parts.length; i++) {\n            part = parts[i];\n            if (part.startsWith('@')) {\n                hasAttr = true;\n\n                if (i === 0) {\n                    // Use the first attribute value as the name of the target property\n                    nestedTagTargetProperty = part.substring(1);\n                }\n            } else if (part.startsWith('<')) {\n                hasNestedTag = true;\n            } else {\n                // Unmatched property that is not an attribute or a\n                // nested tag\n                return false;\n            }\n        }\n\n        var attrProps = {};\n        var tagProps = {};\n        var k;\n\n        if (value != null && typeof value === 'object') {\n            for (k in value) {\n                if (value.hasOwnProperty(k)) {\n                    if (k.startsWith('@') || k.startsWith('<')) {\n                        // Move over all of the attributes and nested tags\n                        // to the tag definition.\n                        tagProps[k] = value[k];\n                        delete value[k];\n                    } else {\n                        // The property is not a shorthand attribute or shorthand\n                        // tag so move it over to either the tag definition\n                        // or the attribute definition or both the tag definition\n                        // and attribute definition.\n                        var propNameDashes = removeDashes(k);\n\n                        if (isSupportedProperty(propNameDashes) &&\n                            loaders.isSupportedAttributeProperty(propNameDashes)) {\n                            // Move over all of the properties that are associated with a tag\n                            // and attribute\n                            tagProps[k] = value[k];\n                            attrProps[k] = value[k];\n                            delete value[k];\n                        } else if (isSupportedProperty(propNameDashes)) {\n                            // Move over all of the properties that are associated with a tag\n                            tagProps[k] = value[k];\n                            delete value[k];\n                        } else if (loaders.isSupportedAttributeProperty(propNameDashes)) {\n                            // Move over all of the properties that are associated with an attr\n                            attrProps[k] = value[k];\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n\n            // If there are any left over properties then something is wrong\n            // with the user's taglib.\n            if (!isObjectEmpty(value)) {\n                throw new Error('Unsupported properties of [' +\n                    Object.keys(value).join(', ') +\n                    ']');\n            }\n\n            var type = attrProps.type;\n            if (!type && hasAttr && hasNestedTag) {\n                // If we have an attribute and a nested tag then default\n                // the attribute type to \"expression\"\n                attrProps.type = 'expression';\n            }\n        } else if (typeof value === 'string') {\n            if (hasNestedTag && hasAttr) {\n                tagProps = attrProps = {\n                    type: value\n                };\n            } else if (hasNestedTag) {\n                tagProps = {\n                    type: value\n                };\n            } else {\n                attrProps = {\n                    type: value\n                };\n            }\n        }\n\n        // Now that we have separated out attribute properties and tag properties\n        // we need to create the actual attributes and nested tags\n        for (i=0; i<parts.length; i++) {\n            part = parts[i];\n            if (part.startsWith('@')) {\n                // This is a shorthand attribute\n                var attrName = part.substring(1);\n\n                var attr = loaders.loadAttributeFromProps(\n                    attrName,\n                    attrProps,\n                    dependencyChain.append(part));\n\n                tag.addAttribute(attr);\n            } else if (part.startsWith('<')) {\n\n                // This is a shorthand nested tag\n                let nestedTag = new types.Tag(this.filePath);\n\n                loadTagFromProps(\n                    nestedTag,\n                    tagProps,\n                    dependencyChain.append(part));\n\n                // We use the '[]' suffix to indicate that a nested tag\n                // can be repeated\n                var isNestedTagRepeated = false;\n                if (part.endsWith('[]')) {\n                    isNestedTagRepeated = true;\n                    part = part.slice(0, -2);\n                }\n\n                var nestedTagName = part.substring(1, part.length-1);\n                nestedTag.name = nestedTagName;\n                nestedTag.isRepeated = isNestedTagRepeated;\n                // Use the name of the attribute as the target property unless\n                // this target property was explicitly provided\n                nestedTag.targetProperty = attrProps.targetProperty || nestedTagTargetProperty;\n                tag.addNestedTag(nestedTag);\n\n                if (!nestedTag.isRepeated) {\n                    let attr = loaders.loadAttributeFromProps(\n                        nestedTag.targetProperty,\n                        { type: 'object' },\n                        dependencyChain.append(part));\n\n                    tag.addAttribute(attr);\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * The tag name\n     * @param {String} value The tag name\n     */\n    name(value) {\n        var tag = this.tag;\n        tag.name = value;\n    }\n\n    /**\n     * The path to the renderer JS module to use for this tag.\n     *\n     * NOTE: We use the equivalent of require.resolve to resolve the JS module\n     * \t\t and use the tag directory as the \"from\".\n     *\n     * @param {String} value The renderer path\n     */\n    renderer(value) {\n        var tag = this.tag;\n        var dirname = this.dirname;\n        var path = markoModules.resolveFrom(dirname, value);\n        tag.renderer = path;\n    }\n\n    /**\n     * A tag can use a renderer or a template to do the rendering. If\n     * a template is provided then the value should be the path to the\n     * template to use to render the custom tag.\n     */\n    template(value) {\n        var tag = this.tag;\n        var dirname = this.dirname;\n\n        var path = nodePath.resolve(dirname, value);\n        if (!exists(path)) {\n            throw new Error('Template at path \"' + path + '\" does not exist.');\n        }\n        tag.template = path;\n    }\n\n    /**\n     * An Object where each property maps to an attribute definition.\n     * The property key will be the attribute name and the property value\n     * will be the attribute definition. Example:\n     * {\n     *     \"attributes\": {\n     *         \"foo\": \"string\",\n     *         \"bar\": \"expression\"\n     *     }\n     * }\n     */\n    attributes(value) {\n        var tag = this.tag;\n\n        loaders.loadAttributes(value, tag, this.dependencyChain.append('attributes'));\n    }\n\n    /**\n     * A custom tag can be mapped to module that is is used\n     * to generate compile-time code for the custom tag. A\n     * node type is created based on the methods and methods\n     * exported by the code codegen module.\n     */\n    codeGenerator(value) {\n        var tag = this.tag;\n        var dirname = this.dirname;\n\n        var path = markoModules.resolveFrom(dirname, value);\n        tag.codeGeneratorModulePath = path;\n    }\n\n    /**\n     * A custom tag can be mapped to a compile-time Node that gets\n     * added to the parsed Abstract Syntax Tree (AST). The Node can\n     * then generate custom JS code at compile time. The value\n     * should be a path to a JS module that gets resolved using the\n     * equivalent of require.resolve(path)\n     */\n    nodeFactory(value) {\n        var tag = this.tag;\n        var dirname = this.dirname;\n\n        var path = markoModules.resolveFrom(dirname, value);\n        tag.nodeFactoryPath = path;\n    }\n\n    /**\n     * If the \"preserve-whitespace\" property is set to true then\n     * all whitespace nested below the custom tag in a template\n     * will be stripped instead of going through the normal whitespace\n     * removal rules.\n     */\n    preserveWhitespace(value) {\n        var tag = this.tag;\n        tag.preserveWhitespace = !!value;\n    }\n\n    /**\n     * If a custom tag has an associated transformer then the transformer\n     * will be called on the compile-time Node. The transformer can manipulate\n     * the AST using the DOM-like API to change how the code gets generated.\n     */\n    transformer(value) {\n        var tag = this.tag;\n        var dirname = this.dirname;\n\n        var transformer = new types.Transformer();\n\n        if (typeof value === 'string') {\n            // The value is a simple string type\n            // so treat the value as the path to the JS\n            // module for the transformer\n            value = {\n                path: value\n            };\n        }\n\n        /**\n         * The transformer is a complex type and we need\n         * to process each property to load the Transformer\n         * definition.\n         */\n        propertyHandlers(value, {\n            path(value) {\n                var path = markoModules.resolveFrom(dirname, value);\n                transformer.path = path;\n            },\n\n            priority(value) {\n                transformer.priority = value;\n            },\n\n            name(value) {\n                transformer.name = value;\n            },\n\n            properties(value) {\n                var properties = transformer.properties || (transformer.properties = {});\n                for (var k in value) {\n                    if (value.hasOwnProperty(k)) {\n                        properties[k] = value[k];\n                    }\n                }\n            }\n\n        }, this.dependencyChain.append('transformer'));\n\n        ok(transformer.path, '\"path\" is required for transformer');\n\n        tag.addTransformer(transformer);\n    }\n\n    /**\n     * The \"var\" property is used to declared nested variables that get\n     * added as JavaScript variables at compile time.\n     *\n     * Examples:\n     *\n     * \"var\": \"myScopedVariable\",\n     *\n     * \"var\": {\n     *     \"name\": \"myScopedVariable\"\n     * }\n     *\n     * \"var\": {\n     *     \"name-from-attribute\": \"var\"\n     * }\n     */\n    var(value) {\n        this._handleVar(value, this.dependencyChain.append('var'));\n    }\n    /**\n     * The \"vars\" property is equivalent to the \"var\" property\n     * except that it expects an array of nested variables.\n     */\n    vars(value) {\n        if (value) {\n            value.forEach((v, i) => {\n                this._handleVar(v, this.dependencyChain.append('vars[' + i + ']'));\n            });\n        }\n    }\n    /**\n     * The \"body-function\" property\" allows the nested body content to be mapped\n     * to a function at compile time. The body function gets mapped to a property\n     * of the tag renderer at render time. The body function can have any number\n     * of parameters.\n     *\n     * Example:\n     * - \"body-function\": \"_handleBody(param1, param2, param3)\"\n     */\n    bodyFunction(value) {\n        var tag = this.tag;\n        var parts = bodyFunctionRegExp.exec(value);\n        if (!parts) {\n            throw new Error('Invalid value of \"' + value + '\" for \"body-function\". Expected value to be of the following form: <function-name>([param1, param2, ...])');\n        }\n\n        var functionName = parts[1];\n        var params = parts[2];\n        if (params) {\n            params = params.trim().split(/\\s*,\\s*/);\n            for (var i=0; i<params.length; i++) {\n                if (params[i].length === 0) {\n                    throw new Error('Invalid parameters for body-function with value of \"' + value + '\"');\n                } else if (!safeVarName.test(params[i])) {\n                    throw new Error('Invalid parameter name of \"' + params[i] + '\" for body-function with value of \"' + value + '\"');\n                }\n            }\n        } else {\n            params = [];\n        }\n\n        tag.setBodyFunction(functionName, params);\n    }\n    /**\n     * The \"import-var\" property can be used to add a property to the\n     * input object of the tag renderer whose value is determined by\n     * a JavaScript expression.\n     *\n     * Example:\n     * \"import-var\": {\n     *     \"myTargetProperty\": \"data.myCompileTimeJavaScriptExpression\",\n     * }\n     */\n    importVar(value) {\n        var tag = this.tag;\n        forEachEntry(value, (varName, varValue) => {\n            var importedVar = {\n                targetProperty: varName\n            };\n\n            var expression = varValue;\n\n            if (!expression) {\n                expression = varName;\n            }\n            else if (typeof expression === 'object') {\n                expression = expression.expression;\n            }\n\n            if (!expression) {\n                throw new Error('Invalid \"import-var\": ' + require('util').inspect(varValue));\n            }\n\n            importedVar.expression = markoCompiler.builder.parseExpression(expression);\n            tag.addImportedVariable(importedVar);\n        });\n    }\n    /**\n     * The tag type.\n     */\n    type(value) {\n        var tag = this.tag;\n        tag.type = value;\n    }\n    /**\n     * Declare a nested tag.\n     *\n     * Example:\n     * {\n     *     ...\n     *     \"nested-tags\": {\n     *        \"tab\": {\n     *            \"target-property\": \"tabs\",\n     *            \"isRepeated\": true\n     *        }\n     *     }\n     * }\n     */\n    nestedTags(value) {\n        var filePath = this.filePath;\n        var tag = this.tag;\n\n        forEachEntry(value, (nestedTagName, nestedTagDef) => {\n            var dependencyChain = this.dependencyChain.append(`nestedTags[\"${nestedTagName}]`);\n            var nestedTag = new types.Tag(filePath);\n\n            loadTagFromProps(\n                nestedTag,\n                nestedTagDef,\n                dependencyChain);\n\n            nestedTag.name = nestedTagName;\n            tag.addNestedTag(nestedTag);\n\n            if (!nestedTag.isRepeated) {\n                let attr = loaders.loadAttributeFromProps(\n                    nestedTag.targetProperty,\n                    { type: 'object' },\n                    dependencyChain);\n\n                tag.addAttribute(attr);\n            }\n        });\n    }\n    escapeXmlBody(value) {\n        if (value === false) {\n            this.tag.escapeXmlBody = false;\n        }\n    }\n\n    /**\n     * Sends the body content type. This is used to control how the body\n     * content is parsed.\n     */\n    body(value) {\n        if (value === 'static-text' || value === 'parsed-text' || value === 'html') {\n            this.tag.body = value;\n        } else {\n            throw new Error('Invalid value for \"body\". Allowed: \"static-text\", \"parsed-text\" or \"html\"');\n        }\n    }\n\n    openTagOnly(value) {\n        this.tag.openTagOnly = value;\n    }\n\n    noOutput(value) {\n        this.tag.noOutput = value;\n    }\n\n    autocomplete(value) {\n        this.tag.autocomplete = value;\n    }\n\n    parseOptions(value) {\n        this.tag.parseOptions = value;\n    }\n\n    deprecated(value) {\n        this.tag.deprecated = value;\n    }\n\n    parseAttributes(value) {\n        this.tag.parseAttributes = value;\n    }\n\n    attributeGroups(value) {\n        if (!value) {\n            return;\n        }\n\n        var attributeGroups = this.tag.attributeGroups || (this.tag.attributeGroups = []);\n        this.tag.attributeGroups = attributeGroups.concat(value);\n    }\n\n    html(value) {\n        this.tag.html = value === true;\n    }\n\n    htmlType(value) {\n        this.tag.htmlType = value;\n    }\n}\n\nfunction isSupportedProperty(name) {\n    return TagLoader.prototype.hasOwnProperty(name);\n}\n\nfunction loadTagFromProps(tag, tagProps, dependencyChain) {\n    ok(typeof tagProps === 'object', 'Invalid \"tagProps\"');\n    ok(dependencyChain, '\"dependencyChain\" is required');\n\n    var tagLoader = new TagLoader(tag, dependencyChain);\n\n    try {\n        tagLoader.load(tagProps);\n    } catch(err) {\n        throw createError('Unable to load tag (' + dependencyChain + '): ' + err, err);\n    }\n\n    return tag;\n}\n\n\n\nmodule.exports = loadTagFromProps;\n\nloadTagFromProps.isSupportedProperty = isSupportedProperty;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/modules.js":"var nativeRequire = require;\nvar resolveFrom = require('resolve-from');\nvar deresolve = require('./util/deresolve');\n\nconst deresolveOptions = {\n    shouldRemoveExt(ext) {\n        return ext === '.js' || ext === '.json' || ext === '.es6';\n    }\n};\n\n// This allows us to swap out a different implementation in the browser...\n// We only need this to make Try Online work :/\nexports.require = function(path) {\n    return nativeRequire(path);\n};\n\nexports.resolve = function(path) {\n    return nativeRequire.resolve(path);\n};\n\nexports.resolveFrom = function(from, target) {\n    return resolveFrom(from, target);\n};\n\nexports.deresolve = function(targetFilename, from) {\n    return deresolve(targetFilename, from, deresolveOptions);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/deresolve.js":"module.exports = require('deresolve');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loadTagFromFile.js":"var jsonFileReader = require('./json-file-reader');\nvar types = require('./types');\nvar cache = require('./cache');\nvar loaders = require('./loaders');\n\nvar ok = require('assert').ok;\n\nfunction loadTagFromFile(filePath) {\n    ok(filePath, '\"filePath\" is required');\n\n    var tag = cache.get(filePath);\n\n    // Only load a tag once by caching the loaded tags using the file\n    // system file path as the key\n    if (!tag) {\n        tag = new types.Tag(filePath);\n        cache.put(filePath, tag);\n\n        var tagProps = jsonFileReader.readFileSync(filePath);\n        loaders.loadTagFromProps(tag, tagProps);\n\n    }\n\n    return tag;\n}\n\nmodule.exports = loadTagFromFile;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/json-file-reader.js":"var fs = require('fs');\nvar stripJsonComments = require('strip-json-comments');\nvar fsReadOptions = { encoding: 'utf8' };\n\nexports.readFileSync = function (path) {\n    var json = fs.readFileSync(path, fsReadOptions);\n\n    try {\n        var taglibProps = JSON.parse(stripJsonComments(json));\n        return taglibProps;\n    } catch(e) {\n        throw new Error('Unable to parse JSON file at path \"' + path + '\". Error: ' + e);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loadTaglibFromProps.js":"'use strict';\n\nvar ok = require('assert').ok;\nvar types = require('./types');\nvar nodePath = require('path');\nvar scanTagsDir = require('./scanTagsDir');\nvar markoModules = require('../modules'); // NOTE: different implementation for browser\nvar propertyHandlers = require('property-handlers');\nvar types = require('./types');\nvar jsonFileReader = require('./json-file-reader');\nvar tryRequire = require('try-require');\nvar resolveFrom = tryRequire('resolve-from', require);\nvar DependencyChain = require('./DependencyChain');\nvar createError = require('raptor-util/createError');\nvar loaders = require('./loaders');\n\nfunction exists(path) {\n    try {\n        markoModules.resolve(path);\n        return true;\n    } catch(e) {\n        return false;\n    }\n}\n\n/**\n * We load a taglib definion using this class. Properties in the taglib\n * definition (which is just a JavaScript object with properties)\n * are mapped to handler methods in an instance of this type.\n *\n *\n * @param {Taglib} taglib The initially empty Taglib instance that we will populate\n * @param {String} path The file system path to the taglib that we are loading\n */\nclass TaglibLoader {\n    constructor(taglib, dependencyChain) {\n        ok(dependencyChain instanceof DependencyChain, '\"dependencyChain\" is not valid');\n\n        this.dependencyChain = dependencyChain;\n\n        this.taglib = taglib;\n        this.filePath = taglib.filePath;\n        this.dirname = taglib.dirname;\n    }\n\n    load(taglibProps) {\n\n        var taglib = this.taglib;\n\n        propertyHandlers(taglibProps, this, this.dependencyChain.toString());\n\n        if (!taglib.id) {\n            // Fixes #73\n            // See if there is a package.json in the same directory as the taglib file.\n            // If so, and if that package.json file has a \"name\" property then we will\n            // use the the name as the \"taglib ID\". The taglib ID is used to uniquely\n            // identity a taglib (ignoring version) and it is used to prevent the same\n            // taglib from being loaded multiple times.\n            //\n            // Using the file path as the taglib ID doesn't work so well since we might find\n            // the same taglib multiple times in the Node.js module search path with\n            // different paths.\n            var filePath = this.filePath;\n            var dirname = this.dirname;\n\n            var packageJsonPath = nodePath.join(dirname, 'package.json');\n\n\n            try {\n                var pkg = jsonFileReader.readFileSync(packageJsonPath);\n                taglib.id = pkg.name;\n            } catch(e) {}\n\n            if (!taglib.id) {\n                taglib.id = filePath;\n            }\n        }\n    }\n\n    _handleTag(tagName, value, dependencyChain) {\n        var tagProps;\n        var tagFilePath = this.filePath;\n\n        var tag;\n\n        if (typeof value === 'string') {\n            tagFilePath = nodePath.resolve(this.dirname, value);\n\n\n            if (!exists(tagFilePath)) {\n                throw new Error('Tag at path \"' + tagFilePath + '\" does not exist. (' + dependencyChain + ')');\n            }\n\n            tag = new types.Tag(tagFilePath);\n\n            tagProps = jsonFileReader.readFileSync(tagFilePath);\n            dependencyChain = dependencyChain.append(tagFilePath);\n        } else {\n            tag = new types.Tag(this.filePath);\n            tagProps = value;\n        }\n\n        loaders.loadTagFromProps(tag, tagProps, dependencyChain);\n\n        if (tag.name === undefined) {\n            tag.name = tagName;\n        }\n\n        this.taglib.addTag(tag);\n    }\n\n    // We register a wildcard handler to handle \"@my-attr\" and \"<my-tag>\"\n    // properties (shorthand syntax)\n    '*'(name, value) {\n        var taglib = this.taglib;\n        var filePath = this.filePath;\n\n        if (name.startsWith('<')) {\n            let tagName = name.slice(1, -1);\n            this._handleTag(tagName, value, this.dependencyChain.append(name));\n        } else if (name.startsWith('@')) {\n            var attrKey = name.substring(1);\n\n            var attr = loaders.loadAttributeFromProps(\n                attrKey,\n                value,\n                this.dependencyChain.append('@' + attrKey));\n\n            attr.filePath = filePath;\n            attr.key = attrKey;\n\n            taglib.addAttribute(attr);\n        } else {\n            return false;\n        }\n    }\n\n    attributes(value) {\n        // The value of the \"attributes\" property will be an object\n        // where each property maps to an attribute definition. Since these\n        // attributes are on the taglib they will be \"global\" attribute\n        // defintions.\n        //\n        // The property key will be the attribute name and the property value\n        // will be the attribute definition. Example:\n        // {\n        //     \"attributes\": {\n        //         \"foo\": \"string\",\n        //         \"bar\": \"expression\"\n        //     }\n        // }\n        var taglib = this.taglib;\n\n        Object.keys(value).forEach((attrName) => {\n            var attrDef = value[attrName];\n\n            var attr = loaders.loadAttributeFromProps(\n                attrName,\n                attrDef,\n                this.dependencyChain.append('@' + attrName));\n\n            attr.key = attrName;\n\n            taglib.addAttribute(attr);\n        });\n    }\n    tags(tags) {\n        // The value of the \"tags\" property will be an object\n        // where each property maps to an attribute definition. The property\n        // key will be the tag name and the property value\n        // will be the tag definition. Example:\n        // {\n        //     \"tags\": {\n        //         \"foo\": {\n        //             \"attributes\": { ... }\n        //         },\n        //         \"bar\": {\n        //             \"attributes\": { ... }\n        //         },\n        //     }\n        // }\n\n        for (var tagName in tags) {\n            if (tags.hasOwnProperty(tagName)) {\n                this._handleTag(tagName, tags[tagName], this.dependencyChain.append('tags.' + tagName));\n            }\n        }\n    }\n    tagsDir(dir) {\n        // The \"tags-dir\" property is used to supporting scanning\n        // of a directory to discover custom tags. Scanning a directory\n        // is a much simpler way for a developer to create custom tags.\n        // Only one tag is allowed per directory and the directory name\n        // corresponds to the tag name. We only search for directories\n        // one level deep.\n        var taglib = this.taglib;\n        var path = this.filePath;\n        var dirname = this.dirname;\n\n        taglib.tagsDir = dir;\n\n        if (dir != null) {\n            if (Array.isArray(dir)) {\n                for (var i = 0; i < dir.length; i++) {\n                    scanTagsDir(path, dirname, dir[i], taglib, this.dependencyChain.append(`tags-dir[${i}]`));\n                }\n            } else {\n                scanTagsDir(path, dirname, dir, taglib, this.dependencyChain.append(`tags-dir`));\n            }\n        }\n    }\n\n    taglibImports(imports) {\n        if (!resolveFrom) {\n            return;\n        }\n        // The \"taglib-imports\" property allows another taglib to be imported\n        // into this taglib so that the tags defined in the imported taglib\n        // will be part of this taglib.\n        //\n        // NOTE: If a taglib import refers to a package.json file then we read\n        //       the package.json file and automatically import *all* of the\n        //       taglibs from the installed modules found in the \"dependencies\"\n        //       section\n        var taglib = this.taglib;\n        var dirname = this.dirname;\n        var importPath;\n\n        if (imports && Array.isArray(imports)) {\n            for (var i=0; i<imports.length; i++) {\n                var curImport = imports[i];\n                if (typeof curImport === 'string') {\n                    var basename = nodePath.basename(curImport);\n                    if (basename === 'package.json') {\n                        var packagePath = markoModules.resolveFrom(dirname, curImport);\n                        var packageDir = nodePath.dirname(packagePath);\n                        var pkg = jsonFileReader.readFileSync(packagePath);\n                        var dependencies = pkg.dependencies;\n                        if (dependencies) {\n                            var dependencyNames = Object.keys(dependencies);\n                            for (var j=0; j<dependencyNames.length; j++) {\n                                var dependencyName = dependencyNames[j];\n\n                                importPath = resolveFrom(packageDir, dependencyName + '/marko.json');\n\n                                if (importPath) {\n                                    taglib.addImport(importPath);\n                                }\n                            }\n                        }\n                    } else {\n                        importPath = resolveFrom(dirname, curImport);\n                        if (importPath) {\n                            taglib.addImport(importPath);\n                        } else {\n                            throw new Error('Import not fount: ' + curImport + ' (from ' + dirname + ')');\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    textTransformer(value) {\n        // Marko allows a \"text-transformer\" to be registered. The provided\n        // text transformer will be called for any static text found in a template.\n        var taglib = this.taglib;\n        var dirname = this.dirname;\n\n        var transformer = new types.Transformer();\n\n        if (typeof value === 'string') {\n            value = {\n                path: value\n            };\n        }\n\n        propertyHandlers(value, {\n            path(value) {\n                var path = markoModules.resolveFrom(dirname, value);\n                transformer.path = path;\n            }\n\n        }, this.dependencyChain.append('textTransformer').toString());\n\n        ok(transformer.path, '\"path\" is required for transformer');\n\n        taglib.addTextTransformer(transformer);\n    }\n\n    /**\n     * Allows an ID to be explicitly assigned to a taglib.\n     * The taglib ID is used to prevent the same taglib  (even if different versions)\n     * from being loaded multiple times.\n     *\n     * NOTE: Introduced as part of fix for #73\n     *\n     * @param  {String} value The taglib ID\n     */\n    taglibId(value) {\n        var taglib = this.taglib;\n        taglib.id = value;\n    }\n\n    transformer(value) {\n        // Marko allows a \"text-transformer\" to be registered. The provided\n        // text transformer will be called for any static text found in a template.\n        var taglib = this.taglib;\n        var dirname = this.dirname;\n\n        var transformer = new types.Transformer();\n\n        if (typeof value === 'string') {\n            value = {\n                path: value\n            };\n        }\n\n        propertyHandlers(value, {\n            path(value) {\n                var path = markoModules.resolveFrom(dirname, value);\n                transformer.path = path;\n            }\n\n        }, this.dependencyChain.append('transformer').toString());\n\n        ok(transformer.path, '\"path\" is required for transformer');\n\n        taglib.addTransformer(transformer);\n    }\n\n    attributeGroups(value) {\n        let taglib = this.taglib;\n        let attributeGroups = taglib.attributeGroups || (taglib.attributeGroups = {});\n        let dependencyChain = this.dependencyChain.append('attribute-groups');\n\n        Object.keys(value).forEach((attrGroupName) => {\n            let attrGroup = attributeGroups[attrGroupName] = {};\n            let attrGroupDependencyChain = dependencyChain.append(attrGroupName);\n\n            let rawAttrGroup = value[attrGroupName];\n\n            Object.keys(rawAttrGroup).forEach((attrName) => {\n                var rawAttrDef = rawAttrGroup[attrName];\n\n                let attr = loaders.loadAttributeFromProps(\n                    attrName,\n                    rawAttrDef,\n                    attrGroupDependencyChain.append('@' + attrName));\n\n                attrGroup[attrName] = attr;\n            });\n        });\n    }\n}\n\n\nfunction loadTaglibFromProps(taglib, taglibProps, dependencyChain) {\n    ok(taglib, '\"taglib\" is required');\n    ok(taglibProps, '\"taglibProps\" is required');\n    ok(taglib.filePath, '\"taglib.filePath\" is required');\n\n    if (!dependencyChain) {\n        dependencyChain = new DependencyChain([taglib.filePath]);\n    }\n\n    var taglibLoader = new TaglibLoader(taglib, dependencyChain);\n\n    try {\n        taglibLoader.load(taglibProps);\n    } catch(err) {\n        throw createError('Unable to load taglib (' + dependencyChain + '): ' + err, err);\n    }\n\n    return taglib;\n}\n\nmodule.exports = loadTaglibFromProps;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/scanTagsDir.js":"'use strict';\n\nconst nodePath = require('path');\nconst fs = require('fs');\nconst stripJsonComments = require('strip-json-comments');\nconst tagDefFromCode = require('./tag-def-from-code');\nconst loaders = require('./loaders');\nconst fsReadOptions = { encoding: 'utf8' };\nconst extend = require('raptor-util/extend');\nconst types = require('./types');\n\nconst tagFileTypes = [\n    'template',\n    'renderer',\n    'transformer',\n    'code-generator',\n    'node-factory',\n];\n\nconst searchFiles = [\n    { name:'index.marko', type:'template' },\n    { name:'renderer', type:'renderer' },\n    { name:'index', type:'renderer' },\n    { name:'template.marko', type:'template' },\n    { name:'template.html', type:'template' },\n    { name:'code-generator', type:'code-generator' },\n    { name:'node-factory', type:'node-factory' },\n    { name:'transformer', type:'transformer' },\n];\n\nfunction createDefaultTagDef() {\n    return {\n        attributes: {\n            '*': {\n                type: 'string',\n                targetProperty: null,\n                preserveName: false\n            }\n        }\n    };\n}\n\nfunction getFileMap(dirname) {\n    let fileMap = {};\n    let files = fs.readdirSync(dirname);\n\n    files.forEach(file => {\n        let extName = nodePath.extname(file);\n        let baseName = file.slice(0, -1*extName.length);\n        let fullPath = nodePath.join(dirname, file);\n        fileMap[baseName] = fileMap[baseName] || {};\n        fileMap[baseName][extName] = fullPath;\n        fileMap[file] = fileMap[file] || {};\n        fileMap[file].__path = fullPath;\n    });\n\n    return fileMap;\n}\n\nfunction getPath(filename, fileMap) {\n    let file = fileMap[filename];\n\n    if(!file) return;\n    if(file.__path) return file.__path;\n    if(file.js) return file['.js'];\n\n    return file[Object.keys(file)[0]];\n}\n\nfunction findAndSetFile(tagDef, tagDirname) {\n    if(!fs.statSync(tagDirname).isDirectory()) {\n        return;\n    }\n\n    let fileMap = getFileMap(tagDirname);\n\n    for(let i = 0; i < searchFiles.length; i++) {\n        let name = searchFiles[i].name;\n        let type = searchFiles[i].type;\n        let path = getPath(name, fileMap);\n\n        if(path) {\n            tagDef[type] = path;\n            return true;\n        }\n    }\n}\n\nfunction hasFile(tagDef) {\n    for(let i = 0; i < tagFileTypes.length; i++) {\n        if(tagDef[tagFileTypes[i]]) return true;\n    }\n    return false;\n}\n\n/**\n * @param {String} tagsConfigPath path to tag definition file\n * @param {String} tagsConfigDirname path to directory of tags config file (should be path.dirname(tagsConfigPath))\n * @param {String|Object} dir the path to directory to scan\n * @param {String} taglib the taglib that is being loaded\n */\nmodule.exports = function scanTagsDir(tagsConfigPath, tagsConfigDirname, dir, taglib, dependencyChain) {\n    let prefix;\n\n    if (typeof dir === 'object') {\n        prefix = dir.prefix;\n        dir = dir.path;\n    }\n\n    if (prefix == null) {\n        // no prefix by default\n        prefix = '';\n    }\n\n    dir = nodePath.resolve(tagsConfigDirname, dir);\n    let children = fs.readdirSync(dir);\n\n    let rendererJSFile;\n\n    for (let i=0, len=children.length; i<len; i++) {\n        rendererJSFile = null;\n        let childFilename = children[i];\n        if (childFilename === 'node_modules') {\n            continue;\n        }\n\n        let tagName;\n        let tagDef = null;\n        let tagDirname;\n        let tagJsonPath;\n\n        let ext = nodePath.extname(childFilename);\n        if (ext === '.marko') {\n            tagName = childFilename.slice(0, 0 - ext.length);\n            tagDirname = dir;\n            tagDef = createDefaultTagDef();\n            tagDef.template = nodePath.join(dir, childFilename);\n        } else {\n            tagName = prefix + childFilename;\n\n            tagDirname = nodePath.join(dir, childFilename);\n            tagJsonPath = nodePath.join(tagDirname, 'marko-tag.json');\n\n            let hasTagJson = false;\n            if (fs.existsSync(tagJsonPath)) {\n                hasTagJson = true;\n                // marko-tag.json exists in the directory, use that as the tag definition\n                try {\n                    tagDef = JSON.parse(stripJsonComments(fs.readFileSync(tagJsonPath, fsReadOptions)));\n                } catch(e) {\n                    throw new Error('Unable to parse JSON file at path \"' + tagJsonPath + '\". Error: ' + e);\n                }\n            } else {\n                tagJsonPath = null;\n                tagDef = createDefaultTagDef();\n            }\n\n            if (!hasFile(tagDef)) {\n                let fileWasSet = findAndSetFile(tagDef, tagDirname);\n                if(!fileWasSet) {\n                    if (hasTagJson) {\n                        throw new Error('Invalid tag file: ' + tagJsonPath + '. Neither a renderer or a template was found for tag. ' + JSON.stringify(tagDef, null, 2));\n                    } else {\n                        // Skip this directory... there doesn't appear to be anything in it\n                        continue;\n                    }\n                }\n            }\n\n            if (!hasTagJson && (tagDef.renderer || tagDef.template)) {\n                let templateCode = fs.readFileSync(tagDef.renderer || tagDef.template, fsReadOptions);\n                let extractedTagDef = tagDefFromCode.extractTagDef(templateCode);\n                if (extractedTagDef) {\n                    extend(tagDef, extractedTagDef);\n                }\n            }\n        }\n\n        let tagDependencyChain;\n\n        if (tagJsonPath) {\n            tagDependencyChain = dependencyChain.append(tagJsonPath);\n        } else {\n            tagDependencyChain = dependencyChain.append(tagDirname);\n        }\n\n        let tag = new types.Tag(tagJsonPath || tagDirname);\n        loaders.loadTagFromProps(tag, tagDef, tagDependencyChain);\n        tag.name = tag.name || tagName;\n        taglib.addTag(tag);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/tag-def-from-code.js":"// Rather than using a full-blown JavaScript parser, we are going to use a few regular expressions\n// to tokenize the code and find what we are interested in\nvar tagStartRegExp = /(^\\s*(?:(?:exports.(?:tag|TAG))|(?:TAG))\\s*=\\s*)\\{/m;\n\n// Tokens: \"<string>\", '<string>', /*<some comment*/, //<single line comment>, {, }, ;\nvar tokensRegExp = /\"(?:[^\"]|\\\\\")*\"|'(?:[^'])|(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(\\/\\/.*)|[\\{\\};]/g;\n\nfunction extractTagDef(code) {\n\n    var startMatches = tagStartRegExp.exec(code);\n\n    var tagDefStart;\n    var tagDefEnd;\n\n    if (startMatches) {\n        tagDefStart = startMatches.index + startMatches[1].length;\n        var nextTokenMatches;\n        tokensRegExp.lastIndex = tagDefStart;\n        var depth = 0;\n\n        while ((nextTokenMatches = tokensRegExp.exec(code))) {\n            if (nextTokenMatches[0] === '{') {\n                depth++;\n                continue;\n            } else if (nextTokenMatches[0] === '}') {\n                if (--depth === 0) {\n                    tagDefEnd = tokensRegExp.lastIndex;\n                    break;\n                }\n            }\n            else if (nextTokenMatches[0] === ';') {\n                tagDefEnd = nextTokenMatches.index;\n                break;\n            }\n        }\n\n        if (tagDefStart != null && tagDefEnd != null) {\n            var jsTagDef = code.substring(tagDefStart, tagDefEnd);\n            var tagDefObject;\n\n            try {\n                // Try parsing it as JSON\n                tagDefObject = JSON.parse(jsTagDef);\n            } catch(e) {\n                // Try parsing it as JavaScript\n                try {\n                    tagDefObject = eval('(' + jsTagDef + ')');\n                } catch(e) {\n                    tagDefObject = {};\n                }\n            }\n            return tagDefObject;\n        }\n    } else {\n        return null;\n    }\n}\n\nexports.extractTagDef = extractTagDef;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/DependencyChain.js":"'use strict';\n\nclass DependencyChain {\n    constructor(array) {\n        this.array = array || [];\n    }\n\n    append(str) {\n        return new DependencyChain(this.array.concat(str));\n    }\n\n    toString() {\n        return '[' + this.array.join(' → ') + ']';\n    }\n}\n\nmodule.exports = DependencyChain;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loadTaglibFromFile.js":"var jsonFileReader = require('./json-file-reader');\nvar types = require('./types');\nvar cache = require('./cache');\nvar loaders = require('./loaders');\n\nvar ok = require('assert').ok;\n\nfunction loadFromFile(filePath) {\n    ok(filePath, '\"filePath\" is required');\n\n    var taglib = cache.get(filePath);\n\n    // Only load a taglib once by caching the loaded taglibs using the file\n    // system file path as the key\n    if (!taglib) {\n        taglib = new types.Taglib(filePath);\n        cache.put(filePath, taglib);\n\n        var taglibProps = jsonFileReader.readFileSync(filePath);\n        loaders.loadTaglibFromProps(taglib, taglibProps);\n    }\n\n    return taglib;\n}\n\nmodule.exports = loadFromFile;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/loadAttributes.js":"var ok = require('assert').ok;\nvar forEachEntry = require('raptor-util/forEachEntry');\nvar loaders = require('./loaders');\n\nmodule.exports = function loadAttributes(value, parent, dependencyChain) {\n    ok(parent);\n    ok(dependencyChain);\n\n    forEachEntry(value, (attrName, attrProps) => {\n        var attr = loaders.loadAttributeFromProps(\n            attrName,\n            attrProps,\n            dependencyChain.append('@' + attrName));\n\n        parent.addAttribute(attr);\n    });\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/Tag.js":"'use strict';\nvar forEachEntry = require('raptor-util/forEachEntry');\nvar ok = require('assert').ok;\nvar CustomTag;\nvar path = require('path');\nvar markoModules = require('../modules');\n\nfunction createCustomTag(el, tagDef) {\n    CustomTag = CustomTag || require('../ast/CustomTag');\n    return new CustomTag(el, tagDef);\n}\n\nfunction createCustomTagNodeFactory(tagDef) {\n    return function nodeFactory(el) {\n        return createCustomTag(el, tagDef);\n    };\n}\n\nclass Tag{\n    constructor(filePath) {\n        this.filePath = filePath;\n        if (filePath) {\n            this.dir = path.dirname(filePath);\n        }\n\n        this.attributes = {};\n        this.transformers = {};\n        this.patternAttributes = [];\n\n        // NOTE: We don't set this properties since\n        //       it breaks merging of tags when the same\n        //       tag is declared at multiple levels\n\n        // this.taglibId = null;\n        // this.taglibPath = null;\n        // this.name = undefined;\n        // this.renderer = null;\n        // this.codeGeneratorModulePath = null;\n        // this.nodeFactoryPath = null;\n        // this.template = null;\n        // this.nestedVariables = null;\n        // this.importedVariables = null;\n        // this.bodyFunction = null;\n        // this.nestedTags = null;\n        // this.isRepeated = null;\n        // this.isNestedTag = false;\n        // this.parentTagName = null;\n        // this.openTagOnly = null;\n        // this.body = null;\n        // this.type = null; // Only applicable for nested tags\n        // this._nodeFactory = undefined;\n    }\n\n    forEachVariable(callback, thisObj) {\n        if (!this.nestedVariables) {\n            return;\n        }\n\n        this.nestedVariables.vars.forEach(callback, thisObj);\n    }\n\n    forEachImportedVariable(callback, thisObj) {\n        if (!this.importedVariables) {\n            return;\n        }\n\n        forEachEntry(this.importedVariables, function (key, importedVariable) {\n            callback.call(thisObj, importedVariable);\n        });\n    }\n\n    forEachTransformer(callback, thisObj) {\n        forEachEntry(this.transformers, function (key, transformer) {\n            callback.call(thisObj, transformer);\n        });\n    }\n    hasTransformers() {\n        /*jshint unused:false */\n        for (var k in this.transformers) {\n            if (this.transformers.hasOwnProperty(k)) {\n                return true;\n            }\n\n        }\n        return false;\n    }\n    addAttribute(attr) {\n        attr.filePath = this.filePath;\n\n        if (attr.pattern) {\n            this.patternAttributes.push(attr);\n        } else {\n            if (attr.name === '*') {\n                attr.dynamicAttribute = true;\n\n                if (attr.targetProperty === null || attr.targetProperty === '') {\n                    attr.targetProperty = null;\n\n                }\n                else if (!attr.targetProperty) {\n                    attr.targetProperty = '*';\n                }\n            }\n\n            this.attributes[attr.name] = attr;\n        }\n    }\n    toString() {\n        return '[Tag: <' + this.name + '@' + this.taglibId + '>]';\n    }\n    forEachAttribute(callback, thisObj) {\n        for (var attrName in this.attributes) {\n            if (this.attributes.hasOwnProperty(attrName)) {\n                callback.call(thisObj, this.attributes[attrName]);\n            }\n        }\n    }\n    getAttribute(attrName) {\n        var attributes = this.attributes;\n\n        // try by exact match first\n        var attribute = attributes[attrName] || attributes['*'];\n\n        if (attribute === undefined && this.patternAttributes) {\n            // try searching by pattern\n            for (var i = 0, len = this.patternAttributes.length; i < len; i++) {\n                var patternAttribute = this.patternAttributes[i];\n                if (patternAttribute.pattern.test(attrName)) {\n                    attribute = patternAttribute;\n                    break;\n                }\n            }\n        }\n\n        return attribute;\n    }\n\n    hasAttribute(attrName) {\n        return this.attributes.hasOwnProperty(attrName);\n    }\n\n    addNestedVariable(nestedVariable) {\n        if (!this.nestedVariables) {\n            this.nestedVariables = {\n                __noMerge: true,\n                vars: []\n            };\n        }\n\n        this.nestedVariables.vars.push(nestedVariable);\n    }\n    addImportedVariable(importedVariable) {\n        if (!this.importedVariables) {\n            this.importedVariables = {};\n        }\n        var key = importedVariable.targetProperty;\n        this.importedVariables[key] = importedVariable;\n    }\n    addTransformer(transformer) {\n        var key = transformer.path;\n        transformer.taglibId = this.taglibId;\n        this.transformers[key] = transformer;\n    }\n    setBodyFunction(name, params) {\n        this.bodyFunction = {\n            __noMerge: true,\n            name: name,\n            params: params\n        };\n    }\n    setBodyProperty(propertyName) {\n        this.bodyProperty = propertyName;\n    }\n    addNestedTag(nestedTag) {\n        ok(nestedTag.name, '\"nestedTag.name\" is required');\n\n        if (!this.nestedTags) {\n            this.nestedTags = {};\n        }\n\n        nestedTag.isNestedTag = true;\n\n        if (!nestedTag.targetProperty) {\n            nestedTag.targetProperty = nestedTag.name;\n        }\n\n        this.nestedTags[nestedTag.name] = nestedTag;\n    }\n    forEachNestedTag(callback, thisObj) {\n        if (!this.nestedTags) {\n            return;\n        }\n\n        forEachEntry(this.nestedTags, function (key, nestedTag) {\n            callback.call(thisObj, nestedTag);\n        });\n    }\n    hasNestedTags() {\n        return this.nestedTags != null;\n    }\n    getNodeFactory() {\n        var nodeFactory = this._nodeFactory;\n        if (nodeFactory !== undefined) {\n            return nodeFactory;\n        }\n\n        let codeGeneratorModulePath = this.codeGeneratorModulePath;\n\n        if (this.codeGeneratorModulePath) {\n            var loadedCodeGenerator = markoModules.require(this.codeGeneratorModulePath);\n            nodeFactory = function(elNode) {\n                elNode.setType(codeGeneratorModulePath);\n                elNode.setCodeGenerator(loadedCodeGenerator);\n                return elNode;\n            };\n        } else if (this.nodeFactoryPath) {\n            nodeFactory = markoModules.require(this.nodeFactoryPath);\n            if (typeof nodeFactory !== 'function') {\n                throw new Error('Invalid node factory exported by module at path \"' + this.nodeFactoryPath + '\"');\n            }\n        } else if (this.renderer || this.template || this.isNestedTag) {\n            nodeFactory = createCustomTagNodeFactory(this);\n        } else {\n            return null;\n        }\n\n        return (this._nodeFactory = nodeFactory);\n    }\n\n    toJSON() {\n        return this;\n    }\n\n    setTaglib(taglib) {\n        this.taglibId = taglib ? taglib.id : null;\n        this.taglibPath = taglib ? taglib.path : null;\n    }\n}\n\nmodule.exports = Tag;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/Attribute.js":"'use strict';\n\nclass Attribute {\n    constructor(name) {\n        this.name = name;\n        this.type = null;\n        this.required = false;\n        this.type = null;\n        this.allowExpressions = true;\n        this.setFlag = null;\n        this.pattern = null;\n    }\n}\n\nmodule.exports = Attribute;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/Property.js":"'use strict';\n\nclass Property {\n    constructor() {\n        this.name = null;\n        this.type = 'string';\n        this.value = undefined;\n    }\n}\n\nmodule.exports = Property;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/NestedVariable.js":"'use strict';\n\nclass NestedVariable {\n    constructor() {\n        this.name = null;\n    }\n}\n\nmodule.exports = NestedVariable;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/ImportedVariable.js":"'use strict';\n\nclass ImportedVariable {\n    constructor() {\n        this.targetProperty = null;\n        this.expression = null;\n    }\n}\n\nmodule.exports = ImportedVariable;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-loader/Transformer.js":"'use strict';\nvar nextTransformerId = 0;\nvar markoModules = require('../modules');\n\nclass Transformer {\n    constructor() {\n        this.id = nextTransformerId++;\n        this.name = null;\n        this.tag = null;\n        this.path = null;\n        this.priority = null;\n        this._func = null;\n        this.properties = {};\n    }\n\n    getFunc() {\n        if (!this.path) {\n            throw new Error('Transformer path not defined for tag transformer (tag=' + this.tag + ')');\n        }\n\n        if (!this._func) {\n            var transformer = markoModules.require(this.path);\n\n            if (typeof transformer === 'function') {\n                if (transformer.prototype.process) {\n                    var Clazz = transformer;\n                    var instance = new Clazz();\n                    instance.id = this.id;\n                    this._func = instance.process.bind(instance);\n                } else {\n                    this._func = transformer;\n                }\n            } else {\n                this._func = transformer.process || transformer.transform;\n            }\n        }\n        return this._func;\n    }\n    toString() {\n        return '[Taglib.Transformer: ' + this.path + ']';\n    }\n}\n\nmodule.exports = Transformer;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-finder/index.js":"'use strict';\nvar taglibLoader = require('../taglib-loader');\nvar nodePath = require('path');\nvar lassoPackageRoot = require('lasso-package-root');\nvar resolveFrom = require('resolve-from');\nvar scanTagsDir = require('../taglib-loader/scanTagsDir');\nvar DependencyChain = require('../taglib-loader/DependencyChain');\nvar lassoCachingFS = require('lasso-caching-fs');\n\nvar findCache = {};\nvar excludedDirs = {};\nvar excludedPackages = {};\nvar taglibsForNodeModulesDirCache = {};\n\n/**\n * Reset all internal state to the default state. This\n * was added for testing purposes.\n */\nfunction reset() {\n    lassoCachingFS.clearCaches();\n    findCache = {};\n    excludedDirs = {};\n    excludedPackages = {};\n    taglibsForNodeModulesDirCache = {};\n}\n\nfunction existsCached(path) {\n    return lassoCachingFS.existsSync(path);\n}\n\nfunction getModuleRootPackage(dirname) {\n    try {\n        return lassoPackageRoot.getRootPackage(dirname);\n    } catch(e) {\n        return undefined;\n    }\n}\n\nfunction getAllDependencyNames(pkg) {\n    var map = {};\n\n    if (pkg.dependencies) {\n        Object.keys(pkg.dependencies).forEach((name) => {\n            map[name] = true;\n        });\n    }\n\n    if (pkg.peerDependencies) {\n        Object.keys(pkg.peerDependencies).forEach((name) => {\n            map[name] = true;\n        });\n    }\n\n    if (pkg.devDependencies) {\n        Object.keys(pkg.devDependencies).forEach((name) => {\n            map[name] = true;\n        });\n    }\n\n    return Object.keys(map);\n}\n\nfunction find(dirname, registeredTaglibs) {\n    var found = findCache[dirname];\n    if (found) {\n        return found;\n    }\n\n    found = [];\n\n    var added = {};\n\n    var helper = {\n        alreadyAdded: function(taglibPath) {\n            return added.hasOwnProperty(taglibPath);\n        },\n        addTaglib: function(taglib) {\n            if (added[taglib.path]) {\n                return;\n            }\n\n            added[taglib.path] = true;\n            found.push(taglib);\n        },\n        foundTaglibPackages: {}\n    };\n\n    var rootDirname = process.cwd(); // Don't search up past this directory\n    var rootPkg = getModuleRootPackage(dirname);\n    if (rootPkg) {\n        rootDirname = rootPkg.__dirname; // Use the package's root directory as the top-level directory\n    }\n\n\n    // First walk up the directory tree looking for marko.json files or components/ directories\n    let curDirname = dirname;\n    while(true) {\n        if(!excludedDirs[curDirname]) {\n            let taglibPath = nodePath.join(curDirname, 'marko.json');\n            let taglib;\n\n            if (existsCached(taglibPath)) {\n                taglib = taglibLoader.loadTaglibFromFile(taglibPath);\n                helper.addTaglib(taglib);\n            }\n\n            if (!taglib || taglib.tagsDir === undefined) {\n                let componentsPath = nodePath.join(curDirname, 'components');\n\n                if (existsCached(componentsPath) && !excludedDirs[componentsPath] && !helper.alreadyAdded(componentsPath)) {\n                    let taglib = taglibLoader.createTaglib(componentsPath);\n                    scanTagsDir(componentsPath, nodePath.dirname(componentsPath), './components', taglib, new DependencyChain([componentsPath]));\n                    helper.addTaglib(taglib);\n                }\n            }\n\n        }\n\n        if (curDirname === rootDirname) {\n            break;\n        }\n\n        let parentDirname = nodePath.dirname(curDirname);\n        if (!parentDirname || parentDirname === curDirname) {\n            break;\n        }\n        curDirname = parentDirname;\n    }\n\n    if (rootPkg) {\n        // Now look for `marko.json` from installed packages\n        getAllDependencyNames(rootPkg).forEach((name) => {\n            if (!excludedPackages[name]) {\n                let taglibPath = resolveFrom(rootPkg.__dirname, name + '/marko.json');\n                if (taglibPath) {\n                    var taglib = taglibLoader.loadTaglibFromFile(taglibPath);\n                    helper.addTaglib(taglib);\n                }\n            }\n        });\n    }\n\n    found = found.concat(registeredTaglibs);\n\n    findCache[dirname] = found;\n\n    return found;\n}\n\nfunction clearCache() {\n    lassoCachingFS.clearCaches();\n    findCache = {};\n    taglibsForNodeModulesDirCache = {};\n}\n\nfunction excludeDir(dir) {\n    excludedDirs[dir] = true;\n}\n\nfunction excludePackage(name) {\n    excludedPackages[name] = true;\n}\n\nexports.reset = reset;\nexports.find = find;\nexports.clearCache = clearCache;\nexports.excludeDir = excludeDir;\nexports.excludePackage = excludePackage;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/taglib-lookup/TaglibLookup.js":"'use strict';\n\nvar ok = require('assert').ok;\nvar taglibTypes = require('../taglib-loader/types');\nvar Text = require('../ast/Text');\nvar extend = require('raptor-util/extend');\n\nfunction transformerComparator(a, b) {\n    a = a.priority;\n    b = b.priority;\n\n    if (a == null) {\n        a = Number.MAX_VALUE;\n    }\n\n    if (b == null) {\n        b = Number.MAX_VALUE;\n    }\n\n    return a - b;\n}\n\nfunction TAG_COMPARATOR(a, b) {\n    a = a.name;\n    b = b.name;\n    return a.localeCompare(b);\n}\n\nfunction merge(target, source) {\n    for (var k in source) {\n        if (source.hasOwnProperty(k)) {\n            if (target[k] && typeof target[k] === 'object' &&\n                source[k] && typeof source[k] === 'object') {\n\n                if (source.__noMerge) {\n                    // Don't merge objects that are explicitly marked as \"do not merge\"\n                    continue;\n                }\n\n                if (Array.isArray(target[k]) || Array.isArray(source[k])) {\n\n                    var targetArray = target[k];\n                    var sourceArray = source[k];\n\n\n                    if (!Array.isArray(targetArray)) {\n                        targetArray = [targetArray];\n                    }\n\n                    if (!Array.isArray(sourceArray)) {\n                        sourceArray = [sourceArray];\n                    }\n\n                    target[k] = [].concat(targetArray).concat(sourceArray);\n                } else {\n                    var Ctor = target[k].constructor;\n                    var newTarget = new Ctor();\n                    merge(newTarget, target[k]);\n                    merge(newTarget, source[k]);\n                    target[k] = newTarget;\n                }\n\n            } else {\n                target[k] = source[k];\n            }\n        }\n    }\n\n    return target;\n}\n\n/**\n * A taglib lookup merges in multiple taglibs so there is a single and fast lookup\n * for custom tags and custom attributes.\n */\nclass TaglibLookup {\n    constructor() {\n        this.merged = {\n            attributeGroups: {}\n        };\n        this.taglibsById = {};\n        this._inputFiles = null;\n\n        this._sortedTags = undefined;\n    }\n\n    hasTaglib(taglib) {\n        return this.taglibsById.hasOwnProperty(taglib.id);\n    }\n\n    _mergeNestedTags(taglib) {\n        var Tag = taglibTypes.Tag;\n        // Loop over all of the nested tags and register a new custom tag\n        // with the fully qualified name\n\n        var merged = this.merged;\n\n        function handleNestedTags(tag, parentTagName) {\n            tag.forEachNestedTag(function(nestedTag) {\n                var fullyQualifiedName = parentTagName + ':' + nestedTag.name;\n                // Create a clone of the nested tag since we need to add some new\n                // properties\n                var clonedNestedTag = new Tag();\n                extend(clonedNestedTag, nestedTag);\n                // Record the fully qualified name of the parent tag that this\n                // custom tag is associated with.\n                clonedNestedTag.parentTagName = parentTagName;\n                clonedNestedTag.name = fullyQualifiedName;\n                merged.tags[fullyQualifiedName] = clonedNestedTag;\n                handleNestedTags(clonedNestedTag, fullyQualifiedName);\n            });\n        }\n\n        taglib.forEachTag(function(tag) {\n            handleNestedTags(tag, tag.name);\n        });\n    }\n\n    addTaglib(taglib) {\n        ok(taglib, '\"taglib\" is required');\n        ok(taglib.id, '\"taglib.id\" expected');\n\n        if (this.taglibsById.hasOwnProperty(taglib.id)) {\n            return;\n        }\n\n        // console.log(\"TAGLIB:\", taglib);\n\n        this._sortedTags = undefined;\n\n        this.taglibsById[taglib.id] = taglib;\n\n        merge(this.merged, {\n            tags: taglib.tags,\n            transformers: taglib.transformers,\n            textTransformers: taglib.textTransformers,\n            attributes: taglib.attributes,\n            patternAttributes: taglib.patternAttributes,\n            attributeGroups: taglib.attributeGroups || {}\n        });\n\n        this._mergeNestedTags(taglib);\n    }\n\n    getTagsSorted() {\n        var sortedTags = this._sortedTags;\n\n        if (sortedTags === undefined) {\n            sortedTags = this._sortedTags = [];\n            this.forEachTag((tag) => {\n                sortedTags.push(tag);\n            });\n            sortedTags.sort(TAG_COMPARATOR);\n        }\n\n        return sortedTags;\n    }\n\n    forEachTag(callback) {\n        var tags = this.merged.tags;\n        if (tags) {\n            for (var tagName in tags) {\n                if (tags.hasOwnProperty(tagName)) {\n                    var tag = tags[tagName];\n                    var result = callback(tag);\n                    if (result === false) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    forEachAttribute(tagName, callback) {\n        var tags = this.merged.tags;\n        if (!tags) {\n            return;\n        }\n\n        var globalAttributes = this.merged.attributes;\n        var taglibAttributeGroups = this.merged.attributeGroups;\n\n\n\n        function findAttributesForTagName(tagName) {\n            var tag = tags[tagName];\n            if (!tag) {\n                return;\n            }\n\n            function handleAttr(attrDef) {\n                if (attrDef.ref) {\n                    attrDef = globalAttributes[attrDef.ref];\n                }\n                callback(attrDef, tag);\n            }\n\n            var attributes = tag.attributes;\n            if (!attributes) {\n                return;\n            }\n\n            for (var attrName in attributes) {\n                if (attributes.hasOwnProperty(attrName)) {\n                    handleAttr(attributes[attrName], tag);\n                }\n            }\n\n            if (tag.attributeGroups) {\n                for (let i=0; i<tag.attributeGroups.length; i++) {\n                    let attributeGroupName = tag.attributeGroups[i];\n                    let attributeGroup = taglibAttributeGroups[attributeGroupName];\n                    if (attributeGroup) {\n                        for (let attrName in attributeGroup) {\n                            handleAttr(attributeGroup[attrName]);\n                        }\n                    }\n                }\n            }\n\n            if (tag.patternAttributes) {\n                tag.patternAttributes.forEach(handleAttr);\n            }\n        }\n\n        findAttributesForTagName(tagName); // Look for an exact match at the tag level\n        findAttributesForTagName('*'); // Including attributes that apply to all tags\n    }\n\n    getTag(element) {\n        if (typeof element === 'string') {\n            element = {\n                tagName: element\n            };\n        }\n        var tags = this.merged.tags;\n        if (!tags) {\n            return;\n        }\n\n        var tagName = element.tagName;\n        return tags[tagName];\n    }\n\n    getAttribute(element, attr) {\n        if (typeof element === 'string') {\n            element = {\n                tagName: element\n            };\n        }\n\n        if (typeof attr === 'string') {\n            attr = {\n                name: attr\n            };\n        }\n\n        var tags = this.merged.tags;\n        if (!tags) {\n            return;\n        }\n\n        var taglibAttributeGroups = this.merged.attributeGroups;\n\n        var tagName = element.tagName;\n        var attrName = attr.name;\n\n        function findAttributeForTag(tag, attributes, attrName) {\n            // try by exact match first\n            var attribute = attributes[attrName];\n            if (attribute === undefined) {\n                if (tag.attributeGroups) {\n                    for (let i=0; i<tag.attributeGroups.length; i++) {\n                        let attributeGroupName = tag.attributeGroups[i];\n                        let attributeGroup = taglibAttributeGroups[attributeGroupName];\n                        if (attributeGroup) {\n                            attribute = attributeGroup[attrName];\n                            if (attribute !== undefined) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (attribute === undefined && attrName !== '*') {\n                if (tag.patternAttributes) {\n                    // try searching by pattern\n                    for (var i = 0, len = tag.patternAttributes.length; i < len; i++) {\n                        var patternAttribute = tag.patternAttributes[i];\n                        if (patternAttribute.pattern.test(attrName)) {\n                            attribute = patternAttribute;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return attribute;\n        }\n\n        var globalAttributes = this.merged.attributes;\n\n        function tryAttribute(tagName, attrName) {\n            var tag = tags[tagName];\n            if (!tag) {\n                return undefined;\n            }\n\n            return findAttributeForTag(tag, tag.attributes, attrName);\n        }\n\n        var attrDef = tryAttribute(tagName, attrName) || // Look for an exact match at the tag level\n            tryAttribute('*', attrName) || // If not there, see if there is a exact match on the attribute name for attributes that apply to all tags\n            tryAttribute(tagName, '*'); // Otherwise, see if there is a splat attribute for the tag\n\n        if (attrDef && attrDef.ref) {\n            attrDef = globalAttributes[attrDef.ref];\n        }\n\n        return attrDef;\n    }\n\n    forEachTemplateTransformer(callback, thisObj) {\n        var transformers = this.merged.transformers;\n        if (transformers && transformers.length) {\n            transformers.forEach(callback, thisObj);\n        }\n    }\n\n    forEachNodeTransformer(node, callback, thisObj) {\n        /*\n         * Based on the type of node we have to choose how to transform it\n         */\n        if (node.tagName || node.tagNameExpression) {\n            this.forEachTagTransformer(node, callback, thisObj);\n        } else if (node instanceof Text) {\n            this.forEachTextTransformer(callback, thisObj);\n        }\n    }\n\n    forEachTagTransformer(element, callback, thisObj) {\n        if (typeof element === 'string') {\n            element = {\n                tagName: element\n            };\n        }\n\n        var tagName = element.tagName;\n        /*\n         * If the node is an element node then we need to find all matching\n         * transformers based on the URI and the local name of the element.\n         */\n\n        var transformers = [];\n\n        function addTransformer(transformer) {\n            if (!transformer || !transformer.getFunc) {\n                throw new Error('Invalid transformer');\n            }\n\n            transformers.push(transformer);\n        }\n\n        /*\n         * Handle all of the transformers for all possible matching transformers.\n         *\n         * Start with the least specific and end with the most specific.\n         */\n\n        if (this.merged.tags) {\n            if (tagName) {\n                if (this.merged.tags[tagName]) {\n                    this.merged.tags[tagName].forEachTransformer(addTransformer);\n                }\n            }\n\n            if (this.merged.tags['*']) {\n                this.merged.tags['*'].forEachTransformer(addTransformer);\n            }\n        }\n\n        transformers.sort(transformerComparator);\n\n        transformers.forEach(callback, thisObj);\n    }\n\n    forEachTextTransformer(callback, thisObj) {\n        if (this.merged.textTransformers) {\n            this.merged.textTransformers.sort(transformerComparator);\n            this.merged.textTransformers.forEach(callback, thisObj);\n        }\n    }\n\n    getInputFiles() {\n        if (!this._inputFiles) {\n            var inputFilesSet = {};\n\n            for (var taglibId in this.taglibsById) {\n                if (this.taglibsById.hasOwnProperty(taglibId)) {\n\n                    var taglibInputFiles = this.taglibsById[taglibId].getInputFiles();\n                    var len = taglibInputFiles.length;\n                    if (len) {\n                        for (var i=0; i<len; i++) {\n                            inputFilesSet[taglibInputFiles[i]] = true;\n                        }\n                    }\n                }\n            }\n\n            this._inputFiles = Object.keys(inputFilesSet);\n        }\n\n        return this._inputFiles;\n    }\n\n    toString() {\n        return 'lookup: ' + this.getInputFiles().join(', ');\n    }\n}\n\nmodule.exports = TaglibLookup;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/UniqueVars.js":"'use strict';\n\nvar safeVarName = require('./safeVarName');\n\nclass UniqueVars {\n    constructor() {\n        this.vars = {};\n    }\n\n    addVar(name, value) {\n        if (typeof value !== 'string') {\n            // Convert the non-string value into a string for easy comparison\n            value = JSON.stringify(value);\n        }\n\n        name = safeVarName(name);\n\n        var entry = this.vars[name];\n        if (entry) {\n            var vars = entry.vars;\n\n            // See if there is already a variable with the requested value\n            for (var i=0; i<vars.length; i++) {\n                var curVar = vars[i];\n                if (curVar.value === value) {\n                    return curVar.name;\n                }\n            }\n\n            let newEntry = {\n                name: name + (++entry.counter),\n                value: value\n            };\n\n            entry.vars.push(newEntry);\n            return newEntry.name;\n        } else {\n            entry = {\n                vars: [\n                    {\n                        name: name,\n                        value: value\n                    }\n                ],\n                counter: 1\n            };\n\n            this.vars[name] = entry;\n        }\n\n        return name;\n    }\n}\n\nmodule.exports = UniqueVars;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/PosInfo.js":"'use strict';\n\nvar path = require('path');\n\nfunction getRelativePath(absolutePath) {\n    if (typeof window === 'undefined') {\n        absolutePath = path.resolve(process.cwd(), absolutePath);\n        return path.relative(process.cwd(), absolutePath);\n    } else {\n        return absolutePath;\n    }\n}\n\nclass PosInfo {\n    constructor(path, line, column) {\n        this.path = getRelativePath(path);\n        this.line = line;\n        this.column = column;\n    }\n\n    toString() {\n        return this.path + (this.line != null ? (\":\" + this.line + \":\" + this.column) : '');\n    }\n}\n\nmodule.exports = PosInfo;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/CompileError.js":"'use strict';\n\nclass CompileError {\n    constructor(errorInfo, context) {\n        this.context = context;\n        this.node = errorInfo.node;\n        this.message = errorInfo.message;\n        this.code = errorInfo.code;\n\n        var pos = errorInfo.pos;\n        var endPos = errorInfo.endPos;\n\n        if (pos == null) {\n            pos = this.node && this.node.pos;\n        }\n\n        if (endPos == null) {\n            endPos = this.node && this.node.endPos;\n        }\n\n        if (pos != null) {\n            pos = context.getPosInfo(pos);\n        }\n\n        if (endPos != null) {\n            endPos = context.getPosInfo(endPos);\n        }\n\n        this.pos = pos;\n        this.endPos = endPos;\n    }\n\n    toString() {\n        var pos = this.pos;\n        if (pos) {\n            pos = '[' + pos + '] ';\n        } else {\n            pos = '';\n        }\n        var str = pos + this.message;\n        if (pos == null && this.node) {\n            str += ' (' + this.node.toString() + ')';\n        }\n        return str;\n    }\n}\n\nmodule.exports = CompileError;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/macros.js":"'use strict';\n\nvar safeVarName = require('./safeVarName');\nvar ok = require('assert').ok;\n\nclass MacrosContext {\n    constructor() {\n        this._byName = {};\n    }\n\n    isMacro(name) {\n        if (!name) {\n            return false;\n        }\n\n        if (name.type === 'Literal') {\n            name = name.value;\n        }\n\n        return this._byName.hasOwnProperty(name);\n    }\n\n    getRegisteredMacro(name) {\n        return this._byName[name];\n    }\n\n    registerMacro(name, params) {\n        ok(name, '\"name\" is required');\n        ok(typeof name === 'string', '\"name\" should be a string');\n        if (params == null) {\n            params = [];\n\n        } else {\n            ok(Array.isArray(params), '\"params\" should be an array');\n        }\n\n\n        var hasOut = false;\n        var hasRenderBody = false;\n        params.forEach((param) => {\n            if (param === 'out') {\n                hasOut = true;\n            } else if (param === 'renderBody') {\n                hasRenderBody = true;\n            }\n        });\n\n        if (!hasOut) {\n            params.push('out');\n        }\n\n        if (!hasRenderBody) {\n            params.push('renderBody');\n        }\n\n        var paramIndexes = {};\n        params.forEach((param, i) => {\n            paramIndexes[param] = i;\n\n            if (param === 'out') {\n                hasOut = true;\n            } else if (param === 'renderBody') {\n                hasRenderBody = true;\n            }\n        });\n\n        var functionName = 'macro_' + safeVarName(name);\n\n        var macroDef = {\n            name: name,\n            params: params,\n            functionName: functionName,\n            getParamIndex: function(param) {\n                return paramIndexes[param];\n            }\n        };\n\n        this._byName[name] = macroDef;\n\n        return macroDef;\n    }\n}\n\nfunction createMacrosContext() {\n    return new MacrosContext();\n}\n\nexports.createMacrosContext = createMacrosContext;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/finger-print.js":"var sha1 = require('simple-sha1');\n\nmodule.exports = function(str) {\n    return sha1.sync(str);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/html-elements.js":"\nvar lassoPackageRoot = require('lasso-package-root');\nvar path = require('path');\nvar lassoCachingFS = require('lasso-caching-fs');\nvar fs = require('fs');\nvar stripJsonComments = require('strip-json-comments');\nvar fsReadOptions = { encoding: 'utf8' };\n\nfunction parseJSONFile(path) {\n    var json = fs.readFileSync(path, fsReadOptions);\n\n    try {\n        var taglibProps = JSON.parse(stripJsonComments(json));\n        return taglibProps;\n    } catch(e) {\n        throw new Error('Unable to parse JSON file at path \"' + path + '\". Error: ' + e);\n    }\n}\n\n\nfunction loadTags(file) {\n\n    var raw = parseJSONFile(file);\n    var tags = {};\n\n    for (var k in raw) {\n        if (raw.hasOwnProperty(k)) {\n            if (k.charAt(0) === '<' && k.charAt(k.length - 1) === '>') {\n                var tagName = k.substring(1, k.length - 1);\n                tags[tagName] = true;\n            }\n        }\n    }\n\n    return tags;\n}\n\n\nvar cache = {};\n\nfunction getPackageRootDir(dirname) {\n    try {\n        return lassoPackageRoot.getRootDir(dirname);\n    } catch(e) {\n        return undefined;\n    }\n}\n\nfunction isRegisteredElement(tagName, dir) {\n    var packageRootDir = getPackageRootDir(dir);\n\n    var currentDir = dir;\n\n    while (true) {\n        var filePath = path.join(currentDir, 'html-elements.json');\n        if (lassoCachingFS.existsSync(filePath)) {\n            var tags = cache[filePath];\n            if (!tags) {\n                tags = cache[filePath] = loadTags(filePath);\n            }\n\n            if (tags[tagName]) {\n                return true;\n            }\n        }\n\n\n        var parentDir = path.dirname(currentDir);\n        if (!parentDir || parentDir === currentDir || parentDir === packageRootDir) {\n            break;\n        }\n        currentDir = parentDir;\n    }\n\n    return false;\n}\n\nexports.isRegisteredElement = isRegisteredElement;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/isJavaScriptReservedWord.js":"var reservedWords = require('./javaScriptReservedWords');\n\nmodule.exports = function isJavaScriptReservedWord(varName) {\n    return reservedWords[varName] === true;\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/config.js":"var NODE_ENV = process.env.NODE_ENV;\nvar config;\n\n/* globals window */\nvar g = typeof window === 'undefined' ? global : window;\n\nif (g.__MARKO_CONFIG) {\n    config = g.__MARKO_CONFIG;\n} else {\n    config = g.__MARKO_CONFIG = {\n        /**\n         * If true, then the compiler will check the disk to see if a previously compiled\n         * template is the same age or newer than the source template. If so, the previously\n         * compiled template will be loaded. Otherwise, the template will be recompiled\n         * and saved to disk.\n         *\n         * If false, the template will always be recompiled. If `writeToDisk` is false\n         * then this option will be ignored.\n         */\n        checkUpToDate: process.env.MARKO_CLEAN ? false : true,\n        /**\n         * If true (the default) then compiled templates will be written to disk. If false,\n         * compiled templates will not be written to disk (i.e., no `.marko.js` file will\n         * be generated)\n         */\n        writeToDisk: true,\n\n        /**\n         * If true, then the compiled template on disk will assumed to be up-to-date if it exists.\n         */\n        assumeUpToDate: process.env.MARKO_CLEAN != null || process.env.hasOwnProperty('MARKO_HOT_RELOAD') ? false : ( NODE_ENV == null ? false : (NODE_ENV !== 'development' && NODE_ENV !== 'dev')),\n\n        /**\n         * If true, whitespace will be preserved in templates. Defaults to false.\n         * @type {Boolean}\n         */\n        preserveWhitespace: false,\n\n        // The default output mode for compiled templates\n        output: 'html',\n\n        /**\n         * Whether the version should be written to the template as a comment e.g.\n         * // Compiled using marko@4.0.0 - DO NOT EDIT\n         */\n        writeVersionComment: true\n    };\n}\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/InlineCompiler.js":"'use strict';\n\nlet CodeWriter = require('./CodeWriter');\n\nfunction fixIndentation(lines) {\n    let length = lines.length;\n    let startLine = 0;\n    let endLine = length;\n\n    for (; startLine<length; startLine++) {\n        let line = lines[startLine];\n        if (line.trim() !== '') {\n            break;\n        }\n    }\n\n    for (; endLine>startLine; endLine--) {\n        let line = lines[endLine-1];\n        if (line.trim() !== '') {\n            break;\n        }\n    }\n\n    if (endLine === startLine) {\n        return '';\n    }\n\n    if (startLine !== 0 || endLine !== length) {\n        lines = lines.slice(startLine, endLine);\n    }\n\n    let firstLine = lines[0];\n    let indentToRemove = /^\\s*/.exec(firstLine)[0];\n\n    if (indentToRemove) {\n        for (let i=0; i<lines.length; i++) {\n            let line = lines[i];\n            if (line.startsWith(indentToRemove)) {\n                lines[i] = line.substring(indentToRemove.length);\n            }\n        }\n    }\n\n    return lines.join('\\n');\n}\n\nfunction normalizeTemplateSrc(src) {\n    let lines = src.split(/\\r\\n|\\n\\r|\\n/);\n    if (lines.length) {\n        if (lines[0].trim() === '') {\n            return fixIndentation(lines);\n        }\n    }\n\n    return src.trim();\n}\nclass InlineCompiler {\n    constructor(context, compiler) {\n        this.context = context;\n        this.compiler = compiler;\n        this.builder = context.builder;\n\n        context.setInline(true);\n    }\n\n    compile(src) {\n        src = normalizeTemplateSrc(src);\n        // console.log('TEMPLATE SRC:>\\n' + src + '\\n<');\n        return this.compiler.compile(src, this.context);\n    }\n\n    get staticCode() {\n        let staticNodes = this.context.getStaticNodes();\n\n        if (!staticNodes || staticNodes.length === 0) {\n            return null;\n        }\n\n        let codeWriter = new CodeWriter(this.context.options, this.builder);\n        codeWriter.write(staticNodes);\n        return codeWriter.getCode();\n    }\n}\n\nmodule.exports = InlineCompiler;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/events.js":"var EventEmitter = require('events-light');\nmodule.exports = new EventEmitter();","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/defineRenderer.js":"var marko = require('./');\n\nfunction defineRenderer(def) {\n    var template = def.template;\n    var getTemplateData = def.getTemplateData;\n    var renderer = def.renderer;\n\n    if (typeof template === 'string') {\n        template = marko.load(template);\n    }\n\n    var createOut;\n\n    if (template) {\n        createOut = template.createOut;\n    } else {\n        createOut = def.createOut || marko.createOut;\n    }\n\n    if (!renderer) {\n        // Create a renderer function that takes care of translating\n        // the input properties to a view state. Also, this renderer\n        // takes care of re-using existing components.\n        renderer = function renderer(input, out) {\n            var newProps = input;\n\n            if (!newProps) {\n                // Make sure we always have a non-null input object\n                newProps = {};\n            }\n\n            // Use getTemplateData(state, props, out) to get the template\n            // data. If that method is not provided then just use the\n            // the state (if provided) or the input data.\n            var templateData = getTemplateData ?\n                getTemplateData(newProps, out) :\n                newProps;\n\n            // Render the template associated with the component using the final template\n            // data that we constructed\n            template.render(templateData, out);\n        };\n    }\n\n    renderer.render = function(input) {\n        var out = createOut();\n        renderer(input, out);\n        return out.end();\n    };\n\n    return renderer;\n}\n\nmodule.exports = defineRenderer;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/express.js":"require('./runtime/env-init');\n\nvar assign = require('object-assign');\nvar express = module.parent.require('express');\npatchResponse(express.response);\ndelete require.cache[__filename];\n\nmodule.exports = function markoAppMiddleware() {\n    var sacrificialApp = express();\n\n    sacrificialApp.once('mount', function onmount(parent) {\n        // Patch the response\n        patchResponse(parent.response);\n\n        // Remove sacrificial express app\n        parent._router.stack.pop();\n    });\n\n    return sacrificialApp;\n}\n\nfunction patchResponse(response) {\n    response.marko = response.marko || function(template, data) {\n        if(typeof template === 'string') {\n            throw new Error(\n                'res.marko does not take a template name or path like res.render.  ' +\n                'Instead you should use `require(\\'./path/to/template.marko\\')` ' +\n                'and pass the loaded template to this function.'\n            );\n        }\n\n        var res = this;\n        var req = res.req;\n        var app = res.app;\n        var $global = assign({ app, req, res }, app.locals, res.locals);\n\n        if (data) {\n            data = assign(data, {\n                $global: assign($global, data.$global)\n            });\n        } else {\n            data = { $global };\n        }\n\n        res.set({ 'content-type': 'text/html; charset=utf-8' });\n\n        template.render(data, res);\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/html.js":"module.exports = require('./runtime/html');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/index.js":"'use strict';\nrequire('../env-init');\n\nvar AsyncStream = require('./AsyncStream');\nvar Template = require('./Template');\n\n/**\n * Method is for internal usage only. This method\n * is invoked by code in a compiled Marko template and\n * it is used to create a new Template instance.\n * @private\n */\nexports.t = function createTemplate(path) {\n     return new Template(path);\n};\n\nfunction createOut(globalData, parent, state, buffer) {\n    return new AsyncStream(globalData, parent, state, buffer);\n}\n\nexports.createWriter = function(writer) {\n    return new AsyncStream(null, writer);\n};\n\nexports.Template = Template;\nexports.$__createOut = createOut;\nexports.AsyncStream = AsyncStream;\nexports.enableAsyncStackTrace = AsyncStream.enableAsyncStackTrace;\n\nrequire('../createOut').$__setCreateOut(createOut);","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/jquery.js":"var ready = require('./ready');\n\nvar idRegExp = /^\\#(\\S+)( .*)?/;\n\nexports.patchComponent = function(jQuery) {\n    /* globals window */\n\n    if (!jQuery) {\n        jQuery = window.$;\n        if (!jQuery) {\n            throw new Error('jQuery not found');\n        }\n    }\n\n    require('./components/Component').prototype.$ = function jqueryProxy(arg) {\n        var args = arguments;\n        var self = this;\n\n        if (args.length === 1) {\n            //Handle an \"ondomready\" callback function\n            if (typeof arg === 'function') {\n                return ready(function() {\n                    arg.call(self);\n                });\n            } else if (typeof arg === 'string') {\n                var match = idRegExp.exec(arg);\n                //Reset the search to 0 so the next call to exec will start from the beginning for the new string\n                if (match != null) {\n                    var componentElId = match[1];\n                    if (match[2] == null) {\n                        return jQuery(self.getEl(componentElId));\n                    } else {\n                        return jQuery('#' + self.getElId(componentElId) + match[2]);\n                    }\n                } else {\n                    var rootEl = self.getEl();\n                    if (!rootEl) {\n                        throw new Error('Root element is not defined for component');\n                    }\n                    if (rootEl) {\n                        return jQuery(arg, rootEl);\n                    }\n                }\n            }\n        } else if (args.length === 2 && typeof args[1] === 'string') {\n            return jQuery(arg, self.getEl(args[1]));\n        } else if (args.length === 0) {\n            return jQuery(self.el);\n        }\n        return jQuery.apply(window, arguments);\n    };\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/ready.js":"/*\n    jQuery's doc.ready/$(function(){}) should\n    you wish to use a cross-browser domReady solution\n    without opting for a library.\n\n    Demo: http://jsfiddle.net/zKLpb/\n\n    usage:\n    $(function(){\n        // your code\n    });\n\n    Parts: jQuery project, Diego Perini, Lucent M.\n    Previous version from Addy Osmani (https://raw.github.com/addyosmani/jquery.parts/master/jquery.documentReady.js)\n\n    This version: Patrick Steele-Idem\n    - Converted to CommonJS module\n    - Code cleanup\n    - Fixes for IE <=10\n*/\n\n/* globals window */\n\nvar isReady = false;\nvar readyBound = false;\n\nvar defaultWindow = typeof window != 'undefined' && window;\nvar defaultDocument = typeof document != 'undefined' && document;\n\nvar listeners = [];\n\nfunction domReadyCallback() {\n    for (var i = 0, len = listeners.length; i < len; i++) {\n        var listener = listeners[i];\n        listener[0].call(listener[1]);\n    }\n    listeners = null;\n}\n\nfunction bindReady(doc) {\n    var toplevel = false;\n    var win = doc.defaultView || defaultWindow || doc;\n\n    // Handle when the DOM is ready\n    function domReady() {\n        // Make sure that the DOM is not already loaded\n        if (!isReady) {\n            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n            if (!doc.body) {\n                return setTimeout(domReady, 1);\n            }\n            // Remember that the DOM is ready\n            isReady = true;\n            // If there are functions bound, to execute\n            domReadyCallback();\n            // Execute all of them\n        }\n    } // /ready()\n\n    // The ready event handler\n    function domContentLoaded() {\n        if (doc.addEventListener) {\n            doc.removeEventListener(\"DOMContentLoaded\", domContentLoaded, false);\n            doc.removeEventListener(\"load\", domContentLoaded, false);\n        } else {\n            // we're here because readyState !== \"loading\" in oldIE\n            // which is good enough for us to call the dom ready!\n            doc.detachEvent(\"onreadystatechange\", domContentLoaded);\n            doc.detachEvent(\"onload\", domContentLoaded);\n        }\n        domReady();\n    }\n\n    // The DOM ready check for Internet Explorer\n    function doScrollCheck() {\n        if (isReady) {\n            return;\n        }\n\n        try {\n            // If IE is used, use the trick by Diego Perini\n            // http://javascript.nwbox.com/IEContentLoaded/\n            doc.documentElement.doScroll(\"left\");\n        } catch (error) {\n            setTimeout(doScrollCheck, 1);\n            return;\n        }\n        // and execute any waiting functions\n        domReady();\n    }\n\n    // Catch cases where $ is called after the\n    // browser event has already occurred. IE <= 10 has a bug that results in 'interactive' being assigned\n    // to the readyState before the DOM is really ready\n    if (document.attachEvent ? document.readyState === \"complete\" : document.readyState !== \"loading\") {\n        // We will get here if the browser is IE and the readyState === 'complete' or the browser\n        // is not IE and the readyState === 'interactive' || 'complete'\n        domReady(doc);\n    } else if (doc.addEventListener) { // Standards-based browsers support DOMContentLoaded\n        // Use the handy event callback\n        doc.addEventListener(\"DOMContentLoaded\", domContentLoaded, false);\n        // A fallback to win.onload, that will always work\n        win.addEventListener(\"load\", domContentLoaded, false);\n        // If IE event model is used\n    } else if (doc.attachEvent) {\n        // ensure firing before onload,\n        // maybe late but safe also for iframes\n        doc.attachEvent(\"onreadystatechange\", domContentLoaded);\n        // A fallback to win.onload, that will always work\n        win.attachEvent(\"onload\", domContentLoaded);\n        // If IE and not a frame\n        // continually check to see if the document is ready\n        try {\n            toplevel = win.frameElement == null;\n        } catch (e) {}\n        if (doc.documentElement.doScroll && toplevel) {\n            doScrollCheck();\n        }\n    }\n}\n\nfunction ready(callback, thisObj, doc) {\n    if (isReady) {\n        return callback.call(thisObj);\n    }\n\n    listeners.push([callback, thisObj]);\n\n    if (!readyBound) {\n        readyBound = true;\n        bindReady(doc || defaultDocument);\n    }\n}\n\nmodule.exports = ready;\n\nmodule.exports.patchComponent = function() {\n    require('./components/Component').prototype.ready = function (callback) {\n        var document = this.el.ownerDocument;\n        ready(callback, this, document);\n    };\n};\n\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/node-require-browser.js":"exports.install = function() {};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/node-require.js":"'use strict';\nrequire('./runtime/env-init');\n\nconst path = require('path');\nconst resolveFrom = require('resolve-from');\nconst fs = require('fs');\nconst fsReadOptions = { encoding: 'utf8' };\nconst MARKO_EXTENSIONS = Symbol('MARKO_EXTENSIONS');\n\nfunction normalizeExtension(extension) {\n    if (extension.charAt(0) !== '.') {\n        extension = '.' + extension;\n    }\n    return extension;\n}\n\nfunction compile(templatePath, markoCompiler, compilerOptions) {\n    if (compilerOptions) {\n        compilerOptions = Object.assign({}, markoCompiler.defaultOptions, compilerOptions);\n    } else {\n        compilerOptions = markoCompiler.defaultOptions;\n    }\n\n    var writeToDisk = compilerOptions.writeToDisk;\n\n    var templateSrc;\n    var compiledSrc;\n\n    if (writeToDisk === false) {\n        // Don't write the compiled template to disk. Instead, load it\n        // directly from the compiled source using the internals of the\n        // Node.js module loading system.\n        templateSrc = fs.readFileSync(templatePath, fsReadOptions);\n        compiledSrc = markoCompiler.compile(templateSrc, templatePath);\n    } else {\n        var targetFile = templatePath + '.js';\n\n        if (markoCompiler.defaultOptions.assumeUpToDate && fs.existsSync(targetFile)) {\n            // If the target file already exists and \"assumeUpToDate\" then just use the previously\n            // compiled template.\n            return fs.readFileSync(targetFile, fsReadOptions);\n        }\n\n        var targetDir = path.dirname(templatePath);\n\n        var isUpToDate = markoCompiler.checkUpToDate(targetFile);\n\n        if (isUpToDate) {\n            compiledSrc = fs.readFileSync(targetFile, fsReadOptions);\n        } else {\n            templateSrc = fs.readFileSync(templatePath, fsReadOptions);\n        \tcompiledSrc = markoCompiler.compile(templateSrc, templatePath, compilerOptions);\n\n            // Write to a temporary file and move it into place to avoid problems\n            // assocatiated with multiple processes write to the same file. We only\n            // write the compiled source code to disk so that stack traces will\n            // be accurate.\n            var filename = path.basename(targetFile);\n            var tempFile = path.join(targetDir, '.' + process.pid + '.' + Date.now() + '.' + filename);\n            fs.writeFileSync(tempFile, compiledSrc, fsReadOptions);\n            fs.renameSync(tempFile, targetFile);\n        }\n    }\n\n    // We attach a path to the compiled template so that hot reloading will work.\n    return compiledSrc;\n}\n\nfunction getLoadedTemplate(path) {\n    var cached = require.cache[path];\n    return cached && cached.exports.render ? cached.exports : undefined;\n}\n\nfunction install(options) {\n    options = options || {};\n\n    var requireExtensions = options.require ? // options.require introduced for testing\n        options.require.extensions :\n        require.extensions;\n\n    var compilerOptions = options.compilerOptions;\n\n    if (compilerOptions) {\n        require('./compiler').configure(compilerOptions);\n    } else {\n        compilerOptions = {};\n    }\n\n    var extensions = [];\n\n    if (options.extension) {\n        extensions.push(options.extension);\n    }\n\n    if (options.extensions) {\n        extensions = extensions.concat(options.extensions);\n    }\n\n    if (extensions.length === 0) {\n        extensions.push('.marko');\n    }\n\n    function markoRequireExtension(module, filename) {\n        var targetFile = filename + '.js';\n        var cachedTemplate = getLoadedTemplate(targetFile) || getLoadedTemplate(filename);\n        if (cachedTemplate) {\n            // The template has already been loaded so use the exports of the already loaded template\n            module.exports = cachedTemplate;\n            return;\n        }\n\n        // Resolve the appropriate compiler relative to the location of the\n        // marko template file on disk using the \"resolve-from\" module.\n        var dirname = path.dirname(filename);\n        var markoCompilerModulePath = resolveFrom(dirname, 'marko/compiler');\n        var markoCompiler = require(markoCompilerModulePath);\n\n        // Now use the appropriate Marko compiler to compile the Marko template\n        // file to JavaScript source code:\n        var compiledSrc = compile(filename, markoCompiler, compilerOptions);\n\n        // Append \".js\" to the filename since that is where we write the compiled\n        // source code that is being loaded. This allows stack traces to match up.\n        module._compile(compiledSrc, targetFile);\n    }\n\n    requireExtensions[MARKO_EXTENSIONS] = requireExtensions[MARKO_EXTENSIONS] ||\n        (requireExtensions[MARKO_EXTENSIONS] = []);\n\n    extensions.forEach((extension) => {\n        extension = normalizeExtension(extension);\n        requireExtensions[extension] = markoRequireExtension;\n        requireExtensions[MARKO_EXTENSIONS].push(extension);\n    });\n}\n\ninstall();\n\nexports.install = install;\n\nexports.getExtensions = function() {\n    return require.extensions[MARKO_EXTENSIONS];\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/stream.js":"/*\nThis module is used to monkey patch `Template.prototype` to add a new `stream(templateData)` method. Since\nstreaming module is likely not needed in the browser, we have made this method optional.\n\nTemplate.prototype.stream is always available on the server, but if you need streaming in the browser you must add\nthe following line to your app:\n\n    require('marko/stream');\n\n*/\n\nrequire('./runtime/stream');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/vdom.js":"module.exports = require('./runtime/vdom');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/index.js":"'use strict';\n// helpers provide a core set of various utility methods\n// that are available in every template\nvar AsyncVDOMBuilder = require('./AsyncVDOMBuilder');\nvar makeRenderable = require('../renderable');\n\n/**\n * Method is for internal usage only. This method\n * is invoked by code in a compiled Marko template and\n * it is used to create a new Template instance.\n * @private\n */\nexports.t = function createTemplate(path) {\n     return new Template(path);\n};\n\nfunction Template(path, func) {\n    this.path = path;\n    this._ = func;\n    this.meta = undefined;\n}\n\nfunction createOut(globalData, parent, state) {\n    return new AsyncVDOMBuilder(globalData, parent, state);\n}\n\nvar Template_prototype = Template.prototype = {\n    createOut: createOut\n};\n\nmakeRenderable(Template_prototype);\n\nexports.Template = Template;\nexports.$__createOut = createOut;\n\nrequire('../createOut').$__setCreateOut(createOut);\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/AsyncVDOMBuilder.js":"var EventEmitter = require('events-light');\nvar vdom = require('./vdom');\nvar VElement = vdom.$__VElement;\nvar VDocumentFragment = vdom.$__VDocumentFragment;\nvar VComment = vdom.$__VComment;\nvar VText = vdom.$__VText;\nvar virtualizeHTML = vdom.$__virtualizeHTML;\nvar RenderResult = require('../RenderResult');\nvar defaultDocument = vdom.$__defaultDocument;\n\nvar FLAG_FINISHED = 1;\nvar FLAG_LAST_FIRED = 2;\n\nvar EVENT_UPDATE = 'update';\nvar EVENT_FINISH = 'finish';\n\nfunction State(tree) {\n    this.$__remaining = 1;\n    this.$__events = new EventEmitter();\n    this.$__tree = tree;\n    this.$__last = null;\n    this.$__lastCount = 0;\n    this.$__flags = 0;\n}\n\nfunction AsyncVDOMBuilder(globalData, parentNode, state) {\n    if (!parentNode) {\n        parentNode = new VDocumentFragment();\n    }\n\n    if (state) {\n        state.$__remaining++;\n    } else {\n        state = new State(parentNode);\n    }\n\n    this.data = {};\n    this.$__state = state;\n    this.$__parent = parentNode;\n    this.global = globalData || {};\n    this.$__stack = [parentNode];\n    this.$__sync = false;\n    this.$__vnode = undefined;\n    this.$c = null; // Component args\n}\n\nvar proto = AsyncVDOMBuilder.prototype = {\n    $__isOut: true,\n    $__document: defaultDocument,\n\n    element: function(tagName, attrs, childCount, flags, props) {\n        var element = new VElement(tagName, attrs, childCount, flags, props);\n\n        var parent = this.$__parent;\n\n        if (parent !== undefined) {\n            parent.$__appendChild(element);\n        }\n\n        return childCount === 0 ? this : element;\n    },\n\n    n: function(node) {\n        // NOTE: We do a shallow clone since we assume the node is being reused\n        //       and a node can only have one parent node.\n        return this.node(node.$__cloneNode());\n    },\n\n    node: function(node) {\n        var parent = this.$__parent;\n        if (parent !== undefined) {\n            parent.$__appendChild(node);\n        }\n        return this;\n    },\n\n    text: function(text) {\n        var type = typeof text;\n\n        if (type != 'string') {\n            if (text == null) {\n                return;\n            } else if (type === 'object') {\n                if (text.toHTML) {\n                    return this.h(text.toHTML());\n                }\n            }\n\n            text = text.toString();\n        }\n\n        var parent = this.$__parent;\n        if (parent !== undefined) {\n            var lastChild = parent.lastChild;\n            if (lastChild && lastChild.$__Text) {\n                lastChild.nodeValue += text;\n            } else {\n                parent.$__appendChild(new VText(text));\n            }\n        }\n        return this;\n    },\n\n    comment: function(comment) {\n        return this.node(new VComment(comment));\n    },\n\n    html: function(html) {\n        if (html != null) {\n            var vdomNode = virtualizeHTML(html, this.$__document);\n            this.node(vdomNode);\n        }\n\n        return this;\n    },\n\n    beginElement: function(name, attrs, childCount, flags, constId) {\n        var element = new VElement(name, attrs, childCount, flags, constId);\n        var parent = this.$__parent;\n        if (parent !== undefined) {\n            parent.$__appendChild(element);\n            this.$__stack.push(element);\n            this.$__parent = element;\n        }\n        return this;\n    },\n\n    endElement: function() {\n        var stack = this.$__stack;\n        stack.pop();\n        this.$__parent = stack[stack.length-1];\n    },\n\n    end: function() {\n        var state = this.$__state;\n\n        this.$__parent = undefined;\n\n        var remaining = --state.$__remaining;\n\n        if (!(state.$__flags & FLAG_LAST_FIRED) && (remaining - state.$__lastCount === 0)) {\n            state.$__flags |= FLAG_LAST_FIRED;\n            state.$__lastCount = 0;\n            state.$__events.emit('last');\n        }\n\n        if (remaining === 0) {\n            state.$__flags |= FLAG_FINISHED;\n            state.$__events.emit(EVENT_FINISH, this.$__getResult());\n        }\n\n        return this;\n    },\n\n    error: function(e) {\n        try {\n            this.emit('error', e);\n        } finally {\n            // If there is no listener for the error event then it will\n            // throw a new Error here. In order to ensure that the async fragment\n            // is still properly ended we need to put the end() in a `finally`\n            // block\n            this.end();\n        }\n\n        return this;\n    },\n\n    beginAsync: function(options) {\n        if (this.$__sync) {\n            throw Error('Not allowed');\n        }\n\n        var state = this.$__state;\n\n        if (options) {\n            if (options.last) {\n                state.$__lastCount++;\n            }\n        }\n\n        var documentFragment = this.$__parent.$__appendDocumentFragment();\n        var asyncOut = new AsyncVDOMBuilder(this.global, documentFragment, state);\n\n        state.$__events.emit('beginAsync', {\n           out: asyncOut,\n           parentOut: this\n       });\n\n       return asyncOut;\n    },\n\n    createOut: function(callback) {\n        return new AsyncVDOMBuilder(this.global);\n    },\n\n    flush: function() {\n        var events = this.$__state.$__events;\n\n        if (events.listenerCount(EVENT_UPDATE)) {\n            events.emit(EVENT_UPDATE, new RenderResult(this));\n        }\n    },\n\n    $__getOutput: function() {\n        return this.$__state.$__tree;\n    },\n\n    $__getResult: function() {\n        return this.$__result || (this.$__result = new RenderResult(this));\n    },\n\n    on: function(event, callback) {\n        var state = this.$__state;\n\n        if (event === EVENT_FINISH && (state.$__flags & FLAG_FINISHED)) {\n            callback(this.$__getResult());\n        } else {\n            state.$__events.on(event, callback);\n        }\n\n        return this;\n    },\n\n    once: function(event, callback) {\n        var state = this.$__state;\n\n        if (event === EVENT_FINISH && (state.$__flags & FLAG_FINISHED)) {\n            callback(this.$__getResult());\n            return this;\n        }\n\n        state.$__events.once(event, callback);\n        return this;\n    },\n\n    emit: function(type, arg) {\n        var events = this.$__state.$__events;\n        switch(arguments.length) {\n            case 1:\n                events.emit(type);\n                break;\n            case 2:\n                events.emit(type, arg);\n                break;\n            default:\n                events.emit.apply(events, arguments);\n                break;\n        }\n        return this;\n    },\n\n    removeListener: function() {\n        var events = this.$__state.$__events;\n        events.removeListener.apply(events, arguments);\n        return this;\n    },\n\n    sync: function() {\n        this.$__sync = true;\n    },\n\n    isSync: function() {\n        return this.$__sync;\n    },\n\n    onLast: function(callback) {\n        var state = this.$__state;\n\n        var lastArray = state.$__last;\n\n        if (!lastArray) {\n            lastArray = state.$__last = [];\n            var i = 0;\n            var next = function() {\n                if (i === lastArray.length) {\n                    return;\n                }\n                var _next = lastArray[i++];\n                _next(next);\n            };\n\n            this.once('last', function() {\n                next();\n            });\n        }\n\n        lastArray.push(callback);\n        return this;\n    },\n\n    $__getNode: function(doc) {\n        var node = this.$__vnode;\n        if (!node) {\n            var vdomTree = this.$__getOutput();\n\n            node = this.$__vnode = vdomTree.actualize(doc || this.$__document);\n        }\n        return node;\n    },\n\n    toString: function() {\n        return this.$__getNode().outerHTML;\n    },\n\n    then: function(fn, fnErr) {\n        var out = this;\n        var promise = new Promise(function(resolve, reject) {\n            out.on('error', reject)\n                .on(EVENT_FINISH, function(result) {\n                    resolve(result);\n                });\n        });\n\n        return Promise.resolve(promise).then(fn, fnErr);\n    },\n\n    catch: function(fnErr) {\n        return this.then(undefined, fnErr);\n    },\n\n    isVDOM: true\n};\n\nproto.e = proto.element;\nproto.be = proto.beginElement;\nproto.ee = proto.endElement;\nproto.t = proto.text;\nproto.h = proto.w = proto.write = proto.html;\n\nmodule.exports = AsyncVDOMBuilder;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/vdom.js":"var VNode = require('./VNode');\nvar VComment = require('./VComment');\nvar VDocumentFragment = require('./VDocumentFragment');\nvar VElement = require('./VElement');\nvar VText = require('./VText');\n\nvar FLAG_IS_TEXTAREA = 2;\nvar defaultDocument = typeof document != 'undefined' && document;\nvar specialHtmlRegexp = /[&<]/;\nvar xmlnsRegExp = /^xmlns(:|$)/;\nvar virtualizedProps = { $__virtualized: true };\n\nfunction virtualizeChildNodes(node, vdomParent) {\n    var curChild = node.firstChild;\n    while(curChild) {\n        vdomParent.$__appendChild(virtualize(curChild));\n        curChild = curChild.nextSibling;\n    }\n}\n\nfunction virtualize(node) {\n    switch(node.nodeType) {\n        case 1:\n            var attributes = node.attributes;\n            var attrCount = attributes.length;\n\n            var attrs;\n\n            if (attrCount) {\n                attrs = {};\n                for (var i=0; i<attrCount; i++) {\n                    var attr = attributes[i];\n                    var attrName = attr.name;\n                    if (!xmlnsRegExp.test(attrName)) {\n                        attrs[attrName] = attr.value;\n                    }\n                }\n            }\n\n            var flags = 0;\n\n            var tagName = node.nodeName;\n            if (tagName === 'TEXTAREA') {\n                flags |= FLAG_IS_TEXTAREA;\n            }\n\n            var vdomEl = new VElement(tagName, attrs, null, flags, virtualizedProps);\n            if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml') {\n                vdomEl.$__namespaceURI = node.namespaceURI;\n            }\n\n            if (vdomEl.$__isTextArea) {\n                vdomEl.$__value = node.value;\n            } else {\n                virtualizeChildNodes(node, vdomEl);\n            }\n\n            return vdomEl;\n        case 3:\n            return new VText(node.nodeValue);\n        case 8:\n            return new VComment(node.nodeValue);\n        case 11:\n            var vdomDocFragment = new VDocumentFragment();\n            virtualizeChildNodes(node, vdomDocFragment);\n            return vdomDocFragment;\n    }\n}\n\nfunction virtualizeHTML(html, doc) {\n    if (!specialHtmlRegexp.test(html)) {\n        return new VText(html);\n    }\n\n    var container = doc.createElement('body');\n    container.innerHTML = html;\n    var vdomFragment = new VDocumentFragment();\n\n    var curChild = container.firstChild;\n    while(curChild) {\n        vdomFragment.$__appendChild(virtualize(curChild));\n        curChild = curChild.nextSibling;\n    }\n\n    return vdomFragment;\n}\n\nvar Node_prototype = VNode.prototype;\n\n/**\n * Shorthand method for creating and appending a Text node with a given value\n * @param  {String} value The text value for the new Text node\n */\nNode_prototype.t = function(value) {\n    var type = typeof value;\n    var vdomNode;\n\n    if (type !== 'string') {\n        if (value == null) {\n            value = '';\n        } else if (type === 'object') {\n            if (value.toHTML) {\n                vdomNode = virtualizeHTML(value.toHTML(), document);\n            }\n        }\n    }\n\n    this.$__appendChild(vdomNode || new VText(value.toString()));\n    return this.$__finishChild();\n};\n\n/**\n * Shorthand method for creating and appending a Comment node with a given value\n * @param  {String} value The value for the new Comment node\n */\nNode_prototype.c = function(value) {\n    this.$__appendChild(new VComment(value));\n    return this.$__finishChild();\n};\n\nNode_prototype.$__appendDocumentFragment = function() {\n    return this.$__appendChild(new VDocumentFragment());\n};\n\nexports.$__VComment = VComment;\nexports.$__VDocumentFragment = VDocumentFragment;\nexports.$__VElement = VElement;\nexports.$__VText = VText;\nexports.$__virtualize = virtualize;\nexports.$__virtualizeHTML = virtualizeHTML;\nexports.$__defaultDocument = defaultDocument;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/VNode.js":"/* jshint newcap:false */\nvar specialElHandlers = require('../../morphdom/specialElHandlers');\n\nfunction VNode() {}\n\nVNode.prototype = {\n    $__VNode: function(finalChildCount) {\n        this.$__finalChildCount = finalChildCount;\n        this.$__childCount = 0;\n        this.$__firstChild = null;\n        this.$__lastChild = null;\n        this.$__parentNode = null;\n        this.$__nextSibling = null;\n    },\n\n    get firstChild() {\n        var firstChild = this.$__firstChild;\n\n        if (firstChild && firstChild.$__DocumentFragment) {\n            var nestedFirstChild = firstChild.firstChild;\n            // The first child is a DocumentFragment node.\n            // If the DocumentFragment node has a first child then we will return that.\n            // Otherwise, the DocumentFragment node is not *really* the first child and\n            // we need to skip to its next sibling\n            return nestedFirstChild || firstChild.nextSibling;\n        }\n\n        return firstChild;\n    },\n\n    get nextSibling() {\n        var nextSibling = this.$__nextSibling;\n\n        if (nextSibling) {\n            if (nextSibling.$__DocumentFragment) {\n                var firstChild = nextSibling.firstChild;\n                return firstChild || nextSibling.nextSibling;\n            }\n        } else {\n            var parentNode = this.$__parentNode;\n            if (parentNode && parentNode.$__DocumentFragment) {\n                return parentNode.nextSibling;\n            }\n        }\n\n        return nextSibling;\n    },\n\n    $__appendChild: function(child) {\n        this.$__childCount++;\n\n        if (this.$__isTextArea) {\n            if (child.$__Text) {\n                var childValue = child.nodeValue;\n                this.$__value = (this.$__value || '') + childValue;\n            } else {\n                throw TypeError();\n            }\n        } else {\n            var lastChild = this.$__lastChild;\n\n            child.$__parentNode = this;\n\n            if (lastChild) {\n                lastChild.$__nextSibling = child;\n            } else {\n                this.$__firstChild = child;\n            }\n\n            this.$__lastChild = child;\n        }\n\n        return child;\n    },\n\n    $__finishChild: function finishChild() {\n        if (this.$__childCount == this.$__finalChildCount && this.$__parentNode) {\n            return this.$__parentNode.$__finishChild();\n        } else {\n            return this;\n        }\n    },\n\n    actualize: function(doc) {\n        var actualNode = this.$__actualize(doc);\n\n        var curChild = this.firstChild;\n\n        while(curChild) {\n            actualNode.appendChild(curChild.actualize(doc));\n            curChild = curChild.nextSibling;\n        }\n\n        if (this.$__nodeType === 1) {\n            var elHandler = specialElHandlers[this.$__nodeName];\n            if (elHandler !== undefined) {\n                elHandler(actualNode, this);\n            }\n        }\n\n        return actualNode;\n    }\n\n    // ,toJSON: function() {\n    //     var clone = Object.assign({\n    //         nodeType: this.nodeType\n    //     }, this);\n    //\n    //     for (var k in clone) {\n    //         if (k.startsWith('_')) {\n    //             delete clone[k];\n    //         }\n    //     }\n    //     delete clone._nextSibling;\n    //     delete clone._lastChild;\n    //     delete clone.parentNode;\n    //     return clone;\n    // }\n};\n\nmodule.exports = VNode;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/morphdom/specialElHandlers.js":"function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name, '');\n        }\n    }\n}\n\nmodule.exports = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value != toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.$__hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value != newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.$__hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                if (curChild.$__nodeName == 'OPTION') {\n                    if (curChild.$__hasAttribute('selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/VComment.js":"var VNode = require('./VNode');\nvar inherit = require('raptor-util/inherit');\n\nfunction VComment(value) {\n    this.$__VNode(-1 /* no children */);\n    this.nodeValue = value;\n}\n\nVComment.prototype = {\n    $__nodeType: 8,\n\n    $__actualize: function(doc) {\n        return doc.createComment(this.nodeValue);\n    },\n\n    $__cloneNode: function() {\n        return new VComment(this.nodeValue);\n    }\n};\n\ninherit(VComment, VNode);\n\nmodule.exports = VComment;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/VDocumentFragment.js":"var VNode = require('./VNode');\nvar inherit = require('raptor-util/inherit');\nvar extend = require('raptor-util/extend');\n\nfunction VDocumentFragmentClone(other) {\n    extend(this, other);\n    this.$__parentNode = null;\n    this.$__nextSibling = null;\n}\n\nfunction VDocumentFragment(documentFragment) {\n    this.$__VNode(null /* childCount */);\n    this.namespaceURI = null;\n}\n\nVDocumentFragment.prototype = {\n    $__nodeType: 11,\n\n    $__DocumentFragment: true,\n\n    $__cloneNode: function() {\n        return new VDocumentFragmentClone(this);\n    },\n\n    $__actualize: function(doc) {\n        return doc.createDocumentFragment();\n    }\n};\n\ninherit(VDocumentFragment, VNode);\n\nVDocumentFragmentClone.prototype = VDocumentFragment.prototype;\n\nmodule.exports = VDocumentFragment;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/VElement.js":"var VNode = require('./VNode');\nvar inherit = require('raptor-util/inherit');\n\nvar NS_XLINK = 'http://www.w3.org/1999/xlink';\nvar ATTR_XLINK_HREF = 'xlink:href';\nvar toString = String;\n\nvar FLAG_IS_SVG = 1;\nvar FLAG_IS_TEXTAREA = 2;\nvar FLAG_SIMPLE_ATTRS = 4;\n\nvar defineProperty = Object.defineProperty;\n\nvar ATTR_HREF = 'href';\nvar EMPTY_OBJECT = Object.freeze({});\n\nfunction convertAttrValue(type, value) {\n    if (value === true) {\n        return '';\n    } else if (type == 'object') {\n        return JSON.stringify(value);\n    } else {\n        return toString(value);\n    }\n}\n\nfunction setAttribute(el, namespaceURI, name, value) {\n    if (namespaceURI === null) {\n        el.setAttribute(name, value);\n    } else {\n        el.setAttributeNS(namespaceURI, name, value);\n    }\n}\n\nfunction removeAttribute(el, namespaceURI, name) {\n    if (namespaceURI === null) {\n        el.removeAttribute(name);\n    } else {\n        el.removeAttributeNS(namespaceURI, name);\n    }\n}\n\nfunction VElementClone(other) {\n    this.$__firstChild = other.$__firstChild;\n    this.$__parentNode = null;\n    this.$__nextSibling = null;\n\n    this.$__attributes = other.$__attributes;\n    this.$__properties = other.$__properties;\n    this.$__namespaceURI = other.$__namespaceURI;\n    this.$__nodeName = other.$__nodeName;\n    this.$__flags = other.$__flags;\n    this.$__value = other.$__value;\n    this.$__constId = other.$__constId;\n}\n\nfunction VElement(tagName, attrs, childCount, flags, props) {\n    this.$__VNode(childCount);\n\n    var constId;\n\n    if (props) {\n        constId = props.c;\n    }\n\n    var namespaceURI;\n\n    if ((this.$__flags = flags || 0)) {\n        if (flags & FLAG_IS_SVG) {\n            namespaceURI = 'http://www.w3.org/2000/svg';\n        }\n    }\n\n    this.$__attributes = attrs || EMPTY_OBJECT;\n    this.$__properties = props || EMPTY_OBJECT;\n    this.$__namespaceURI = namespaceURI;\n    this.$__nodeName = tagName;\n    this.$__value = null;\n    this.$__constId = constId;\n}\n\nVElement.prototype = {\n    $__VElement: true,\n\n    $__nodeType: 1,\n\n    $__cloneNode: function() {\n        return new VElementClone(this);\n    },\n\n    /**\n     * Shorthand method for creating and appending an HTML element\n     *\n     * @param  {String} tagName    The tag name (e.g. \"div\")\n     * @param  {int|null} attrCount  The number of attributes (or `null` if not known)\n     * @param  {int|null} childCount The number of child nodes (or `null` if not known)\n     */\n    e: function(tagName, attrs, childCount, flags, props) {\n        var child = this.$__appendChild(new VElement(tagName, attrs, childCount, flags, props));\n\n        if (childCount === 0) {\n            return this.$__finishChild();\n        } else {\n            return child;\n        }\n    },\n\n    /**\n     * Shorthand method for creating and appending a static node. The provided node is automatically cloned\n     * using a shallow clone since it will be mutated as a result of setting `nextSibling` and `parentNode`.\n     *\n     * @param  {String} value The value for the new Comment node\n     */\n    n: function(node) {\n        this.$__appendChild(node.$__cloneNode());\n        return this.$__finishChild();\n    },\n\n    $__actualize: function(doc) {\n        var namespaceURI = this.$__namespaceURI;\n        var tagName = this.$__nodeName;\n\n        var attributes = this.$__attributes;\n        var flags = this.$__flags;\n\n        var el = namespaceURI !== undefined ?\n            doc.createElementNS(namespaceURI, tagName) :\n            doc.createElement(tagName);\n\n        for (var attrName in attributes) {\n            var attrValue = attributes[attrName];\n\n            if (attrValue !== false && attrValue != null) {\n                var type = typeof attrValue;\n\n                if (type !== 'string') {\n                    // Special attributes aren't copied to the real DOM. They are only\n                    // kept in the virtual attributes map\n                    attrValue = convertAttrValue(type, attrValue);\n                }\n\n                if (attrName == ATTR_XLINK_HREF) {\n                    setAttribute(el, NS_XLINK, ATTR_HREF, attrValue);\n                } else {\n                    el.setAttribute(attrName, attrValue);\n                }\n            }\n        }\n\n        if (flags & FLAG_IS_TEXTAREA) {\n            el.value = this.$__value;\n        }\n\n        el._vattrs = attributes;\n        el._vprops = this.$__properties;\n        el._vflags = flags;\n\n        return el;\n    },\n\n    $__hasAttribute: function(name) {\n        // We don't care about the namespaces since the there\n        // is no chance that attributes with the same name will have\n        // different namespaces\n        var value = this.$__attributes[name];\n        return value != null && value !== false;\n    },\n};\n\ninherit(VElement, VNode);\n\nvar proto = VElementClone.prototype = VElement.prototype;\n\n['checked', 'selected', 'disabled'].forEach(function(name) {\n    defineProperty(proto, name, {\n        get: function () {\n            var value = this.$__attributes[name];\n            return value !== false && value != null;\n        }\n    });\n});\n\ndefineProperty(proto, 'id', {\n    get: function () {\n        return this.$__attributes.id;\n    }\n});\n\ndefineProperty(proto, 'value', {\n    get: function () {\n        var value = this.$__value;\n        if (value == null) {\n            value = this.$__attributes.value;\n        }\n        return value != null ? toString(value) : '';\n    }\n});\n\ndefineProperty(proto, '$__isTextArea', {\n    get: function () {\n        return this.$__flags & FLAG_IS_TEXTAREA;\n    }\n});\n\nVElement.$__removePreservedAttributes = function(attrs) {\n    // By default this static method is a no-op, but if there are any\n    // compiled components that have \"no-update\" attributes then\n    // `preserve-attrs.js` will be imported and this method will be replaced\n    // with a method that actually does something\n    return attrs;\n};\n\nVElement.$__morphAttrs = function(fromEl, toEl) {\n\n    var removePreservedAttributes = VElement.$__removePreservedAttributes;\n\n    var attrs = toEl.$__attributes;\n    var props = fromEl._vprops = toEl.$__properties;\n\n    var attrName;\n    var i;\n\n    // We use expando properties to associate the previous HTML\n    // attributes provided as part of the VDOM node with the\n    // real VElement DOM node. When diffing attributes,\n    // we only use our internal representation of the attributes.\n    // When diffing for the first time it's possible that the\n    // real VElement node will not have the expando property\n    // so we build the attribute map from the expando property\n\n    var oldAttrs = fromEl._vattrs;\n\n    if (oldAttrs) {\n        if (oldAttrs == attrs) {\n            // For constant attributes the same object will be provided\n            // every render and we can use that to our advantage to\n            // not waste time diffing a constant, immutable attribute\n            // map.\n            return;\n        } else {\n            oldAttrs = removePreservedAttributes(oldAttrs, props, true);\n        }\n    } else {\n        // We need to build the attribute map from the real attributes\n        oldAttrs = {};\n\n        var oldAttributesList = fromEl.attributes;\n        for (i = oldAttributesList.length - 1; i >= 0; --i) {\n            var attr = oldAttributesList[i];\n\n            if (attr.specified !== false) {\n                attrName = attr.name;\n                if (attrName !== 'data-marko') {\n                    var attrNamespaceURI = attr.namespaceURI;\n                    if (attrNamespaceURI === NS_XLINK) {\n                        oldAttrs[ATTR_XLINK_HREF] = attr.value;\n                    } else {\n                        oldAttrs[attrName] = attr.value;\n                    }\n                }\n            }\n        }\n\n        // We don't want preserved attributes to show up in either the old\n        // or new attribute map.\n        removePreservedAttributes(oldAttrs, props, false);\n    }\n\n    fromEl._vattrs = attrs;\n\n    var attrValue;\n\n    var flags = toEl.$__flags;\n    var oldFlags;\n\n    if (flags & FLAG_SIMPLE_ATTRS && ((oldFlags = fromEl._vflags) & FLAG_SIMPLE_ATTRS)) {\n        if (oldAttrs['class'] !== (attrValue = attrs['class'])) {\n            fromEl.className = attrValue;\n        }\n        if (oldAttrs.id !== (attrValue = attrs.id)) {\n            fromEl.id = attrValue;\n        }\n        if (oldAttrs.style !== (attrValue = attrs.style)) {\n            fromEl.style.cssText = attrValue;\n        }\n        return;\n    }\n\n    // In some cases we only want to set an attribute value for the first\n    // render or we don't want certain attributes to be touched. To support\n    // that use case we delete out all of the preserved attributes\n    // so it's as if they never existed.\n    attrs = removePreservedAttributes(attrs, props, true);\n\n    var namespaceURI;\n\n    // Loop over all of the attributes in the attribute map and compare\n    // them to the value in the old map. However, if the value is\n    // null/undefined/false then we want to remove the attribute\n    for (attrName in attrs) {\n        attrValue = attrs[attrName];\n        namespaceURI = null;\n\n        if (attrName === ATTR_XLINK_HREF) {\n            namespaceURI = NS_XLINK;\n            attrName = ATTR_HREF;\n        }\n\n        if (attrValue == null || attrValue === false) {\n            removeAttribute(fromEl, namespaceURI, attrName);\n        } else if (oldAttrs[attrName] !== attrValue) {\n            var type = typeof attrValue;\n\n            if (type !== 'string') {\n                attrValue = convertAttrValue(type, attrValue);\n            }\n\n            setAttribute(fromEl, namespaceURI, attrName, attrValue);\n        }\n    }\n\n    // If there are any old attributes that are not in the new set of attributes\n    // then we need to remove those attributes from the target node\n    //\n    // NOTE: We can skip this if the the element is keyed because if the element\n    //       is keyed then we know we already processed all of the attributes for\n    //       both the target and original element since target VElement nodes will\n    //       have all attributes declared. However, we can only skip if the node\n    //       was not a virtualized node (i.e., a node that was not rendered by a\n    //       Marko template, but rather a node that was created from an HTML\n    //       string or a real DOM node).\n    if (!attrs.id || props.$__virtualized === true) {\n        for (attrName in oldAttrs) {\n            if (!(attrName in attrs)) {\n                if (attrName === ATTR_XLINK_HREF) {\n                    fromEl.removeAttributeNS(ATTR_XLINK_HREF, ATTR_HREF);\n                } else {\n                    fromEl.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = VElement;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/VText.js":"var VNode = require('./VNode');\nvar inherit = require('raptor-util/inherit');\n\nfunction VText(value) {\n    this.$__VNode(-1 /* no children */);\n    this.nodeValue = value;\n}\n\nVText.prototype = {\n    $__Text: true,\n\n    $__nodeType: 3,\n\n    $__actualize: function(doc) {\n        return doc.createTextNode(this.nodeValue);\n    },\n\n    $__cloneNode: function() {\n        return new VText(this.nodeValue);\n    }\n};\n\ninherit(VText, VNode);\n\nmodule.exports = VText;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/bin/markoc.js":"var fs = require('fs');\nvar nodePath = require('path');\nvar cwd = process.cwd();\nvar resolveFrom = require('resolve-from');\n\n// Try to use the Marko compiler installed with the project\nvar markoCompilerPath;\nconst markocPkgVersion = require('../package.json').version;\n\nvar markoPkgVersion;\ntry {\n    var markoPkgPath = resolveFrom(process.cwd(), 'marko/package.json');\n    markoPkgVersion = require(markoPkgPath).version;\n} catch(e) {}\n\ntry {\n    markoCompilerPath = resolveFrom(process.cwd(), 'marko/compiler');\n} catch(e) {}\n\nvar markoCompiler;\n\nif (markoCompilerPath) {\n    markoCompiler = require(markoCompilerPath);\n} else {\n    markoCompiler = require('../compiler');\n}\n\nvar Minimatch = require('minimatch').Minimatch;\n\nvar appModulePath = require('app-module-path');\n\nrequire('raptor-polyfill/string/startsWith');\nrequire('raptor-polyfill/string/endsWith');\n\nmarkoCompiler.defaultOptions.checkUpToDate = false;\n\nvar mmOptions = {\n    matchBase: true,\n    dot: true,\n    flipNegate: true\n};\n\nfunction relPath(path) {\n    if (path.startsWith(cwd)) {\n        return path.substring(cwd.length+1);\n    }\n}\n\nvar args = require('argly').createParser({\n        '--help': {\n            type: 'boolean',\n            description: 'Show this help message'\n        },\n        '--files --file -f *': {\n            type: 'string[]',\n            description: 'A set of directories or files to compile'\n        },\n        '--ignore -i': {\n            type: 'string[]',\n            description: 'An ignore rule (default: --ignore \"/node_modules\" \".*\")'\n        },\n        '--clean -c': {\n            type: 'boolean',\n            description: 'Clean all of the *.marko.js files'\n        },\n        '--force': {\n            type: 'boolean',\n            description: 'Force template recompilation even if unchanged'\n        },\n        '--paths -p': {\n            type: 'string[]',\n            description: 'Additional directories to add to the Node.js module search path'\n        },\n        '--vdom -V': {\n            type: 'boolean',\n            description: 'VDOM output'\n        },\n        '--version -v': {\n            type: 'boolean',\n            description: 'Print markoc and marko compiler versions to the console'\n        }\n    })\n    .usage('Usage: $0 <pattern> [options]')\n    .example('Compile a single template', '$0 template.marko')\n    .example('Compile all templates in the current directory', '$0 .')\n    .example('Compile multiple templates', '$0 template.marko src/ foo/')\n    .example('Delete all *.marko.js files in the current directory', '$0 . --clean')\n    .validate(function(result) {\n        if (result.help) {\n            this.printUsage();\n            process.exit(0);\n        } else if (result.version) {\n            console.log('markoc@' + markocPkgVersion);\n\n            if (markoPkgVersion) {\n                console.log('marko@' + markoPkgVersion);\n            }\n\n            process.exit(0);\n        } else if (!result.files || result.files.length === 0) {\n            this.printUsage();\n            process.exit(1);\n        }\n    })\n    .onError(function(err) {\n        this.printUsage();\n\n        if (err) {\n            console.log();\n            console.log(err);\n        }\n\n        process.exit(1);\n    })\n    .parse();\n\nvar output = 'html';\n\nif (args.vdom) {\n    output = 'vdom';\n}\n\nvar compileOptions = {\n    output: output,\n    compilerType: 'markoc',\n    compilerVersion: markoPkgVersion || markocPkgVersion\n};\n\nvar force = args.force;\nif (force) {\n    markoCompiler.defaultOptions.checkUpToDate = false;\n}\n\nvar paths = args.paths;\nif (paths && paths.length) {\n    paths.forEach(function(path) {\n        appModulePath.addPath(nodePath.resolve(cwd, path));\n    });\n}\n\nvar ignoreRules = args.ignore;\n\nif (!ignoreRules) {\n    ignoreRules = ['/node_modules', '.*'];\n}\n\nignoreRules = ignoreRules.filter(function (s) {\n    s = s.trim();\n    return s && !s.match(/^#/);\n});\n\nignoreRules = ignoreRules.map(function (pattern) {\n\n    return new Minimatch(pattern, mmOptions);\n});\n\n\nfunction isIgnored(path, dir, stat) {\n    if (path.startsWith(dir)) {\n        path = path.substring(dir.length);\n    }\n\n    path = path.replace(/\\\\/g, '/');\n\n    var ignore = false;\n    var ignoreRulesLength = ignoreRules.length;\n    for (var i=0; i<ignoreRulesLength; i++) {\n        var rule = ignoreRules[i];\n\n        var match = rule.match(path);\n\n        if (!match && stat && stat.isDirectory()) {\n            try {\n                stat = fs.statSync(path);\n            } catch(e) {}\n\n            if (stat && stat.isDirectory()) {\n                match = rule.match(path + '/');\n            }\n        }\n\n\n        if (match) {\n            if (rule.negate) {\n                ignore = false;\n            } else {\n                ignore = true;\n            }\n        }\n    }\n\n    return ignore;\n}\n\nfunction walk(files, options, done) {\n    if (!files || files.length === 0) {\n        done('No files provided');\n    }\n\n    var pending = 0;\n\n    if (!Array.isArray(files)) {\n        files = [files];\n    }\n\n    var fileCallback = options.file;\n    var context = {\n        errors: [],\n        beginAsync: function() {\n            pending++;\n        },\n        endAsync: function(err) {\n            if (err) {\n                this.errors.push(err);\n            }\n\n            pending--;\n\n            if (pending === 0) {\n                if (this.errors.length) {\n                    done(this.errors);\n                } else {\n                    done(null);\n                }\n\n            }\n        }\n    };\n\n    function doWalk(dir) {\n        context.beginAsync();\n        fs.readdir(dir, function(err, list) {\n            if (err) {\n                return context.endAsync(err);\n            }\n\n            if (list.length) {\n                list.forEach(function(basename) {\n                    var file = nodePath.join(dir, basename);\n\n                    context.beginAsync();\n                    fs.stat(file, function(err, stat) {\n                        if (err) {\n                            return context.endAsync(err);\n                        }\n\n                        if (!isIgnored(file, dir, stat)) {\n                            if (stat && stat.isDirectory()) {\n                                doWalk(file);\n                            } else {\n                                fileCallback(file, context);\n                            }\n                        }\n\n                        context.endAsync();\n                    });\n                });\n            }\n\n            context.endAsync();\n        });\n    }\n\n    for (var i=0; i<files.length; i++) {\n        var file = nodePath.resolve(cwd, files[i]);\n\n        var stat = fs.statSync(file);\n\n        if (stat.isDirectory()) {\n            doWalk(file);\n        } else {\n            fileCallback(file, context);\n        }\n    }\n}\n\nif (args.clean) {\n    var deleteCount = 0;\n\n    walk(\n        args.files,\n        {\n            file: function(file, context) {\n                var basename = nodePath.basename(file);\n\n                if (basename.endsWith('.marko.js') || basename.endsWith('.marko.html') || basename.endsWith('.marko.xml.js')) {\n                    context.beginAsync();\n                    fs.unlink(file, function(err) {\n                        if (err) {\n                            return context.endAsync(err);\n                        }\n                        deleteCount++;\n                        console.log('Deleted: ' + file);\n                        context.endAsync();\n                    });\n\n\n                }\n            }\n        },\n        function(err) {\n            if (deleteCount === 0) {\n                console.log('No *.marko.js files were found. Already clean.');\n            } else {\n                console.log('Deleted ' + deleteCount + ' file(s)');\n            }\n\n        });\n\n} else {\n    var found = {};\n    var compileCount = 0;\n    var failed;\n    var failed = [];\n\n    var compile = function(path, context) {\n        if (found[path]) {\n            return;\n        }\n\n        found[path] = true;\n\n        var outPath = path + '.js';\n        console.log('Compiling:\\n  Input:  ' + relPath(path) + '\\n  Output: ' + relPath(outPath) + '\\n');\n        context.beginAsync();\n        markoCompiler.compileFile(path, compileOptions, function(err, src) {\n            if (err) {\n                failed.push('Failed to compile \"' + relPath(path) + '\". Error: ' + (err.stack || err));\n                context.endAsync(err);\n                return;\n            }\n\n            context.beginAsync();\n            fs.writeFile(outPath, src, {encoding: 'utf8'}, function(err, src) {\n                if (err) {\n                    failed.push('Failed to write \"' + path + '\". Error: ' + (err.stack || err));\n                    context.endAsync(err);\n                    return;\n                }\n\n                compileCount++;\n                context.endAsync();\n\n            });\n\n            context.endAsync();\n        });\n    };\n\n\n    if (args.files && args.files.length) {\n        walk(\n            args.files,\n            {\n                file: function(file, context) {\n                    var basename = nodePath.basename(file);\n\n                    if (basename.endsWith('.marko') || basename.endsWith('.marko.html') || basename.endsWith('.marko.xml')) {\n                        compile(file, context);\n                    }\n                }\n            },\n            function(err) {\n                if (err) {\n                    if (failed.length) {\n                        console.error('The following errors occurred:\\n- ' + failed.join('\\n- '));\n                    } else {\n                        console.error(err);\n                    }\n\n                    return;\n                }\n\n                if (compileCount === 0) {\n                    console.log('No templates found');\n                } else {\n                    console.log('Compiled ' + compileCount + ' templates(s)');\n                }\n\n            });\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/attach-detach.js":"var eventDelegation = require('./event-delegation');\nvar delegateEvent = eventDelegation.$__delegateEvent;\nvar getEventFromEl = eventDelegation.$__getEventFromEl;\n\nvar componentsUtil = require('./util');\nvar destroyElRecursive = componentsUtil.$__destroyElRecursive;\nvar destroyComponentForEl = componentsUtil.$__destroyComponentForEl;\n\nfunction handleNodeAttach(node, out) {\n    if (node.nodeType === 1) {\n        var target = getEventFromEl(node, 'onattach');\n        if (target) {\n            var data = out.data;\n\n            var attachTargets = data.$__attachTargets;\n            if (!attachTargets) {\n                attachTargets = data.$__attachTargets = [];\n                out.on('$__componentsInitialized', function() {\n                    for (var i=0; i<attachTargets.length; i+=2) {\n                        var node = attachTargets[i];\n                        var target = attachTargets[i+1];\n                        delegateEvent(node, target, {});\n                    }\n                });\n            }\n\n            attachTargets.push(node);\n            attachTargets.push(target);\n        }\n    }\n}\n\nfunction handleNodeDetach(node) {\n    if (node.nodeType === 1) {\n        var target = getEventFromEl(node, 'ondetach');\n        if (target) {\n            var allowDetach;\n\n            delegateEvent(node, target, {\n                preventDefault: function() {\n                    allowDetach = false;\n                    destroyComponentForEl(node);\n                    destroyElRecursive(node);\n                },\n                detach: function() {\n                    var parentNode = node.parentNode;\n                    if (parentNode) {\n                        parentNode.removeChild(node);\n                    }\n                }\n            });\n\n            return allowDetach;\n        }\n    }\n}\n\neventDelegation.$__handleNodeAttach = handleNodeAttach;\neventDelegation.$__handleNodeDetach = handleNodeDetach;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/event-delegation.js":"var componentsUtil = require('./util');\nvar runtimeId = componentsUtil.$__runtimeId;\nvar componentLookup = componentsUtil.$__componentLookup;\nvar getMarkoPropsFromEl = componentsUtil.$__getMarkoPropsFromEl;\n\nvar isArray = Array.isArray;\n\n// We make our best effort to allow multiple marko runtimes to be loaded in the\n// same window. Each marko runtime will get its own unique runtime ID.\nvar listenersAttachedKey = '$MED' + runtimeId;\n\nfunction getEventFromEl(el, eventName) {\n    var virtualProps = getMarkoPropsFromEl(el);\n    var eventInfo = virtualProps[eventName];\n    if (typeof eventInfo === 'string') {\n        eventInfo = eventInfo.split(' ');\n        if (eventInfo.length == 3) {\n            eventInfo[2] = parseInt(eventInfo[2], 10);\n        }\n    }\n\n    return eventInfo;\n}\n\nfunction delegateEvent(node, target, event) {\n    var targetMethod = target[0];\n    var targetComponentId = target[1];\n    var extraArgs = target[2];\n\n    var targetComponent = componentLookup[targetComponentId];\n\n    if (!targetComponent) {\n        return;\n    }\n\n    var targetFunc = targetComponent[targetMethod];\n    if (!targetFunc) {\n        throw Error('Method not found: ' + targetMethod);\n    }\n\n    if (extraArgs != null) {\n        if (typeof extraArgs === 'number') {\n            extraArgs = targetComponent.$__bubblingDomEvents[extraArgs];\n            if (!isArray(extraArgs)) {\n                extraArgs = [extraArgs];\n            }\n        }\n    }\n\n    // Invoke the component method\n    if (extraArgs) {\n        targetFunc.apply(targetComponent, extraArgs.concat(event, node));\n    } else {\n        targetFunc.call(targetComponent, event, node);\n    }\n}\n\nfunction attachBubbleEventListeners(doc) {\n    var body = doc.body;\n    // Here's where we handle event delegation using our own mechanism\n    // for delegating events. For each event that we have white-listed\n    // as supporting bubble, we will attach a listener to the root\n    // document.body element. When we get notified of a triggered event,\n    // we again walk up the tree starting at the target associated\n    // with the event to find any mappings for event. Each mapping\n    // is from a DOM event type to a method of a component.\n    require('./bubble').forEach(function addBubbleHandler(eventType) {\n        body.addEventListener(eventType, function(event) {\n            var propagationStopped = false;\n\n            // Monkey-patch to fix #97\n            var oldStopPropagation = event.stopPropagation;\n\n            event.stopPropagation = function() {\n                oldStopPropagation.call(event);\n                propagationStopped = true;\n            };\n\n            var curNode = event.target;\n            if (!curNode) {\n                return;\n            }\n\n            // Search up the tree looking DOM events mapped to target\n            // component methods\n            var propName = 'on' + eventType;\n            var target;\n\n            // Attributes will have the following form:\n            // on<event_type>(\"<target_method>|<component_id>\")\n\n            do {\n                if ((target = getEventFromEl(curNode, propName))) {\n                    delegateEvent(curNode, target, event);\n\n                    if (propagationStopped) {\n                        break;\n                    }\n                }\n            } while((curNode = curNode.parentNode) && curNode.getAttribute);\n        });\n    });\n}\n\nfunction noop() {}\n\nexports.$__handleNodeAttach = noop;\nexports.$__handleNodeDetach = noop;\nexports.$__delegateEvent = delegateEvent;\nexports.$__getEventFromEl = getEventFromEl;\n\nexports.$__init = function(doc) {\n    if (!doc[listenersAttachedKey]) {\n        doc[listenersAttachedKey] = true;\n        attachBubbleEventListeners(doc);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/boot.js":"require('./init-components').$__initServerRendered();","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/init-components.js":"// The server-side implementation of this module is intentionally empty","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/bubble.js":"module.exports = [\n    /* Mouse Events */\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseup',\n    // 'mouseover',\n    // 'mousemove',\n    // 'mouseout',\n    'dragstart',\n    'drag',\n    // 'dragenter',\n    // 'dragleave',\n    // 'dragover',\n    'drop',\n    'dragend',\n\n    /* Keyboard Events */\n    'keydown',\n    'keypress',\n    'keyup',\n\n    /* Form Events */\n    'select',\n    'change',\n    'submit',\n    'reset',\n    'input',\n\n    'attach', // Pseudo event supported by Marko\n    'detach'  // Pseudo event supported by Marko\n\n    // 'focus', <-- Does not bubble\n    // 'blur', <-- Does not bubble\n    // 'focusin', <-- Not supported in all browsers\n    // 'focusout' <-- Not supported in all browsers\n];","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/ComponentDef.js":"'use strict';\nvar nextRepeatedId = require('./nextRepeatedId');\nvar repeatedRegExp = /\\[\\]$/;\nvar componentUtil = require('./util');\nvar nextComponentId = componentUtil.$__nextComponentId;\nvar attachBubblingEvent = componentUtil.$__attachBubblingEvent;\n\nvar extend = require('raptor-util/extend');\nvar registry = require('./registry');\n\n/**\n * A ComponentDef is used to hold the metadata collected at runtime for\n * a single component and this information is used to instantiate the component\n * later (after the rendered HTML has been added to the DOM)\n */\nfunction ComponentDef(component, componentId, out, componentStack, componentStackLen) {\n    this.$__out = out; // The AsyncWriter that this component is associated with\n    this.$__componentStack = componentStack;\n    this.$__componentStackLen = componentStackLen;\n    this.$__component = component;\n    this.id = componentId;\n\n    this.$__roots =  null;            // IDs of root elements if there are multiple root elements\n    this.$__children = null;          // An array of nested ComponentDef instances\n    this.$__domEvents = null;         // An array of DOM events that need to be added (in sets of three)\n    this.$__bubblingDomEvents = null; // Used to keep track of bubbling DOM events for components rendered on the server\n\n    this.$__isExisting = false;\n\n    this.$__nextIdIndex = 0; // The unique integer to use for the next scoped ID\n}\n\nComponentDef.prototype = {\n    $__end: function() {\n        this.$__componentStack.length = this.$__componentStackLen;\n    },\n\n    /**\n     * Register a nested component for this component. We maintain a tree of components\n     * so that we can instantiate nested components before their parents.\n     */\n    $__addChild: function (componentDef) {\n        var children = this.$__children;\n\n        if (children) {\n            children.push(componentDef);\n        } else {\n            this.$__children = [componentDef];\n        }\n    },\n    /**\n     * This helper method generates a unique and fully qualified DOM element ID\n     * that is unique within the scope of the current component. This method prefixes\n     * the the nestedId with the ID of the current component. If nestedId ends\n     * with `[]` then it is treated as a repeated ID and we will generate\n     * an ID with the current index for the current nestedId.\n     * (e.g. \"myParentId-foo[0]\", \"myParentId-foo[1]\", etc.)\n     */\n    elId: function (nestedId) {\n        var id = this.id;\n        if (nestedId == null) {\n            return id;\n        } else {\n            if (typeof nestedId == 'string' && repeatedRegExp.test(nestedId)) {\n                return nextRepeatedId(this.$__out, id, nestedId);\n            } else {\n                return id + '-' + nestedId;\n            }\n        }\n    },\n    /**\n     * Registers a DOM event for a nested HTML element associated with the\n     * component. This is only done for non-bubbling events that require\n     * direct event listeners to be added.\n     * @param  {String} type The DOM event type (\"mouseover\", \"mousemove\", etc.)\n     * @param  {String} targetMethod The name of the method to invoke on the scoped component\n     * @param  {String} elId The DOM element ID of the DOM element that the event listener needs to be added too\n     */\n     e: function(type, targetMethod, elId, extraArgs) {\n        if (targetMethod) {\n            // The event handler method is allowed to be conditional. At render time if the target\n            // method is null then we do not attach any direct event listeners.\n            (this.$__domEvents || (this.$__domEvents = [])).push([\n                type,\n                targetMethod,\n                elId,\n                extraArgs]);\n        }\n    },\n    /**\n     * Returns the next auto generated unique ID for a nested DOM element or nested DOM component\n     */\n    $__nextId: function() {\n        var id = this.id;\n\n        return id ?\n            id + '-c' + (this.$__nextIdIndex++) :\n            nextComponentId(this.$__out);\n    },\n\n    d: function(handlerMethodName, extraArgs) {\n        return attachBubblingEvent(this, handlerMethodName, extraArgs);\n    }\n};\n\nComponentDef.$__deserialize = function(o, types) {\n    var id        = o[0];\n    var typeName  = types[o[1]];\n    var input     = o[2];\n    var extra     = o[3];\n\n    var state = extra.s;\n    var componentProps = extra.w;\n\n    var component = typeName /* legacy */ && registry.$__createComponent(typeName, id);\n\n    if (extra.b) {\n        component.$__bubblingDomEvents = extra.b;\n    }\n\n    // Preview newly created component from being queued for update since we area\n    // just building it from the server info\n    component.$__updateQueued = true;\n\n    if (state) {\n        var undefinedPropNames = extra.u;\n        if (undefinedPropNames) {\n            undefinedPropNames.forEach(function(undefinedPropName) {\n                state[undefinedPropName] = undefined;\n            });\n        }\n        // We go through the setter here so that we convert the state object\n        // to an instance of `State`\n        component.state = state;\n    }\n\n    component.$__input = input;\n\n    if (componentProps) {\n        extend(component, componentProps);\n    }\n\n    var scope = extra.p;\n    var customEvents = extra.e;\n    if (customEvents) {\n        component.$__setCustomEvents(customEvents, scope);\n    }\n\n    return {\n        $__component: component,\n        $__roots: extra.r,\n        $__domEvents: extra.d\n    };\n};\n\nmodule.exports = ComponentDef;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/nextRepeatedId.js":"var REPEATED_ID_KEY = '$rep';\n\nmodule.exports = function nextRepeatedId(out, parentId, id) {\n    var nextIdLookup = out.global[REPEATED_ID_KEY] || (out.global[REPEATED_ID_KEY] = {});\n\n    var indexLookupKey = parentId + '-' + id;\n    var currentIndex = nextIdLookup[indexLookupKey];\n    if (currentIndex == null) {\n        currentIndex = nextIdLookup[indexLookupKey] = 0;\n    } else {\n        currentIndex = ++nextIdLookup[indexLookupKey];\n    }\n\n    return indexLookupKey.slice(0, -2) + '[' + currentIndex + ']';\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/registry.js":"'use strict';\nconst copyProps = require('raptor-util/copyProps');\nconst SERVER_WIDGET_KEY = Symbol();\n\nfunction createServerComponentClass(renderingLogic) {\n\n    class ServerComponent {\n        constructor(id, input, out, typeName, customEvents, scope) {\n            this.id = id;\n            this.$__customEvents = customEvents;\n            this.$__scope = scope;\n            this.$__updatedInput = undefined;\n            this.$__input = undefined;\n            this.$__state = undefined;\n            this.typeName = typeName;\n\n            if (this.onCreate) {\n                this.onCreate(input, out);\n            }\n\n            if (this.onInput) {\n                var updatedInput = this.onInput(input, out) || input;\n\n                if (this.$__input === undefined) {\n                    this.$__input = updatedInput;\n                }\n\n                this.$__updatedInput = updatedInput;\n            } else {\n                this.$__input = this.$__updatedInput = input;\n            }\n\n            if (this.onRender) {\n                this.onRender(out);\n            }\n        }\n\n        set input(newInput) {\n            this.$__input = newInput;\n        }\n\n        get input() {\n            return this.$__input;\n        }\n\n        set state(newState) {\n            this.$__state = newState;\n        }\n\n        get state() {\n            return this.$__state;\n        }\n\n        get $__rawState() {\n            return this.$__state;\n        }\n    }\n\n    var renderingLogicProps = typeof renderingLogic === 'function' ?\n        renderingLogic.prototype :\n        renderingLogic;\n\n\n    copyProps(renderingLogicProps, ServerComponent.prototype);\n\n    return ServerComponent;\n}\nfunction createComponent(renderingLogic, id, input, out, typeName, customEvents, scope) {\n    var ServerComponent = renderingLogic[SERVER_WIDGET_KEY];\n    if (!ServerComponent) {\n        ServerComponent = renderingLogic[SERVER_WIDGET_KEY] = createServerComponentClass(renderingLogic);\n    }\n\n    var component = new ServerComponent(id, input, out, typeName, customEvents, scope);\n    return component;\n}\n\nexports.$__isServer = true;\nexports.$__createComponent = createComponent;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/Component.js":"'use strict';\n/* jshint newcap:false */\n\nvar domInsert = require('../runtime/dom-insert');\nvar marko = require('../');\nvar componentsUtil = require('./util');\nvar componentLookup = componentsUtil.$__componentLookup;\nvar emitLifecycleEvent = componentsUtil.$__emitLifecycleEvent;\nvar destroyComponentForEl = componentsUtil.$__destroyComponentForEl;\nvar destroyElRecursive = componentsUtil.$__destroyElRecursive;\nvar getElementById = componentsUtil.$__getElementById;\nvar EventEmitter = require('events-light');\nvar RenderResult = require('../runtime/RenderResult');\nvar SubscriptionTracker = require('listener-tracker');\nvar inherit = require('raptor-util/inherit');\nvar updateManager = require('./update-manager');\nvar morphdom = require('../morphdom');\nvar eventDelegation = require('./event-delegation');\n\nvar slice = Array.prototype.slice;\n\nvar MORPHDOM_SKIP = true;\n\nvar COMPONENT_SUBSCRIBE_TO_OPTIONS;\nvar NON_COMPONENT_SUBSCRIBE_TO_OPTIONS = {\n    addDestroyListener: false\n};\n\nvar emit = EventEmitter.prototype.emit;\n\nfunction removeListener(removeEventListenerHandle) {\n    removeEventListenerHandle();\n}\n\nfunction checkCompatibleComponent(globalComponentsContext, el) {\n    var component = el._w;\n    while(component) {\n        var id = component.id;\n        var newComponentDef = globalComponentsContext.$__componentsById[id];\n        if (newComponentDef && component.$__type == newComponentDef.$__component.$__type) {\n            break;\n        }\n\n        var rootFor = component.$__rootFor;\n        if (rootFor)  {\n            component = rootFor;\n        } else {\n            component.$__destroyShallow();\n            break;\n        }\n    }\n}\n\nfunction handleCustomEventWithMethodListener(component, targetMethodName, args, extraArgs) {\n    // Remove the \"eventType\" argument\n    args.push(component);\n\n    if (extraArgs) {\n        args = extraArgs.concat(args);\n    }\n\n\n    var targetComponent = componentLookup[component.$__scope];\n    var targetMethod = targetComponent[targetMethodName];\n    if (!targetMethod) {\n        throw Error('Method not found: ' + targetMethodName);\n    }\n\n    targetMethod.apply(targetComponent, args);\n}\n\nfunction getElIdHelper(component, componentElId, index) {\n    var id = component.id;\n\n    var elId = componentElId != null ? id + '-' + componentElId : id;\n\n    if (index != null) {\n        elId += '[' + index + ']';\n    }\n\n    return elId;\n}\n\n/**\n * This method is used to process \"update_<stateName>\" handler functions.\n * If all of the modified state properties have a user provided update handler\n * then a rerender will be bypassed and, instead, the DOM will be updated\n * looping over and invoking the custom update handlers.\n * @return {boolean} Returns true if if the DOM was updated. False, otherwise.\n */\nfunction processUpdateHandlers(component, stateChanges, oldState) {\n    var handlerMethod;\n    var handlers;\n\n    for (var propName in stateChanges) {\n        if (stateChanges.hasOwnProperty(propName)) {\n            var handlerMethodName = 'update_' + propName;\n\n            handlerMethod = component[handlerMethodName];\n            if (handlerMethod) {\n                (handlers || (handlers=[])).push([propName, handlerMethod]);\n            } else {\n                // This state change does not have a state handler so return false\n                // to force a rerender\n                return;\n            }\n        }\n    }\n\n    // If we got here then all of the changed state properties have\n    // an update handler or there are no state properties that actually\n    // changed.\n    if (handlers) {\n        // Otherwise, there are handlers for all of the changed properties\n        // so apply the updates using those handlers\n\n        handlers.forEach(function(handler, i) {\n            var propertyName = handler[0];\n            handlerMethod = handler[1];\n\n            var newValue = stateChanges[propertyName];\n            var oldValue = oldState[propertyName];\n            handlerMethod.call(component, newValue, oldValue);\n        });\n\n        emitLifecycleEvent(component, 'update');\n\n        component.$__reset();\n    }\n\n    return true;\n}\n\nfunction checkInputChanged(existingComponent, oldInput, newInput) {\n    if (oldInput != newInput) {\n        if (oldInput == null || newInput == null) {\n            return true;\n        }\n\n        var oldKeys = Object.keys(oldInput);\n        var newKeys = Object.keys(newInput);\n        var len = oldKeys.length;\n        if (len !== newKeys.length) {\n            return true;\n        }\n\n        for (var i=0; i<len; i++) {\n            var key = oldKeys[i];\n            if (oldInput[key] !== newInput[key]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction onNodeDiscarded(node) {\n    if (node.nodeType === 1) {\n        destroyComponentForEl(node);\n    }\n}\n\nfunction onBeforeNodeDiscarded(node) {\n    return eventDelegation.$__handleNodeDetach(node);\n}\n\nfunction onBeforeElUpdated(fromEl, key, globalComponentsContext) {\n    if (key) {\n        var preserved = globalComponentsContext.$__preserved[key];\n\n        if (preserved === true) {\n            // Don't morph elements that are associated with components that are being\n            // reused or elements that are being preserved. For components being reused,\n            // the morphing will take place when the reused component updates.\n            return MORPHDOM_SKIP;\n        } else {\n            // We may need to destroy a Component associated with the current element\n            // if a new UI component was rendered to the same element and the types\n            // do not match\n            checkCompatibleComponent(globalComponentsContext, fromEl);\n        }\n    }\n}\n\nfunction onBeforeElChildrenUpdated(el, key, globalComponentsContext) {\n    if (key) {\n        var preserved = globalComponentsContext.$__preservedBodies[key];\n        if (preserved === true) {\n            // Don't morph the children since they are preserved\n            return MORPHDOM_SKIP;\n        }\n    }\n}\n\nfunction onNodeAdded(node, globalComponentsContext) {\n    eventDelegation.$__handleNodeAttach(node, globalComponentsContext.$__out);\n}\n\nvar componentProto;\n\n/**\n * Base component type.\n *\n * NOTE: Any methods that are prefixed with an underscore should be considered private!\n */\nfunction Component(id) {\n    EventEmitter.call(this);\n    this.id = id;\n    this.el = null;\n    this.$__state = null;\n    this.$__roots = null;\n    this.$__subscriptions = null;\n    this.$__domEventListenerHandles = null;\n    this.$__bubblingDomEvents = null;\n    this.$__customEvents = null;\n    this.$__scope = null;\n    this.$__renderInput = null;\n    this.$__input = undefined;\n\n    this.$__destroyed = false;\n    this.$__updateQueued = false;\n    this.$__dirty = false;\n    this.$__settingInput = false;\n\n    this.$__document = undefined;\n}\n\nComponent.prototype = componentProto = {\n    $__isComponent: true,\n\n    subscribeTo: function(target) {\n        if (!target) {\n            throw TypeError();\n        }\n\n        var subscriptions = this.$__subscriptions || (this.$__subscriptions = new SubscriptionTracker());\n\n        var subscribeToOptions = target.$__isComponent ?\n            COMPONENT_SUBSCRIBE_TO_OPTIONS :\n            NON_COMPONENT_SUBSCRIBE_TO_OPTIONS;\n\n        return subscriptions.subscribeTo(target, subscribeToOptions);\n    },\n\n    emit: function(eventType) {\n        var customEvents = this.$__customEvents;\n        var target;\n\n        if (customEvents && (target = customEvents[eventType])) {\n            var targetMethodName = target[0];\n            var extraArgs = target[1];\n            var args = slice.call(arguments, 1);\n\n            handleCustomEventWithMethodListener(this, targetMethodName, args, extraArgs);\n        }\n\n        if (this.listenerCount(eventType)) {\n            return emit.apply(this, arguments);\n        }\n    },\n    getElId: function (componentElId, index) {\n        return getElIdHelper(this, componentElId, index);\n    },\n    getEl: function (componentElId, index) {\n        var doc = this.$__document;\n\n        if (componentElId != null) {\n            return getElementById(doc, getElIdHelper(this, componentElId, index));\n        } else {\n            return this.el || getElementById(doc, getElIdHelper(this));\n        }\n    },\n    getEls: function(id) {\n        var els = [];\n        var i = 0;\n        var el;\n        while((el = this.getEl(id, i))) {\n            els.push(el);\n            i++;\n        }\n        return els;\n    },\n    getComponent: function(id, index) {\n        return componentLookup[getElIdHelper(this, id, index)];\n    },\n    getComponents: function(id) {\n        var components = [];\n        var i = 0;\n        var component;\n        while((component = componentLookup[getElIdHelper(this, id, i)])) {\n            components.push(component);\n            i++;\n        }\n        return components;\n    },\n    destroy: function() {\n        if (this.$__destroyed) {\n            return;\n        }\n\n        var els = this.els;\n\n        this.$__destroyShallow();\n\n        var rootComponents = this.$__rootComponents;\n        if (rootComponents) {\n            rootComponents.forEach(function(rootComponent) {\n                rootComponent.$__destroy();\n            });\n        }\n\n        els.forEach(function(el) {\n            destroyElRecursive(el);\n\n            var parentNode = el.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(el);\n            }\n        });\n    },\n\n    $__destroyShallow: function() {\n        if (this.$__destroyed) {\n            return;\n        }\n\n        emitLifecycleEvent(this, 'destroy');\n        this.$__destroyed = true;\n\n        this.el = null;\n\n        // Unsubscribe from all DOM events\n        this.$__removeDOMEventListeners();\n\n        var subscriptions = this.$__subscriptions;\n        if (subscriptions) {\n            subscriptions.removeAllListeners();\n            this.$__subscriptions = null;\n        }\n\n        delete componentLookup[this.id];\n    },\n\n    isDestroyed: function() {\n        return this.$__destroyed;\n    },\n    get state() {\n        return this.$__state;\n    },\n    set state(newState) {\n        var state = this.$__state;\n        if (!state && !newState) {\n            return;\n        }\n\n        if (!state) {\n            state = this.$__state = new this.$__State(this);\n        }\n\n        state.$__replace(newState || {});\n\n        if (state.$__dirty) {\n            this.$__queueUpdate();\n        }\n\n        if (!newState) {\n            this.$__state = null;\n        }\n    },\n    setState: function(name, value) {\n        var state = this.$__state;\n\n        if (typeof name == 'object') {\n            // Merge in the new state with the old state\n            var newState = name;\n            for (var k in newState) {\n                if (newState.hasOwnProperty(k)) {\n                    state.$__set(k, newState[k], true /* ensure:true */);\n                }\n            }\n        } else {\n            state.$__set(name, value, true /* ensure:true */);\n        }\n    },\n\n    setStateDirty: function(name, value) {\n        var state = this.$__state;\n\n        if (arguments.length == 1) {\n            value = state[name];\n        }\n\n        state.$__set(name, value, true /* ensure:true */, true /* forceDirty:true */);\n    },\n\n    replaceState: function(newState) {\n        this.$__state.$__replace(newState);\n    },\n\n    get input() {\n        return this.$__input;\n    },\n    set input(newInput) {\n        if (this.$__settingInput) {\n            this.$__input = newInput;\n        } else {\n            this.$__setInput(newInput);\n        }\n    },\n\n    $__setInput: function(newInput, onInput, out) {\n        onInput = onInput || this.onInput;\n        var updatedInput;\n\n        var oldInput = this.$__input;\n        this.$__input = undefined;\n\n        if (onInput) {\n            // We need to set a flag to preview `this.input = foo` inside\n            // onInput causing infinite recursion\n            this.$__settingInput = true;\n            updatedInput = onInput.call(this, newInput || {}, out);\n            this.$__settingInput = false;\n        }\n\n        newInput = this.$__renderInput = updatedInput || newInput;\n\n        if ((this.$__dirty = checkInputChanged(this, oldInput, newInput))) {\n            this.$__queueUpdate();\n        }\n\n        if (this.$__input === undefined) {\n            this.$__input = newInput;\n        }\n\n        return newInput;\n    },\n\n    forceUpdate: function() {\n        this.$__dirty = true;\n        this.$__queueUpdate();\n    },\n\n    $__queueUpdate: function() {\n        if (!this.$__updateQueued) {\n            updateManager.$__queueComponentUpdate(this);\n        }\n    },\n\n    update: function() {\n        if (this.$__destroyed === true || this.$__isDirty === false) {\n            return;\n        }\n\n        var input = this.$__input;\n        var state = this.$__state;\n\n        if (this.$__dirty === false && state !== null && state.$__dirty === true) {\n            if (processUpdateHandlers(this, state.$__changes, state.$__old, state)) {\n                state.$__dirty = false;\n            }\n        }\n\n        if (this.$__isDirty === true) {\n            // The UI component is still dirty after process state handlers\n            // then we should rerender\n\n            if (this.shouldUpdate(input, state) !== false) {\n                this.$__rerender();\n            }\n        }\n\n        this.$__reset();\n    },\n\n\n    get $__isDirty() {\n        return this.$__dirty === true || (this.$__state !== null && this.$__state.$__dirty === true);\n    },\n\n    $__reset: function() {\n        this.$__dirty = false;\n        this.$__updateQueued = false;\n        this.$__renderInput = null;\n        var state = this.$__state;\n        if (state) {\n            state.$__reset();\n        }\n    },\n\n    shouldUpdate: function(newState, newProps) {\n        return true;\n    },\n\n    $__emitLifecycleEvent: function(eventType, eventArg1, eventArg2) {\n        emitLifecycleEvent(this, eventType, eventArg1, eventArg2);\n    },\n\n    $__rerender: function(input) {\n        if (input) {\n            this.input = input;\n        }\n\n        var self = this;\n        var renderer = self.$__renderer;\n\n        if (!renderer) {\n            throw TypeError();\n        }\n\n        var globalData = {\n            $w: self\n        };\n\n        var fromEls = self.$__getRootEls({});\n        var doc = self.$__document;\n        input = this.$__renderInput || this.$__input;\n\n        updateManager.$__batchUpdate(function() {\n            var createOut = renderer.createOut || marko.createOut;\n            var out = createOut(globalData);\n            out.sync();\n            out.$__document = self.$__document;\n            renderer(input, out);\n            var result = new RenderResult(out);\n            var targetNode = out.$__getOutput();\n\n            var globalComponentsContext = out.global.components;\n\n            var fromEl;\n\n            var targetEl = targetNode.firstChild;\n            while(targetEl) {\n                var id = targetEl.id;\n\n                if (id) {\n                    fromEl = fromEls[id];\n                    if (fromEl) {\n                        morphdom(\n                            fromEl,\n                            targetEl,\n                            globalComponentsContext,\n                            onNodeAdded,\n                            onBeforeElUpdated,\n                            onBeforeNodeDiscarded,\n                            onNodeDiscarded,\n                            onBeforeElChildrenUpdated);\n                    }\n                }\n\n                targetEl = targetEl.nextSibling;\n            }\n\n            result.afterInsert(doc);\n\n            out.emit('$__componentsInitialized');\n        });\n\n        this.$__reset();\n    },\n\n    $__getRootEls: function(rootEls) {\n        var i, len;\n\n        var componentEls = this.els;\n\n        for (i=0, len=componentEls.length; i<len; i++) {\n            var componentEl = componentEls[i];\n            rootEls[componentEl.id] = componentEl;\n        }\n\n        var rootComponents = this.$__rootComponents;\n        if (rootComponents) {\n            for (i=0, len=rootComponents.length; i<len; i++) {\n                var rootComponent = rootComponents[i];\n                rootComponent.$__getRootEls(rootEls);\n            }\n        }\n\n        return rootEls;\n    },\n\n    $__removeDOMEventListeners: function() {\n        var eventListenerHandles = this.$__domEventListenerHandles;\n        if (eventListenerHandles) {\n            eventListenerHandles.forEach(removeListener);\n            this.$__domEventListenerHandles = null;\n        }\n    },\n\n    get $__rawState() {\n        var state = this.$__state;\n        return state && state.$__raw;\n    },\n\n    $__setCustomEvents: function(customEvents, scope) {\n        var finalCustomEvents = this.$__customEvents = {};\n        this.$__scope = scope;\n\n        customEvents.forEach(function(customEvent) {\n            var eventType = customEvent[0];\n            var targetMethodName = customEvent[1];\n            var extraArgs = customEvent[2];\n\n            finalCustomEvents[eventType] = [targetMethodName, extraArgs];\n        });\n    }\n};\n\ncomponentProto.elId = componentProto.getElId;\ncomponentProto.$__update = componentProto.update;\ncomponentProto.$__destroy = componentProto.destroy;\n\n// Add all of the following DOM methods to Component.prototype:\n// - appendTo(referenceEl)\n// - replace(referenceEl)\n// - replaceChildrenOf(referenceEl)\n// - insertBefore(referenceEl)\n// - insertAfter(referenceEl)\n// - prependTo(referenceEl)\ndomInsert(\n    componentProto,\n    function getEl(component) {\n        var els = this.els;\n        var elCount = els.length;\n        if (elCount > 1) {\n            var fragment = component.$__document.createDocumentFragment();\n            els.forEach(function(el) {\n                fragment.appendChild(el);\n            });\n            return fragment;\n        } else {\n            return els[0];\n        }\n    },\n    function afterInsert(component) {\n        return component;\n    });\n\ninherit(Component, EventEmitter);\n\nmodule.exports = Component;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/update-manager.js":"'use strict';\n\nvar updatesScheduled = false;\nvar batchStack = []; // A stack of batched updates\nvar unbatchedQueue = []; // Used for scheduled batched updates\n\nvar nextTick = require('../runtime/nextTick');\n\n/**\n * This function is called when we schedule the update of \"unbatched\"\n * updates to components.\n */\nfunction updateUnbatchedComponents() {\n    if (unbatchedQueue.length) {\n        try {\n            updateComponents(unbatchedQueue);\n        } finally {\n            // Reset the flag now that this scheduled batch update\n            // is complete so that we can later schedule another\n            // batched update if needed\n            updatesScheduled = false;\n        }\n    }\n}\n\nfunction scheduleUpdates() {\n    if (updatesScheduled) {\n        // We have already scheduled a batched update for the\n        // process.nextTick so nothing to do\n        return;\n    }\n\n    updatesScheduled = true;\n\n    nextTick(updateUnbatchedComponents);\n}\n\nfunction updateComponents(queue) {\n    // Loop over the components in the queue and update them.\n    // NOTE: It is okay if the queue grows during the iteration\n    //       since we will still get to them at the end\n    for (var i=0; i<queue.length; i++) {\n        var component = queue[i];\n        component.$__update(); // Do the actual component update\n    }\n\n    // Clear out the queue by setting the length to zero\n    queue.length = 0;\n}\n\nfunction batchUpdate(func) {\n    // If the batched update stack is empty then this\n    // is the outer batched update. After the outer\n    // batched update completes we invoke the \"afterUpdate\"\n    // event listeners.\n    var batch = {\n        $__queue: null\n    };\n\n    batchStack.push(batch);\n\n    try {\n        func();\n    } finally {\n        try {\n            // Update all of the components that where queued up\n            // in this batch (if any)\n            if (batch.$__queue) {\n                updateComponents(batch.$__queue);\n            }\n        } finally {\n            // Now that we have completed the update of all the components\n            // in this batch we need to remove it off the top of the stack\n            batchStack.length--;\n        }\n    }\n}\n\nfunction queueComponentUpdate(component) {\n    var batchStackLen = batchStack.length;\n\n    if (batchStackLen) {\n        // When a batch update is started we push a new batch on to a stack.\n        // If the stack has a non-zero length then we know that a batch has\n        // been started so we can just queue the component on the top batch. When\n        // the batch is ended this component will be updated.\n        var batch = batchStack[batchStackLen-1];\n\n        // We default the batch queue to null to avoid creating an Array instance\n        // unnecessarily. If it is null then we create a new Array, otherwise\n        // we push it onto the existing Array queue\n        if (batch.$__queue) {\n            batch.$__queue.push(component);\n        } else {\n            batch.$__queue = [component];\n        }\n    } else {\n        // We are not within a batched update. We need to schedule a batch update\n        // for the process.nextTick (if that hasn't been done already) and we will\n        // add the component to the unbatched queued\n        scheduleUpdates();\n        unbatchedQueue.push(component);\n    }\n}\n\nexports.$__queueComponentUpdate = queueComponentUpdate;\nexports.$__batchUpdate = batchUpdate;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/nextTick.js":"module.exports = process.nextTick;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/morphdom/index.js":"'use strict';\nvar defaultDoc = typeof document == 'undefined' ? undefined : document;\nvar specialElHandlers = require('./specialElHandlers');\n\nvar morphAttrs = require('../runtime/vdom/VElement').$__morphAttrs;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction compareNodeNames(fromEl, toEl) {\n    return fromEl.nodeName === toEl.$__nodeName;\n}\n\n\nfunction getElementById(doc, id) {\n    return doc.getElementById(id);\n}\n\nfunction morphdom(\n        fromNode,\n        toNode,\n        context,\n        onNodeAdded,\n        onBeforeElUpdated,\n        onBeforeNodeDiscarded,\n        onNodeDiscarded,\n        onBeforeElChildrenUpdated\n    ) {\n\n    var doc = fromNode.ownerDocument || defaultDoc;\n\n    // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n    var removalList = [];\n    var foundKeys = {};\n\n    function walkDiscardedChildNodes(node) {\n        onNodeDiscarded(node);\n        var curChild = node.firstChild;\n\n        while (curChild) {\n            walkDiscardedChildNodes(curChild);\n            curChild = curChild.nextSibling;\n        }\n    }\n\n\n    function addVirtualNode(vEl, parentEl) {\n        var realEl = vEl.$__actualize(doc);\n\n        if (parentEl) {\n            parentEl.appendChild(realEl);\n        }\n\n        onNodeAdded(realEl, context);\n\n        var vCurChild = vEl.firstChild;\n        while (vCurChild) {\n            var realCurChild = null;\n\n            var key = vCurChild.id;\n            if (key) {\n                var unmatchedFromEl = getElementById(doc, key);\n                if (unmatchedFromEl && compareNodeNames(vCurChild, unmatchedFromEl)) {\n                    morphEl(unmatchedFromEl, vCurChild, false);\n                    realEl.appendChild(realCurChild = unmatchedFromEl);\n                }\n            }\n\n            if (!realCurChild) {\n                addVirtualNode(vCurChild, realEl);\n            }\n\n            vCurChild = vCurChild.nextSibling;\n        }\n\n        if (vEl.$__nodeType === 1) {\n            var elHandler = specialElHandlers[vEl.nodeName];\n            if (elHandler !== undefined) {\n                elHandler(realEl, vEl);\n            }\n        }\n\n        return realEl;\n    }\n\n    function morphEl(fromEl, toEl, childrenOnly) {\n        var toElKey = toEl.id;\n        var nodeName = toEl.$__nodeName;\n\n        if (childrenOnly === false) {\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                foundKeys[toElKey] = true;\n            }\n\n            var constId = toEl.$__constId;\n            if (constId !== undefined) {\n                var otherProps = fromEl._vprops;\n                if (otherProps !== undefined && constId === otherProps.c) {\n                    return;\n                }\n            }\n\n            if (onBeforeElUpdated(fromEl, toElKey, context) === true) {\n                return;\n            }\n\n            morphAttrs(fromEl, toEl);\n        }\n\n\n        if (onBeforeElChildrenUpdated(fromEl, toElKey, context) === true) {\n            return;\n        }\n\n        if (nodeName !== 'TEXTAREA') {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = curToNodeChild.id;\n\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    curFromNodeKey = curFromNodeChild.id;\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.$__nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = getElementById(doc, curToNodeKey))) {\n                                        if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's moving the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n\n\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            var curToNodeChildNextSibling = curToNodeChild.nextSibling;\n                                            if (curToNodeChildNextSibling && curToNodeChildNextSibling.id === curFromNodeKey) {\n                                                fromNextSibling = curFromNodeChild;\n                                            } else {\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n                                                removalList.push(curFromNodeChild);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild) === true;\n\n                            if (isCompatible === true) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                morphEl(curFromNodeChild, curToNodeChild, false);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType === COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                        }\n                    }\n\n                    if (isCompatible === true) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    removalList.push(curFromNodeChild);\n\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = getElementById(doc, curToNodeKey)) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    morphEl(matchingFromEl, curToNodeChild, false);\n                } else {\n                    addVirtualNode(curToNodeChild, fromEl);\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                removalList.push(curFromNodeChild);\n                curFromNodeChild = curFromNodeChild.nextSibling;\n            }\n        }\n\n        var specialElHandler = specialElHandlers[nodeName];\n        if (specialElHandler) {\n            specialElHandler(fromEl, toEl);\n        }\n    } // END: morphEl(...)\n\n    var morphedNode = fromNode;\n    var fromNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.$__nodeType;\n    var morphChildrenOnly = false;\n    var shouldMorphEl = true;\n    var newNode;\n\n    // Handle the case where we are given two DOM nodes that are not\n    // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n    if (fromNodeType == ELEMENT_NODE) {\n        if (toNodeType == ELEMENT_NODE) {\n            if (!compareNodeNames(fromNode, toNode)) {\n                newNode = toNode.$__actualize(doc);\n                morphChildrenOnly = true;\n                removalList.push(fromNode);\n            }\n        } else {\n            // Going from an element node to a text or comment node\n            removalList.push(fromNode);\n            newNode = toNode.$__actualize(doc);\n            shouldMorphEl = false;\n        }\n    } else if (fromNodeType == TEXT_NODE || fromNodeType == COMMENT_NODE) { // Text or comment node\n        if (toNodeType == fromNodeType) {\n            morphedNode.nodeValue = toNode.nodeValue;\n            return morphedNode;\n        } else {\n            // Text node to something else\n            removalList.push(fromNode);\n            newNode = addVirtualNode(toNode);\n            shouldMorphEl = false;\n        }\n    }\n\n    if (shouldMorphEl === true) {\n        morphEl(newNode || morphedNode, toNode, morphChildrenOnly);\n    }\n\n    if (newNode) {\n        if (fromNode.parentNode) {\n            fromNode.parentNode.replaceChild(newNode, fromNode);\n        }\n    }\n\n    // We now need to loop over any keyed nodes that might need to be\n    // removed. We only do the removal if we know that the keyed node\n    // never found a match. When a keyed node is matched up we remove\n    // it out of fromNodesLookup and we use fromNodesLookup to determine\n    // if a keyed node has been matched up or not\n    for (var i=0, len=removalList.length; i<len; i++) {\n        var node = removalList[i];\n        var key = node.id;\n        if (!key || foundKeys[key] === undefined) {\n            if (onBeforeNodeDiscarded(node) == false) {\n                continue;\n            }\n\n            var parentNode = node.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            walkDiscardedChildNodes(node);\n        }\n    }\n\n    return newNode || morphedNode;\n}\n\nmodule.exports = morphdom;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/ComponentsContext.js":"'use strict';\n\nvar ComponentDef = require('./ComponentDef');\nvar initComponents = require('./init-components');\nvar EMPTY_OBJECT = {};\n\nfunction GlobalComponentsContext(out) {\n    this.$__roots = [];\n    this.$__preserved = EMPTY_OBJECT;\n    this.$__preservedBodies = EMPTY_OBJECT;\n    this.$__componentsById = {};\n    this.$__out = out;\n}\n\nGlobalComponentsContext.prototype = {\n    $__initComponents: function (doc) {\n        var topLevelComponentDefs = null;\n\n        this.$__roots.forEach(function(root) {\n            var children = root.$__children;\n            if (children) {\n                initComponents.$__initClientRendered(children, doc);\n                if (topLevelComponentDefs === null) {\n                    topLevelComponentDefs = children;\n                } else {\n                    topLevelComponentDefs = topLevelComponentDefs.concat(children);\n                }\n            }\n        });\n\n        this.$__roots = null;\n\n        return topLevelComponentDefs;\n    },\n    $__preserveDOMNode: function(elId, bodyOnly) {\n        var preserved = bodyOnly === true ? this.$__preservedBodies : this.$__preserved;\n        if (preserved === EMPTY_OBJECT) {\n            if (bodyOnly === true) {\n                preserved = this.$__preservedBodies = {};\n            } else {\n                preserved = this.$__preserved = {};\n            }\n        }\n        preserved[elId] = true;\n    }\n};\n\nfunction ComponentsContext(out, parentComponentsContext, shouldAddGlobalRoot) {\n    var root;\n\n    var globalComponentsContext;\n\n    if (parentComponentsContext === undefined) {\n        root = new ComponentDef(null, null, out);\n\n        globalComponentsContext = out.global.components;\n        if (globalComponentsContext === undefined) {\n            out.global.components = globalComponentsContext = new GlobalComponentsContext(out);\n        }\n\n        if (shouldAddGlobalRoot !== false) {\n            globalComponentsContext.$__roots.push(root);\n        }\n    } else {\n        globalComponentsContext = parentComponentsContext.$__globalContext;\n        var parentComponentStack = parentComponentsContext.$__componentStack;\n        root = parentComponentStack[parentComponentStack.length-1];\n    }\n\n    this.$__globalContext = globalComponentsContext;\n    this.$__out = out;\n    this.$__componentStack = [root];\n}\n\nComponentsContext.prototype = {\n    $__createNestedComponentsContext: function(nestedOut) {\n        return new ComponentsContext(nestedOut, this);\n    },\n    $__beginComponent: function(component) {\n        var componentStack = this.$__componentStack;\n        var origLength = componentStack.length;\n        var parent = componentStack[origLength - 1];\n\n        var componentId = component.id;\n\n        if (!componentId) {\n            componentId = component.id = parent.$__nextId();\n        }\n\n        var componentDef = new ComponentDef(component, componentId, this.$__out, componentStack, origLength);\n        this.$__globalContext.$__componentsById[componentId] = componentDef;\n        parent.$__addChild(componentDef);\n        componentStack.push(componentDef);\n\n        return componentDef;\n    },\n\n    $__nextComponentId: function() {\n        var componentStack = this.$__componentStack;\n        var parent = componentStack[componentStack.length - 1];\n        return parent.$__nextId();\n    }\n};\n\nfunction getComponentsContext(out) {\n    return out.data.components || (out.data.components = new ComponentsContext(out));\n}\n\nmodule.exports = exports = ComponentsContext;\n\nexports.$__getComponentsContext = getComponentsContext;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/defineComponent.js":"'use strict';\n/* jshint newcap:false */\n\nvar BaseState = require('./State');\nvar BaseComponent = require('./Component');\nvar inherit = require('raptor-util/inherit');\n\nmodule.exports = function defineComponent(def, renderer) {\n    if (def.$__isComponent) {\n        return def;\n    }\n\n    var ComponentClass = function() {};\n    var proto;\n\n    var type = typeof def;\n\n    if (type == 'function') {\n        proto = def.prototype;\n    } else if (type == 'object') {\n        proto = def;\n    } else {\n        throw TypeError();\n    }\n\n    ComponentClass.prototype = proto;\n\n    // We don't use the constructor provided by the user\n    // since we don't invoke their constructor until\n    // we have had a chance to do our own initialization.\n    // Instead, we store their constructor in the \"initComponent\"\n    // property and that method gets called later inside\n    // init-components-browser.js\n    function Component(id) {\n        BaseComponent.call(this, id);\n    }\n\n    if (!proto.$__isComponent) {\n        // Inherit from Component if they didn't already\n        inherit(ComponentClass, BaseComponent);\n    }\n\n    // The same prototype will be used by our constructor after\n    // we he have set up the prototype chain using the inherit function\n    proto = Component.prototype = ComponentClass.prototype;\n\n    // proto.constructor = def.constructor = Component;\n\n    // Set a flag on the constructor function to make it clear this is\n    // a component so that we can short-circuit this work later\n    Component.$__isComponent = true;\n\n    function State(component) { BaseState.call(this, component); }\n    inherit(State, BaseState);\n    proto.$__State = State;\n    proto.$__renderer = renderer;\n\n    return Component;\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/State.js":"var extend = require('raptor-util/extend');\n\nfunction ensure(state, propertyName) {\n    var proto = state.constructor.prototype;\n    if (!(propertyName in proto)) {\n        Object.defineProperty(proto, propertyName, {\n            get: function() {\n                return this.$__raw[propertyName];\n            },\n            set: function(value) {\n                this.$__set(propertyName, value, false /* ensure:false */);\n            }\n        });\n    }\n}\n\nfunction State(component) {\n    this.$__component = component;\n    this.$__raw = {};\n\n    this.$__dirty = false;\n    this.$__old = null;\n    this.$__changes = null;\n    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty\n\n    Object.seal(this);\n}\n\nState.prototype = {\n    $__reset: function() {\n        var self = this;\n\n        self.$__dirty = false;\n        self.$__old = null;\n        self.$__changes = null;\n        self.$__forced = null;\n    },\n\n    $__replace: function(newState) {\n        var state = this;\n        var key;\n\n        var rawState = this.$__raw;\n\n        for (key in rawState) {\n            if (!(key in newState)) {\n                state.$__set(key, undefined, false /* ensure:false */, false /* forceDirty:false */);\n            }\n        }\n\n        for (key in newState) {\n            state.$__set(key, newState[key], true /* ensure:true */, false /* forceDirty:false */);\n        }\n    },\n    $__set: function(name, value, shouldEnsure, forceDirty) {\n        var rawState = this.$__raw;\n\n        if (shouldEnsure) {\n            ensure(this, name);\n        }\n\n        if (forceDirty) {\n            var forcedDirtyState = this.$__forced || (this.$__forced = {});\n            forcedDirtyState[name] = true;\n        } else if (rawState[name] === value) {\n            return;\n        }\n\n        if (!this.$__dirty) {\n            // This is the first time we are modifying the component state\n            // so introduce some properties to do some tracking of\n            // changes to the state\n            this.$__dirty = true; // Mark the component state as dirty (i.e. modified)\n            this.$__old = rawState;\n            this.$__raw = rawState = extend({}, rawState);\n            this.$__changes = {};\n            this.$__component.$__queueUpdate();\n        }\n\n        this.$__changes[name] = value;\n\n        if (value === undefined) {\n            // Don't store state properties with an undefined or null value\n            delete rawState[name];\n        } else {\n            // Otherwise, store the new value in the component state\n            rawState[name] = value;\n        }\n    },\n    toJSON: function() {\n        return this.$__raw;\n    }\n};\n\nmodule.exports = State;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/index-browser.js":"var componentsUtil = require('./util');\nvar events = require('../runtime/events');\nvar Component = require('./Component');\n\nfunction onInitComponent(listener) {\n    events.on('initComponent', listener);\n}\n\nexports.onInitComponent = onInitComponent;\nexports.Component = Component;\nexports.getComponentForEl = componentsUtil.$__getComponentForEl;\nexports.init = require('./init-components').$__initServerRendered;\n\nexports.c = require('./defineComponent'); // Referenced by compiled templates\nexports.r = require('./renderer'); // Referenced by compiled templates\nexports.rc = require('./registry').$__register;  // Referenced by compiled templates\n\nwindow.$__MARKO_COMPONENTS = exports; // Helpful when debugging... WARNING: DO NOT USE IN REAL CODE!\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/renderer.js":"var componentsUtil = require('./util');\nvar componentLookup = componentsUtil.$__componentLookup;\nvar emitLifecycleEvent = componentsUtil.$__emitLifecycleEvent;\n\nvar ComponentsContext = require('./ComponentsContext');\nvar getComponentsContext = ComponentsContext.$__getComponentsContext;\n\nvar nextRepeatedId = require('./nextRepeatedId');\nvar repeatedRegExp = /\\[\\]$/;\nvar registry = require('./registry');\nvar copyProps = require('raptor-util/copyProps');\n\nvar COMPONENT_BEGIN_ASYNC_ADDED_KEY = '$wa';\n\nfunction resolveComponentKey(out, key, scope) {\n    if (key[0] == '#') {\n        return key.substring(1);\n    } else {\n        var resolvedId;\n\n        if (repeatedRegExp.test(key)) {\n            resolvedId = nextRepeatedId(out, scope, key);\n        } else {\n            resolvedId = scope + '-' + key;\n        }\n\n        return resolvedId;\n    }\n}\n\nfunction preserveComponentEls(existingComponent, out, componentsContext) {\n    var rootEls = existingComponent.$__getRootEls({});\n\n    for (var elId in rootEls) {\n        var el = rootEls[elId];\n\n        // We put a placeholder element in the output stream to ensure that the existing\n        // DOM node is matched up correctly when using morphdom.\n        out.element(el.tagName, { id: elId });\n\n        componentsContext.$__globalContext.$__preserveDOMNode(elId); // Mark the element as being preserved (for morphdom)\n    }\n\n    existingComponent.$__reset(); // The component is no longer dirty so reset internal flags\n    return true;\n}\n\nfunction handleBeginAsync(event) {\n    var parentOut = event.parentOut;\n    var asyncOut = event.out;\n    var componentsContext = parentOut.data.components;\n\n    if (componentsContext !== undefined) {\n        // All of the components in this async block should be\n        // initialized after the components in the parent. Therefore,\n        // we will create a new ComponentsContext for the nested\n        // async block and will create a new component stack where the current\n        // component in the parent block is the only component in the nested\n        // stack (to begin with). This will result in top-level components\n        // of the async block being added as children of the component in the\n        // parent block.\n        var nestedComponentsContext = componentsContext.$__createNestedComponentsContext(asyncOut);\n        asyncOut.data.components = nestedComponentsContext;\n    }\n\n    // Carry along the component arguments\n    asyncOut.$c = parentOut.$c;\n}\n\nfunction createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {\n    renderingLogic = renderingLogic || {};\n    var onInput = renderingLogic.onInput;\n    var typeName = componentProps.type;\n    var roots = componentProps.roots;\n    var assignedId = componentProps.id;\n    var split = componentProps.split;\n\n    return function renderer(input, out) {\n        var outGlobal = out.global;\n\n        if (out.isSync() === false) {\n            if (!outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {\n                outGlobal[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;\n                out.on('beginAsync', handleBeginAsync);\n            }\n        }\n\n        var component = outGlobal.$w;\n        var isRerender = component !== undefined;\n        var id = assignedId;\n        var isExisting;\n        var customEvents;\n        var scope;\n\n        if (component) {\n            id = component.id;\n            isExisting = true;\n            outGlobal.$w = null;\n        } else {\n            var componentArgs = out.$c;\n\n            if (componentArgs) {\n                out.$c = null;\n\n                scope = componentArgs[0];\n\n                if (scope) {\n                    scope = scope.id;\n                }\n\n                var key = componentArgs[1];\n                if (key != null) {\n                    key = key.toString();\n                }\n                id = id || resolveComponentKey(out, key, scope);\n                customEvents = componentArgs[2];\n            }\n        }\n\n        var componentsContext = getComponentsContext(out);\n        id = id || componentsContext.$__nextComponentId();\n\n        if (registry.$__isServer) {\n            component = registry.$__createComponent(\n                renderingLogic,\n                id,\n                input,\n                out,\n                typeName,\n                customEvents,\n                scope);\n            input = component.$__updatedInput;\n            component.$__updatedInput = undefined; // We don't want $__updatedInput to be serialized to the browser\n        } else {\n            if (!component) {\n                if (isRerender) {\n                    // Look in in the DOM to see if a component with the same ID and type already exists.\n                    component = componentLookup[id];\n                    if (component && component.$__type !== typeName) {\n                        component = undefined;\n                    }\n                }\n\n                if (component) {\n                    isExisting = true;\n                } else {\n                    isExisting = false;\n                    // We need to create a new instance of the component\n                    component = registry.$__createComponent(typeName, id);\n\n                    if (split) {\n                        split = false;\n\n                        var renderingLogicProps = typeof renderingLogic == 'function' ?\n                            renderingLogic.prototype :\n                            renderingLogic;\n\n                        copyProps(renderingLogicProps, component.constructor.prototype);\n                    }\n                }\n\n                // Set this flag to prevent the component from being queued for update\n                // based on the new input. The component is about to be rerendered\n                // so we don't want to queue it up as a result of calling `setInput()`\n                component.$__updateQueued = true;\n\n                if (customEvents !== undefined) {\n                    component.$__setCustomEvents(customEvents, scope);\n                }\n\n\n                if (isExisting === false) {\n                    emitLifecycleEvent(component, 'create', input, out);\n                }\n\n                input = component.$__setInput(input, onInput, out);\n\n                if (isExisting === true) {\n                    if (component.$__isDirty === false || component.shouldUpdate(input, component.$__state) === false) {\n                        preserveComponentEls(component, out, componentsContext);\n                        return;\n                    }\n                }\n            }\n\n            emitLifecycleEvent(component, 'render', out);\n        }\n\n        var componentDef = componentsContext.$__beginComponent(component);\n        componentDef.$__roots = roots;\n        componentDef.$__isExisting = isExisting;\n\n        // Render the template associated with the component using the final template\n        // data that we constructed\n        templateRenderFunc(input, out, componentDef, component, component.$__rawState);\n\n        componentDef.$__end();\n    };\n}\n\nmodule.exports = createRendererFunc;\n\n// exports used by the legacy renderer\ncreateRendererFunc.$__resolveComponentKey = resolveComponentKey;\ncreateRendererFunc.$__preserveComponentEls = preserveComponentEls;\ncreateRendererFunc.$__handleBeginAsync = handleBeginAsync;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/init-components-browser.js":"'use strict';\nvar warp10Finalize = require('warp10/finalize');\nvar eventDelegation = require('./event-delegation');\nvar win = window;\nvar defaultDocument = document;\nvar events = require('../runtime/events');\nvar componentsUtil = require('./util');\nvar componentLookup = componentsUtil.$__componentLookup;\nvar getElementById = componentsUtil.$__getElementById;\nvar ComponentDef = require('./ComponentDef');\n\nfunction invokeComponentEventHandler(component, targetMethodName, args) {\n    var method = component[targetMethodName];\n    if (!method) {\n        throw Error('Method not found: ' + targetMethodName);\n    }\n\n    method.apply(component, args);\n}\n\nfunction addEventListenerHelper(el, eventType, listener) {\n    el.addEventListener(eventType, listener, false);\n    return function remove() {\n        el.removeEventListener(eventType, listener);\n    };\n}\n\nfunction addDOMEventListeners(component, el, eventType, targetMethodName, extraArgs, handles) {\n    var removeListener = addEventListenerHelper(el, eventType, function(event) {\n        var args = [event, el];\n        if (extraArgs) {\n            args = extraArgs.concat(args);\n        }\n\n        invokeComponentEventHandler(component, targetMethodName, args);\n    });\n    handles.push(removeListener);\n}\n\nfunction initComponent(componentDef, doc) {\n    var component = componentDef.$__component;\n\n    if (!component || !component.$__isComponent) {\n        return; // legacy\n    }\n\n    var domEvents = componentDef.$__domEvents;\n\n    component.$__reset();\n    component.$__document = doc;\n\n    var isExisting = componentDef.$__isExisting;\n    var id = component.id;\n\n    var rootIds = componentDef.$__roots;\n\n    if (rootIds) {\n        var rootComponents;\n\n        var els = [];\n\n        rootIds.forEach(function(rootId) {\n            var nestedId = id + '-' + rootId;\n            var rootComponent = componentLookup[nestedId];\n            if (rootComponent) {\n                rootComponent.$__rootFor = component;\n                if (rootComponents) {\n                    rootComponents.push(rootComponent);\n                } else {\n                    rootComponents = component.$__rootComponents = [rootComponent];\n                }\n            } else {\n                var rootEl = getElementById(doc, nestedId);\n                if (rootEl) {\n                    rootEl._w = component;\n                    els.push(rootEl);\n                }\n            }\n        });\n\n        component.el = els[0];\n        component.els = els;\n        componentLookup[id] = component;\n    } else if (!isExisting) {\n        var el = getElementById(doc, id);\n        el._w = component;\n        component.el = el;\n        component.els = [el];\n        componentLookup[id] = component;\n    }\n\n    if (isExisting) {\n        component.$__removeDOMEventListeners();\n    }\n\n    if (domEvents) {\n        var eventListenerHandles = [];\n\n        domEvents.forEach(function(domEventArgs) {\n            // The event mapping is for a direct DOM event (not a custom event and not for bubblign dom events)\n\n            var eventType = domEventArgs[0];\n            var targetMethodName = domEventArgs[1];\n            var eventEl = getElementById(doc, domEventArgs[2]);\n            var extraArgs = domEventArgs[3];\n\n            addDOMEventListeners(component, eventEl, eventType, targetMethodName, extraArgs, eventListenerHandles);\n        });\n\n        if (eventListenerHandles.length) {\n            component.$__domEventListenerHandles = eventListenerHandles;\n        }\n    }\n\n    if (isExisting) {\n        component.$__emitLifecycleEvent('update');\n    } else {\n        events.emit('mountComponent', component);\n        component.$__emitLifecycleEvent('mount');\n    }\n}\n\n/**\n * This method is used to initialized components associated with UI components\n * rendered in the browser. While rendering UI components a \"components context\"\n * is added to the rendering context to keep up with which components are rendered.\n * When ready, the components can then be initialized by walking the component tree\n * in the components context (nested components are initialized before ancestor components).\n * @param  {Array<marko-components/lib/ComponentDef>} componentDefs An array of ComponentDef instances\n */\nfunction initClientRendered(componentDefs, doc) {\n    // Ensure that event handlers to handle delegating events are\n    // always attached before initializing any components\n    eventDelegation.$__init(doc);\n\n    doc = doc || defaultDocument;\n    for (var i=0,len=componentDefs.length; i<len; i++) {\n        var componentDef = componentDefs[i];\n\n        if (componentDef.$__children) {\n            initClientRendered(componentDef.$__children, doc);\n        }\n\n        initComponent(\n            componentDef,\n            doc);\n    }\n}\n\n/**\n * This method initializes all components that were rendered on the server by iterating over all\n * of the component IDs.\n */\nfunction initServerRendered(renderedComponents, doc) {\n    if (!renderedComponents) {\n        renderedComponents = win.$components;\n\n        if (renderedComponents) {\n            if (renderedComponents.forEach) {\n                renderedComponents.forEach(function(renderedComponent) {\n                    initServerRendered(renderedComponent, doc);\n                });\n            }\n        } else {\n            win.$components = {\n                concat: initServerRendered\n            };\n        }\n        return;\n    }\n    // Ensure that event handlers to handle delegating events are\n    // always attached before initializing any components\n    eventDelegation.$__init(doc || defaultDocument);\n\n    renderedComponents = warp10Finalize(renderedComponents);\n\n    var componentDefs = renderedComponents.w;\n    var typesArray = renderedComponents.t;\n\n    componentDefs.forEach(function(componentDef) {\n        componentDef = ComponentDef.$__deserialize(componentDef, typesArray);\n        initComponent(componentDef, doc || defaultDocument);\n    });\n}\n\nexports.$__initClientRendered = initClientRendered;\nexports.$__initServerRendered = initServerRendered;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/loadComponent-dynamic.js":"'use strict';\n\nmodule.exports = function load(typeName) {\n    // We make the assumption that the component type name is a path to a\n    // fully resolved module path and that the module exists\n    // as a CommonJS module\n    return require(typeName);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/loadComponent.js":"'use strict';\nmodule.exports = function load(typeName) {\n    throw new Error('Not found: ' + typeName);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/registry-browser.js":"var loadComponent = require('./loadComponent');\nvar defineComponent = require('./defineComponent');\n\nvar registered = {};\nvar loaded = {};\nvar componentTypes = {};\n\nfunction register(typeName, def) {\n    // We do this to kick off registering of nested components\n    // but we don't use the return value just yet since there\n    // is a good chance that it resulted in a circular dependency\n    def();\n\n    registered[typeName] = def;\n    delete loaded[typeName];\n    delete componentTypes[typeName];\n    return typeName;\n}\n\nfunction load(typeName) {\n    var target = loaded[typeName];\n    if (!target) {\n        target = registered[typeName];\n\n        if (target) {\n            target = target();\n        } else {\n            target = loadComponent(typeName); // Assume the typeName has been fully resolved already\n        }\n\n        if (!target) {\n            throw Error('Not found: ' + typeName);\n        }\n\n        loaded[typeName] = target;\n    }\n\n    return target;\n}\n\nfunction getComponentClass(typeName) {\n    var ComponentClass = componentTypes[typeName];\n\n    if (ComponentClass) {\n        return ComponentClass;\n    }\n\n    ComponentClass = load(typeName);\n\n    ComponentClass = ComponentClass.Component || ComponentClass;\n\n    if (!ComponentClass.$__isComponent) {\n        ComponentClass = defineComponent(ComponentClass, ComponentClass.renderer);\n    }\n\n    // Make the component \"type\" accessible on each component instance\n    ComponentClass.prototype.$__type = typeName;\n\n    componentTypes[typeName] = ComponentClass;\n\n    return ComponentClass;\n}\n\nfunction createComponent(typeName, id) {\n    var ComponentClass = getComponentClass(typeName);\n    return new ComponentClass(id);\n}\n\nexports.$__register = register;\nexports.$__createComponent = createComponent;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/util-browser.js":"var markoGlobal = window.$MG || (window.$MG = {\n    uid: 0\n});\n\nvar runtimeId = markoGlobal.uid++;\n\nvar componentLookup = {};\n\nvar defaultDocument = document;\nvar EMPTY_OBJECT = {};\n\nfunction getComponentForEl(el, doc) {\n    if (el) {\n        var node = typeof el == 'string' ? (doc || defaultDocument).getElementById(el) : el;\n        if (node) {\n            var component = node._w;\n\n            while(component) {\n                var rootFor = component.$__rootFor;\n                if (rootFor)  {\n                    component = rootFor;\n                } else {\n                    break;\n                }\n            }\n\n            return component;\n        }\n    }\n}\n\nvar lifecycleEventMethods = {};\n\n[\n    'create',\n    'render',\n    'update',\n    'mount',\n    'destroy',\n].forEach(function(eventName) {\n    lifecycleEventMethods[eventName] = 'on' + eventName[0].toUpperCase() + eventName.substring(1);\n});\n\n/**\n * This method handles invoking a component's event handler method\n * (if present) while also emitting the event through\n * the standard EventEmitter.prototype.emit method.\n *\n * Special events and their corresponding handler methods\n * include the following:\n *\n * beforeDestroy --> onBeforeDestroy\n * destroy       --> onDestroy\n * beforeUpdate  --> onBeforeUpdate\n * update        --> onUpdate\n * render        --> onRender\n */\nfunction emitLifecycleEvent(component, eventType, eventArg1, eventArg2) {\n    var listenerMethod = component[lifecycleEventMethods[eventType]];\n\n    if (listenerMethod !== undefined) {\n        listenerMethod.call(component, eventArg1, eventArg2);\n    }\n\n    component.emit(eventType, eventArg1, eventArg2);\n}\n\nfunction destroyComponentForEl(el) {\n    var componentToDestroy = el._w;\n    if (componentToDestroy) {\n        componentToDestroy.$__destroyShallow();\n        el._w = null;\n\n        while ((componentToDestroy = componentToDestroy.$__rootFor)) {\n            componentToDestroy.$__rootFor = null;\n            componentToDestroy.$__destroyShallow();\n        }\n    }\n}\nfunction destroyElRecursive(el) {\n    var curChild = el.firstChild;\n    while(curChild) {\n        if (curChild.nodeType === 1) {\n            destroyComponentForEl(curChild);\n            destroyElRecursive(curChild);\n        }\n        curChild = curChild.nextSibling;\n    }\n}\n\nfunction nextComponentId() {\n    // Each component will get an ID that is unique across all loaded\n    // marko runtimes. This allows multiple instances of marko to be\n    // loaded in the same window and they should all place nice\n    // together\n    return 'b' + ((markoGlobal.uid)++);\n}\n\nfunction getElementById(doc, id) {\n    return doc.getElementById(id);\n}\n\nfunction attachBubblingEvent(componentDef, handlerMethodName, extraArgs) {\n    if (handlerMethodName) {\n        var id = componentDef.id;\n\n        return extraArgs ?\n            [handlerMethodName, id, extraArgs] :\n            [handlerMethodName, id];\n    }\n}\n\nfunction getMarkoPropsFromEl(el) {\n    var virtualProps = el._vprops;\n    if (virtualProps === undefined) {\n        virtualProps = el.getAttribute('data-marko');\n        if (virtualProps) {\n            virtualProps = JSON.parse(virtualProps);\n        }\n        el._vprops = virtualProps = virtualProps || EMPTY_OBJECT;\n    }\n\n    return virtualProps;\n}\n\nexports.$__runtimeId = runtimeId;\nexports.$__componentLookup = componentLookup;\nexports.$__getComponentForEl = getComponentForEl;\nexports.$__emitLifecycleEvent = emitLifecycleEvent;\nexports.$__destroyComponentForEl = destroyComponentForEl;\nexports.$__destroyElRecursive = destroyElRecursive;\nexports.$__nextComponentId = nextComponentId;\nexports.$__getElementById = getElementById;\nexports.$__attachBubblingEvent = attachBubblingEvent;\nexports.$__getMarkoPropsFromEl = getMarkoPropsFromEl;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/helpers/empty.js":"var notEmpty = require('./notEmpty');\n\nmodule.exports = function (o) {\n    return !notEmpty(o);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/helpers/notEmpty.js":"module.exports = function notEmpty(o) {\n    if (o == null) {\n        return false;\n    } else if (Array.isArray(o)) {\n        return !!o.length;\n    } else if (o === '') {\n        return false;\n    }\n\n    return true;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-forEachProperty.js":"var isArray = Array.isArray;\n\n/**\n * Internal helper method for looping over the properties of any object\n * @private\n */\nmodule.exports = function forEachPropertyHelper(o, func) {\n    if (!o) {\n        return;\n    }\n\n    if (isArray(o)) {\n        for (var i=0; i<o.length; i++) {\n            func(i, o[i]);\n        }\n    } else if (typeof Map && o instanceof Map) {\n        o.forEach(function(v, k) {\n            func(k, v);\n        });\n    } else {\n        for (var k in o) {\n            if (o.hasOwnProperty(k)) {\n                func(k, o[k]);\n            }\n        }\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-forEachPropStatusVar.js":"'use strict';\n\nfunction LoopStatus(getLength, isLast, isFirst, getIndex) {\n    this.getLength = getLength;\n    this.isLast = isLast;\n    this.isFirst = isFirst;\n    this.getIndex = getIndex;\n}\n\nmodule.exports = function forEachPropStatusVarHelper(object, callback) {\n    var keys = Object.keys(object);\n\n    var i = 0;\n    var len = keys.length;\n    var loopStatus = new LoopStatus(\n            function getLength() {\n                return len;\n            },\n            function isLast() {\n                return i === len - 1;\n            },\n            function isFirst() {\n                return i === 0;\n            },\n            function getIndex() {\n                return i;\n            });\n\n    for (; i < len; i++) {\n        var key = keys[i];\n        var value = object[key];\n        callback(key, value, loopStatus);\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-forEachWithStatusVar.js":"function LoopStatus(len) {\n    this.i = 0;\n    this.len = len;\n}\n\nLoopStatus.prototype = {\n    getLength: function() {\n        return this.len;\n    },\n    isLast: function() {\n        return this.i === this.len - 1;\n    },\n    isFirst: function() {\n        return this.i === 0;\n    },\n    getIndex: function() {\n        return this.i;\n    }\n};\n\n/**\n * Internal helper method to handle loops with a status variable\n * @private\n */\nmodule.exports = function forEachStatusVariableHelper(array, callback) {\n    if (!array) {\n        return;\n    }\n    if (!array.forEach) {\n        array = [array];\n    }\n\n    var len = array.length;\n    var loopStatus = new LoopStatus(len);\n\n    for (; loopStatus.i < len; loopStatus.i++) {\n        var o = array[loopStatus.i];\n        callback(o, loopStatus);\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-forRange.js":"module.exports = function forRangeHelper(from, to, step, callback) {\n    if (step == null) {\n        step = from <= to ? 1 : -1;\n    }\n\n    var i;\n\n    if (step > 0) {\n        for (i=from; i<=to; i += step) {\n            callback(i);\n        }\n    } else {\n        for (i=from; i>=to; i += step) {\n            callback(i);\n        }\n    }\n\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-loadNestedTag.js":"module.exports = function loadNestedTagHelper(targetProperty, isRepeated) {\n    return function(input, parent) {\n        // If we are nested tag then we do not have a renderer\n        if (isRepeated) {\n            var existingArray = parent[targetProperty];\n            if (existingArray) {\n                existingArray.push(input);\n            } else {\n                parent[targetProperty] = [input];\n            }\n        } else {\n            parent[targetProperty] = input;\n        }\n    };\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-loadTemplate.js":"/**\n * Loads a template\n */\nmodule.exports = require('./loader');","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-merge.js":"/**\n * Merges object properties\n * @param  {[type]} object [description]\n * @param  {[type]} source [description]\n * @return {[type]}        [description]\n */\nfunction merge(into, source) {\n    for (var k in source) {\n        if (source.hasOwnProperty(k) && !into.hasOwnProperty(k)) {\n            into[k] = source[k];\n        }\n    }\n    return into;\n}\n\nmodule.exports = merge;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/helper-mergeNestedTags.js":"/**\n * Merges nested tags by rendering the body\n * @param  {[type]} object [description]\n * @param  {[type]} source [description]\n * @return {[type]}        [description]\n */\nfunction mergeNestedTags(input) {\n    if (input.renderBody) {\n        input.renderBody(null, input);\n    }\n    input.renderBody = null;\n    return input;\n}\n\nmodule.exports = mergeNestedTags;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/nextTick-browser.js":"/* globals window */\n\nvar win = window;\nvar setImmediate = win.setImmediate;\n\nif (!setImmediate) {\n    if (win.postMessage) {\n        var queue = [];\n        var messageName = 'si';\n        win.addEventListener('message', function (event) {\n            var source = event.source;\n            if (source == win || !source && event.data === messageName) {\n                event.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        setImmediate = function(fn) {\n            queue.push(fn);\n            win.postMessage(messageName, '*');\n        };\n    } else {\n        setImmediate = setTimeout;\n    }\n}\n\nmodule.exports = setImmediate;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/removeComments.js":"'use strict';\nvar tokenizer = require('./tokenizer').create([\n    {\n        name: 'stringDouble',\n        pattern: /\"(?:[^\"]|\\\\\")*\"/,\n    },\n    {\n        name: 'stringSingle',\n        pattern: /'(?:[^']|\\\\')*'/\n    },\n    {\n        name: 'singleLineComment',\n        pattern: /\\/\\/.*/\n    },\n    {\n        name: 'multiLineComment',\n        pattern: /\\/\\*(?:[\\s\\S]*?)\\*\\//\n    }\n]);\n\n/**\n * Parses a for loop string in the following forms:\n *\n * <varName> in <expression>\n * <varName> in <expression> | status-var=<varName> separator=<expression>\n * <varName> from <expression> to <expression>\n * <varName> from <expression> to <expression> step <expression>\n * <init>; <test>; <update>\n */\nmodule.exports = function removeComments(str) {\n\n    var comments = [];\n\n    tokenizer.forEachToken(str, (token) => {\n        switch(token.name) {\n            case 'singleLineComment':\n            case 'multiLineComment':\n                comments.push(token);\n                break;\n        }\n    });\n\n    var len = comments.length;\n\n    if (len) {\n        for (var i=len-1; i>=0; i--) {\n            var comment = comments[i];\n            str = str.substring(0, comment.start) + str.substring(comment.end);\n        }\n    }\n\n    return str;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/compiler/util/tokenizer.js":"'use strict';\n\nfunction create(tokens) {\n    function getToken(matches) {\n        for (var i=0; i<tokens.length; i++) {\n            let tokenValue = matches[i + 1];\n            if (tokenValue != null) {\n                var tokenDef = tokens[i];\n                return {\n                    start: matches.index,\n                    end: matches.index + matches[0].length,\n                    name: tokenDef.name,\n                    value: tokenValue\n                };\n            }\n        }\n    }\n\n    var tokensRegExp = new RegExp(tokens\n        .map((token) => {\n            return '(' + token.pattern.source + ')';\n        })\n        .join('|'), 'g');\n\n    return {\n        forEachToken: function(value, callback, thisObj) {\n            tokensRegExp.lastIndex = 0; // Start searching from the beginning again\n            var matches;\n            while ((matches = tokensRegExp.exec(value))) {\n                let token = getToken(matches);\n                callback.call(this, token);\n            }\n        }\n    };\n}\n\nexports.create = create;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/legacy/defineComponent-legacy.js":"/**\n * Define a new UI component that includes component and renderer.\n *\n * @param  {Object} def The definition of the UI component (component methods, component constructor, rendering methods, etc.)\n * @return {Component} The resulting Component with renderer\n */\nvar defineRenderer;\nvar defineWidget;\n\nmodule.exports = function defineComponent(def) {\n    if (def.$__isComponent) {\n        return def;\n    }\n\n    var renderer;\n\n    if (def.template || def.renderer) {\n        renderer = defineRenderer(def);\n    } else {\n        throw new Error('Expected \"template\" or \"renderer\"');\n    }\n\n    return defineWidget(def, renderer);\n};\n\ndefineRenderer = require('./defineRenderer-legacy');\ndefineWidget = require('./defineWidget-legacy');\n\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/legacy/defineRenderer-legacy.js":"var marko = require('../../');\nvar makeRenderable = require('../../runtime/renderable');\n\nmodule.exports = function defineRenderer(renderingLogic) {\n    var renderer = renderingLogic.renderer;\n\n    if (renderer && renderer.$__isRenderer) {\n        return renderer;\n    }\n\n    var template = renderingLogic.template;\n\n    if (typeof template === 'string') {\n        template = marko.load(template);\n    }\n\n    if (!renderer) {\n        // Create a renderer function that takes care of translating\n        // the input properties to a view state. Also, this renderer\n        // takes care of re-using existing components.\n        renderer = function renderer(input, out) {\n            // Render the template associated with the component using the final template\n            // data that we constructed\n            template._(input, out, renderingLogic);\n        };\n    }\n\n    renderer.$__isRenderer = true;\n    renderer.createOut = template ? template.createOut : renderingLogic.createOut;\n    renderer.template = template;\n\n    makeRenderable(renderer, renderer);\n\n    return renderer;\n};\n\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/legacy/defineWidget-legacy.js":"module.exports = function defineWidget(def, renderer) {\n    if (def.$__isComponent) {\n        return def;\n    }\n\n    if (renderer) {\n        return {\n            $__isComponent: true,\n            renderer: renderer,\n            render: renderer.render,\n            renderSync: renderer.renderSync,\n            template: renderer.template\n        };\n    } else {\n        return {$__isComponent: true};\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/legacy/defineWidget-legacy-browser.js":"'use strict';\n/* jshint newcap:false */\n\n var BaseState;\n var BaseComponent;\n var inherit;\n\n\nmodule.exports = function defineWidget(def, renderer) {\n    def = def.Widget || def;\n\n    if (def.$__isComponent) {\n        return def;\n    }\n\n    var ComponentClass = function() {};\n    var proto;\n\n    if (typeof def === 'function') {\n        proto = def.prototype;\n        proto.init = def;\n    } else if (typeof def === 'object') {\n        proto = def;\n    } else {\n        throw TypeError();\n    }\n\n    ComponentClass.prototype = proto;\n\n    // We don't use the constructor provided by the user\n    // since we don't invoke their constructor until\n    // we have had a chance to do our own initialization.\n    // Instead, we store their constructor in the \"initComponent\"\n    // property and that method gets called later inside\n    // init-components-browser.js\n    function Component(id, doc) {\n        BaseComponent.call(this, id, doc);\n    }\n\n    if (!proto.$__isComponent) {\n        // Inherit from Component if they didn't already\n        inherit(ComponentClass, BaseComponent);\n    }\n\n    // The same prototype will be used by our constructor after\n    // we he have set up the prototype chain using the inherit function\n    proto = Component.prototype = ComponentClass.prototype;\n\n    proto.constructor = def.constructor = Component;\n\n    // get legacy methods\n    var init = proto.init;\n    var onRender = proto.onRender;\n    var onBeforeUpdate = proto.onBeforeUpdate;\n    var onUpdate = proto.onUpdate;\n    var onBeforeDestroy = proto.onBeforeDestroy;\n    var onDestroy = proto.onDestroy;\n\n    // delete legacy methods\n    delete proto.init;\n    delete proto.onRender;\n    delete proto.onBeforeUpdate;\n    delete proto.onUpdate;\n    delete proto.onBeforeDestroy;\n    delete proto.onDestroy;\n\n    proto.getWidget = proto.getComponent;\n    proto.getWidgets = proto.getComponents;\n\n    // convert legacy to modern\n\n    if (init || onRender) {\n        proto.onMount = function() {\n            var self = this;\n            var config = this.$c;\n            if (init) init.call(this, config);\n            if (onRender) {\n                onRender.call(this, { firstRender:true });\n                this.on('$__legacyRender', function() {\n                    self.$__didUpdate = true;\n                });\n            }\n        };\n    }\n\n    if (onBeforeUpdate || onUpdate) {\n        proto.onUpdate = function() {\n            if (onBeforeUpdate) onBeforeUpdate.call(this);\n            if (onUpdate) onUpdate.call(this);\n            if (onRender && this.$__didUpdate) {\n                this.$__didUpdate = false;\n                onRender.call(this, {});\n            }\n        };\n    }\n\n    if (onBeforeDestroy || onDestroy) {\n        proto.onDestroy = function() {\n            if (onBeforeDestroy) onBeforeDestroy.call(this);\n            if (onDestroy) onDestroy.call(this);\n        };\n    }\n\n\n    // Set a flag on the constructor function to make it clear this is\n    // a component so that we can short-circuit this work later\n    Component.$__isComponent = true;\n\n    function State() { BaseState.apply(this, arguments); }\n    inherit(State, BaseState);\n    proto.$__State = State;\n\n\n    if (!renderer) {\n        renderer = ComponentClass.renderer || ComponentClass.prototype.renderer;\n        if (renderer) {\n            // Legacy support\n            var createOut = renderer.createOut;\n            if (typeof renderer !== 'function') {\n                var rendererObject = renderer;\n                renderer = function(input, out) {\n                    var rendererFunc = rendererObject.renderer || rendererObject.render;\n                    rendererFunc(input, out);\n                };\n                renderer.createOut = createOut;\n            }\n\n            renderer.render = function(input) {\n                var out = createOut();\n                renderer(input, out);\n                return out.end();\n            };\n        }\n    }\n\n\n    if (renderer) {\n        // Add the rendering related methods as statics on the\n        // new component constructor function\n        Component.renderer = proto.$__renderer = renderer;\n        Component.render = renderer.render;\n        Component.renderSync = renderer.renderSync;\n    }\n\n    return Component;\n};\n\nBaseState = require('./State-legacy');\nBaseComponent = require('../Component');\ninherit = require('raptor-util/inherit');\n\nrequire('../../jquery').patchComponent();","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/legacy/State-legacy.js":"var extend = require('raptor-util/extend');\n\nfunction ensure(state, propertyName) {\n    var proto = state.constructor.prototype;\n    if (!(propertyName in proto)) {\n        Object.defineProperty(proto, propertyName, {\n            get: function() {\n                return this.$__raw[propertyName];\n            },\n            set: function(value) {\n                if (value === undefined) {\n                    // Don't store state properties with an undefined or null value\n                    delete this.$__raw[name];\n                } else {\n                    // Otherwise, store the new value in the component state\n                    this.$__raw[name] = value;\n                }\n            }\n        });\n    }\n}\n\nfunction State(component) {\n    this.$__component = component;\n    this.$__raw = {};\n\n    this.$__dirty = false;\n    this.$__old = null;\n    this.$__changes = null;\n    this.$__forced = null; // An object that we use to keep tracking of state properties that were forced to be dirty\n}\n\nState.prototype = {\n    $__reset: function() {\n        var self = this;\n\n        self.$__dirty = false;\n        self.$__old = null;\n        self.$__changes = null;\n        self.$__forced = null;\n    },\n\n    $__replace: function(newState) {\n        var state = this;\n        var key;\n\n        var rawState = this.$__raw;\n\n        for (key in rawState) {\n            if (!(key in newState)) {\n                state.$__set(key, undefined, false /* ensure:false */, false /* forceDirty:false */);\n            }\n        }\n\n        for (key in newState) {\n            state.$__set(key, newState[key], true /* ensure:true */, false /* forceDirty:false */);\n        }\n    },\n    $__set: function(name, value, shouldEnsure, forceDirty) {\n        var rawState = this.$__raw;\n\n        if (shouldEnsure) {\n            ensure(this, name);\n        }\n\n        if (forceDirty) {\n            var forcedDirtyState = this.$__forced || (this.$__forced = {});\n            forcedDirtyState[name] = true;\n        } else if (rawState[name] === value) {\n            return;\n        }\n\n        if (!this.$__dirty) {\n            // This is the first time we are modifying the component state\n            // so introduce some properties to do some tracking of\n            // changes to the state\n            this.$__dirty = true; // Mark the component state as dirty (i.e. modified)\n            this.$__old = rawState;\n            this.$__raw = rawState = extend({}, rawState);\n            this.$__changes = {};\n            this.$__component.$__queueUpdate();\n        }\n\n        this.$__changes[name] = value;\n\n        if (value === undefined) {\n            // Don't store state properties with an undefined or null value\n            delete rawState[name];\n        } else {\n            // Otherwise, store the new value in the component state\n            rawState[name] = value;\n        }\n    },\n    toJSON: function() {\n        return this.$__raw;\n    }\n};\n\nmodule.exports = State;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/legacy/renderer-legacy.js":"var getComponentsContext = require('../ComponentsContext').$__getComponentsContext;\nvar componentsUtil = require('../util');\nvar componentLookup = componentsUtil.$__componentLookup;\nvar registry = require('../registry');\nvar modernRenderer = require('../renderer');\nvar resolveComponentKey = modernRenderer.$__resolveComponentKey;\nvar preserveComponentEls = modernRenderer.$__preserveComponentEls;\nvar handleBeginAsync = modernRenderer.$__handleBeginAsync;\n\nvar WIDGETS_BEGIN_ASYNC_ADDED_KEY = '$wa';\n\nfunction createRendererFunc(templateRenderFunc, componentProps) {\n    var typeName = componentProps.type;\n    var roots = componentProps.roots;\n    var assignedId = componentProps.id;\n\n    return function renderer(input, out, renderingLogic) {\n        var outGlobal = out.global;\n\n        if (!outGlobal[WIDGETS_BEGIN_ASYNC_ADDED_KEY]) {\n            outGlobal[WIDGETS_BEGIN_ASYNC_ADDED_KEY] = true;\n            out.on('beginAsync', handleBeginAsync);\n        }\n\n        var getInitialProps;\n        var getTemplateData;\n        var getInitialState;\n        var getWidgetConfig;\n        var getInitialBody;\n\n        if (renderingLogic) {\n            getInitialProps = renderingLogic.getInitialProps;\n            getTemplateData = renderingLogic.getTemplateData;\n            getInitialState = renderingLogic.getInitialState;\n            getWidgetConfig = renderingLogic.getWidgetConfig;\n            getInitialBody = renderingLogic.getInitialBody;\n        }\n\n        var widgetConfig;\n        var componentBody;\n        var componentState;\n\n        var component = outGlobal.$w;\n        var fakeComponent;\n        var isRerender = component !== undefined;\n        var id = assignedId;\n        var isExisting;\n        var customEvents;\n        var scope;\n\n        if (component) {\n            id = component.id;\n            isExisting = true;\n            outGlobal.$w = null;\n        } else {\n            var componentArgs = out.$c;\n\n            if (componentArgs) {\n                out.$c = null;\n                scope = componentArgs[0];\n\n                if (scope) {\n                    scope = scope.id;\n                }\n\n                var ref = componentArgs[1];\n                if (ref != null) {\n                    ref = ref.toString();\n                }\n                id = id || resolveComponentKey(out, ref, scope);\n                customEvents = componentArgs[2];\n                delete input.$w;\n            }\n        }\n\n        var componentsContext = getComponentsContext(out);\n        id = id || componentsContext.$__nextComponentId();\n\n        if (registry.$__isServer && typeName) {\n            component = { id:id, typeName:typeName };\n        } else {\n            if (!component) {\n                if (isRerender) {\n                    // Look in in the DOM to see if a component with the same ID and type already exists.\n                    component = componentLookup[id];\n                    if (component && component.$__type !== typeName) {\n                        component = undefined;\n                    }\n                }\n\n                if (component) {\n                    isExisting = true;\n                } else {\n                    isExisting = false;\n                    // We need to create a new instance of the component\n                    if (typeName) {\n                        component = registry.$__createComponent(typeName, id);\n                    }\n                }\n            }\n        }\n\n        if (input) {\n            if (getWidgetConfig) {\n                // If getWidgetConfig() was implemented then use that to\n                // get the component config. The component config will be passed\n                // to the component constructor. If rendered on the server the\n                // component config will be serialized to a JSON-like data\n                // structure and stored in a \"data-w-config\" attribute.\n                widgetConfig = getWidgetConfig(input, out);\n            } else {\n                widgetConfig = input.widgetConfig;\n            }\n\n            if (widgetConfig) {\n                component.$c = widgetConfig;\n            }\n\n            if (getInitialBody) {\n                // If we have component a component body then pass it to the template\n                // so that it is available to the component tag and can be inserted\n                // at the w-body marker\n                componentBody = getInitialBody(input, out);\n            }\n\n            // If we do not have state then we need to go through the process\n            // of converting the input to a component state, or simply normalizing\n            // the input using getInitialProps\n\n            if (getInitialProps) {\n                // This optional method is used to normalize input state\n                input = getInitialProps(input, out) || {};\n            }\n\n            if (getInitialState) {\n                // This optional method is used to derive the component state\n                // from the input properties\n                component.state = componentState = getInitialState(input, out);\n            }\n\n            if (!componentBody) {\n                // Default to using the nested content as the component body\n                componentBody = input.renderBody;\n            }\n        }\n\n        if (component && isExisting) {\n            if (!component.$__isDirty || !component.shouldUpdate(input, component.$__state)) {\n                if (customEvents) {\n                    component.$__setCustomEvents(customEvents, scope);\n                }\n\n                preserveComponentEls(component, out, componentsContext);\n                return;\n            }\n        }\n\n        if (!component) {\n            fakeComponent = {};\n        } else {\n            componentState = component.$__rawState || componentState;\n        }\n\n        var templateInput = getTemplateData ?\n            getTemplateData(componentState, input, out) :\n            componentState || input || {};\n\n        var componentDef = componentsContext.$__beginComponent(component || fakeComponent);\n        componentDef.$__roots = roots;\n        componentDef.$__component = fakeComponent ? null : component;\n        componentDef.$__isExisting = isExisting;\n        componentDef.b = componentBody;\n        componentDef.c = function(widgetConfig) {\n            component.$c = widgetConfig;\n        };\n        componentDef.t = function(typeName) {\n            if (typeName) {\n                this.$__component = component = registry.$__createComponent(typeName, fakeComponent.id);\n            }\n        };\n\n        if (component && isExisting) {\n            component.$__emitLifecycleEvent('$__legacyRender');\n        }\n\n        // Render the template associated with the component using the final template\n        // data that we constructed\n        templateRenderFunc(templateInput, out, componentDef, componentDef);\n\n        if (customEvents && componentDef.$__component) {\n            if (registry.$__isServer) {\n                componentDef.$__customEvents = customEvents;\n                componentDef.$__scope = scope;\n            } else {\n                componentDef.$__component.$__setCustomEvents(customEvents, scope);\n            }\n        }\n\n        componentDef.$__end();\n    };\n}\n\nmodule.exports = createRendererFunc;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/body-transformer.js":"'use strict';\n\nmodule.exports = function transform(el, context) {\n    let initComponentsNode = context.createNodeForEl('init-components');\n    el.appendChild(initComponentsNode);\n\n    // Make <await-reorderer> optional. Automatically insert it before the\n    // body tag.\n    let awaitReorderer = context.createNodeForEl('await-reorderer');\n    el.appendChild(awaitReorderer);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/components-transformer.js":"'use strict';\nvar getTransformHelper = require('./util/getTransformHelper');\n\n\nfunction tagDefinitionHasOverridingKeyAttribute(el, context) {\n    if (!el.hasAttribute('key')) {\n        return false;\n    }\n\n    var tagDef = el.tagDef;\n    if (tagDef && tagDef.hasAttribute('key')) {\n        return true;\n    }\n\n    return false;\n}\nmodule.exports = function transform(el, context) {\n    var transformHelper = getTransformHelper(el, context);\n\n    if (el.type === 'TemplateRoot') {\n        transformHelper.handleRootNodes();\n        return;\n    }\n\n    if (el.hasAttribute('w-body')) {\n        context.deprecate('The \"w-body\" attribute is deprecated. Please use \"<include(...)\" instead. See: https://github.com/marko-js/marko/issues/492');\n        let builder = context.builder;\n        let bodyValue = el.getAttributeValue('w-body');\n        el.removeAttribute('w-body');\n\n        let includeNode = context.createNodeForEl('include');\n\n        if (!bodyValue) {\n            bodyValue = builder.memberExpression(\n                builder.identifier('__component'),\n                builder.identifier('b'));\n\n            includeNode.data.bodySlot = true;\n        }\n\n        includeNode.addProp('_target', bodyValue);\n        el.appendChild(includeNode);\n    }\n\n    if (el.tagName === 'widget-types') {\n        context.setFlag('hasWidgetTypes');\n    } else if (el.tagName === 'include') {\n        transformHelper.handleComponentEvents();\n        transformHelper.handleIncludeNode(el);\n        transformHelper.getComponentArgs().compile(transformHelper);\n        return;\n    }\n\n    if (el.hasAttribute('w-el-id')) {\n        transformHelper.addError('\"w-el-id\" attribute is no longer allowed. Use \"w-id\" instead.');\n        return;\n    }\n\n    if (el.isFlagSet('hasComponentBind') || el.hasAttribute('w-bind')) {\n        el.setFlag('hasComponentBind');\n        transformHelper.handleComponentBind();\n    }\n\n    if (/* New preserve attributes */\n        el.hasAttribute('no-update') ||\n        el.hasAttribute('no-update-body') ||\n        el.hasAttribute('no-update-if') ||\n        el.hasAttribute('no-update-body-if') ||\n        /* Old preserve attributes */\n        el.hasAttribute('w-preserve') ||\n        el.hasAttribute('w-preserve-body') ||\n        el.hasAttribute('w-preserve-if') ||\n        el.hasAttribute('w-preserve-body-if')) {\n        transformHelper.handleComponentPreserve();\n    }\n\n    if (el.hasAttribute('key') || el.hasAttribute('ref') || el.hasAttribute('w-id')) {\n        if (!tagDefinitionHasOverridingKeyAttribute(el, context)) {\n            transformHelper.assignComponentId();\n        }\n    }\n\n    if (el.hasAttribute('for-key') || el.hasAttribute('for-ref') || el.hasAttribute('w-for')) {\n        transformHelper.handleComponentFor();\n    }\n\n    if (el.hasAttribute('w-body')) {\n        transformHelper.handleComponentBody();\n    }\n\n    // Handle w-preserve-attrs and :no-update attributes\n    transformHelper.handleComponentPreserveAttrs();\n\n    // Handle w-on* properties\n    transformHelper.handleComponentEvents();\n\n    // If we need to pass any information to a nested component then\n    // we start that information in the \"out\" so that it can be picked\n    // up later by the nested component. We call this \"component args\" and\n    // we generate compiled code that stores the component args in the out\n    // for the next component and then we also insert cleanup code to remove\n    // the data out of the out\n    transformHelper.getComponentArgs().compile(transformHelper);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/util/getTransformHelper.js":"var TransformHelper = require('../TransformHelper');\n\nmodule.exports = function(el, context) {\n    return new TransformHelper(el, context);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/index.js":"'use strict';\nvar ComponentArgs = require('./ComponentArgs');\nvar getRequirePath = require('../getRequirePath');\n\nvar MARKO_WIDGETS_VAR_KEY = Symbol('MARKO_WIDGETS_VAR');\nvar WIDGET_PROPS_KEY;\nvar HAS_COMPONENT_KEY = Symbol('HAS_WIDGET');\n\nclass TransformHelper {\n    constructor(el, context) {\n        this.el = el;\n        this.context = context;\n        this.builder = context.builder;\n        this.dirname = context.dirname;\n        this.filename = context.filename;\n\n        this.componentNextElId = 0;\n        this.componentArgs = undefined;\n        this.containingComponentNode = undefined;\n        this._markoComponentsVar = context.data.markoComponentsVar;\n        this.firstBind = false;\n        this.componentModule = null;\n        this.rendererModule = null;\n    }\n\n    setHasBoundComponentForTemplate() {\n        this.context.data[HAS_COMPONENT_KEY] = true;\n    }\n\n    setComponentModule(value) {\n        this.context.data.componentModule = value;\n    }\n\n    getComponentModule() {\n        return this.context.data.componentModule;\n    }\n\n    setRendererModule(value) {\n        this.context.data.rendererModule = value;\n    }\n\n    getRendererModule() {\n        return this.context.data.rendererModule;\n    }\n\n    getTemplateModule() {\n        return {\n            requirePath:this.context.getRequirePath(this.filename)\n        };\n    }\n\n    hasBoundComponentForTemplate() {\n        return this.context.data.componentModule != null ||\n            this.context.data[HAS_COMPONENT_KEY] ||\n            this.context.data[WIDGET_PROPS_KEY] != null;\n    }\n\n    getComponentProps() {\n        var componentProps = this.context.data[WIDGET_PROPS_KEY];\n        if (!componentProps) {\n            this.firstBind = true;\n            componentProps = this.context.data[WIDGET_PROPS_KEY] = {};\n        }\n        return componentProps;\n    }\n\n    addError(message, code) {\n        this.context.addError(this.el, message, code);\n    }\n\n    getComponentArgs() {\n        return this.componentArgs || (this.componentArgs = new ComponentArgs());\n    }\n\n    nextUniqueId() {\n        var componentNextElId = this.context.data.componentNextElId;\n        if (componentNextElId == null) {\n            this.context.data.componentNextElId = 0;\n        }\n\n        return (this.context.data.componentNextElId++);\n    }\n\n    getNestedIdExpression() {\n        this.assignComponentId();\n        return this.getComponentIdInfo().nestedIdExpression;\n    }\n\n    getIdExpression() {\n        this.assignComponentId();\n        return this.getComponentIdInfo().idExpression;\n    }\n\n    set componentIdInfo(value) {\n        this.el.data.componentIdInfo = value;\n    }\n\n    get componentIdInfo() {\n        return this.el.data.componentIdInfo;\n    }\n\n    getComponentIdInfo() {\n        return this.componentIdInfo;\n    }\n\n    getCompileContext() {\n        return this.context;\n    }\n\n    getMarkoComponentsRequirePath(target) {\n        return getRequirePath(target, this.context);\n    }\n\n    set markoComponentsVar(value) {\n        this.context.data[MARKO_WIDGETS_VAR_KEY] = value;\n    }\n\n    get markoComponentsVar() {\n        if (!this.context.data[MARKO_WIDGETS_VAR_KEY]) {\n            this.context.data[MARKO_WIDGETS_VAR_KEY] =\n                this.context.importModule(\n                    'marko_components',\n                    this.getMarkoComponentsRequirePath(this.isLegacyComponent ? 'marko/components/legacy' : 'marko/components'));\n        }\n\n        return this.context.data[MARKO_WIDGETS_VAR_KEY];\n    }\n\n    buildComponentElIdFunctionCall(id) {\n        var builder = this.builder;\n\n        var componentElId = builder.memberExpression(\n            builder.identifier('__component'),\n            builder.identifier('elId'));\n\n        return builder.functionCall(componentElId, arguments.length === 0 ? [] : [ id ]);\n    }\n\n    getTransformHelper(el) {\n        return new TransformHelper(el, this.context);\n    }\n}\n\nTransformHelper.prototype.assignComponentId = require('./assignComponentId');\nTransformHelper.prototype.handleRootNodes = require('./handleRootNodes');\nTransformHelper.prototype.handleIncludeNode = require('./handleIncludeNode');\nTransformHelper.prototype.handleComponentEvents = require('./handleComponentEvents');\nTransformHelper.prototype.handleComponentPreserve = require('./handleComponentPreserve');\nTransformHelper.prototype.handleComponentPreserveAttrs = require('./handleComponentPreserveAttrs');\nTransformHelper.prototype.handleComponentBind = require('./handleComponentBind');\nTransformHelper.prototype.handleComponentFor = require('./handleComponentFor');\n\nmodule.exports = TransformHelper;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/ComponentArgs.js":"'use strict';\nclass ComponentArgs {\n\n    constructor() {\n        this.id = null;\n        this.customEvents = null;\n        this.empty = true;\n    }\n\n    setId(id) {\n        this.empty = false;\n        this.id = id;\n    }\n\n    getId() {\n        return this.id;\n    }\n\n    addCustomEvent(eventType, targetMethod, extraArgs) {\n        this.empty = false;\n\n        if (!this.customEvents) {\n            this.customEvents = [];\n        }\n\n        this.customEvents.push([eventType, targetMethod, extraArgs]);\n    }\n\n    compile(transformHelper) {\n        if (this.empty) {\n            return;\n        }\n\n        var el = transformHelper.el;\n\n        var builder = transformHelper.builder;\n\n        var id = this.id;\n        var customEvents = this.customEvents;\n\n        // Make sure the nested component has access to the ID of the containing\n        // component if it is needed\n        var shouldProvideScope = id || customEvents;\n\n        var args = [];\n\n        if (shouldProvideScope) {\n            args.push(builder.identifier('__component'));\n        } else {\n            args.push(builder.literalNull());\n        }\n\n        if (id != null) {\n            args.push(id);\n        } else {\n            args.push(builder.literalNull());\n        }\n\n        if (customEvents) {\n            args.push(builder.literal(customEvents));\n        }\n\n        if (el.type === 'CustomTag') {\n            var renderComponentHelper = transformHelper.context.helper('renderComponent');\n\n            el.generateRenderTagCode = function(codegen, tagVar, tagArgs) {\n                tagArgs = [tagVar].concat(tagArgs);\n\n                tagArgs.push(builder.literal(args));\n\n                return codegen.builder.functionCall(\n                    renderComponentHelper,\n                    tagArgs);\n            };\n        } else {\n            el.onBeforeGenerateCode((event) => {\n                let lhs = builder.memberExpression(builder.identifierOut(), builder.identifier('$c'));\n                let rhs = builder.literal(args);\n\n                event.insertCode(builder.assignment(lhs, rhs));\n            });\n\n            el.onAfterGenerateCode((event) => {\n                let lhs = builder.memberExpression(builder.identifierOut(), builder.identifier('$c'));\n                let rhs = builder.literalNull();\n\n                event.insertCode(builder.assignment(lhs, rhs));\n            });\n        }\n    }\n}\n\nmodule.exports = ComponentArgs;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/getRequirePath.js":"var resolveFrom = require('resolve-from');\n\nmodule.exports = function getRequirePath(target, context) {\n    if (target === 'marko' || target.startsWith('marko/')) {\n        return target;\n    }\n\n    var resolvedTarget = resolveFrom(context.dirname, target);\n    if (!resolvedTarget) {\n        throw new Error('Unable to resolve \"' + target + '\" from \"' + context.dirname + '\"');\n    }\n    var requirePath = context.getRequirePath(resolvedTarget);\n    return requirePath;\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/assignComponentId.js":"'use strict';\n\nmodule.exports = function assignComponentId(isRepeated) {\n    // First check if we have already assigned an ID to thie element\n    var componentIdInfo = this.componentIdInfo;\n\n    if (componentIdInfo) {\n        return this.componentIdInfo;\n    }\n\n    var el = this.el;\n    var context = this.context;\n    var builder = this.builder;\n\n    let componentRef;\n    var nestedIdExpression;\n    var idExpression;\n\n    if (!this.hasBoundComponentForTemplate()) {\n        // We are assigning a component ID to a nested component in a template that does not have a component.\n        // That means we do not have access to the parent component variable as part of a closure. We\n        // need to look it up out of the `out.data` map\n        if (!context.isFlagSet('hasComponentVar')) {\n            context.setFlag('hasComponentVar');\n\n            var getCurrentComponentVar = context.importModule('marko_getCurrentComponent',\n                this.getMarkoComponentsRequirePath('marko/components/taglib/helpers/getCurrentComponent'));\n\n            context.addVar('__component', builder.functionCall(getCurrentComponentVar, [builder.identifierOut()]));\n        }\n    }\n\n    // In order to attach a DOM event listener directly we need to make sure\n    // the target HTML element has an ID that we can use to get a reference\n    // to the element during initialization. We generate this unique ID\n    // at compile-time to allow consistent IDs during rendering.\n    // We need to handle the following scenarios:\n    //\n    // 1) The HTML element already has an \"id\" attribute\n    // 2) The HTML element has a \"ref\" or \"w-id\" attribute (we already converted this\n    //    to an \"id\" attribute above)\n    // 3) The HTML does not have an \"id\" or \"ref\" attribute. We must add\n    //    an \"id\" attribute with a unique ID.\n\n    var isCustomTag = el.type !== 'HtmlElement';\n\n    if (el.hasAttribute('key')) {\n        componentRef = el.getAttributeValue('key');\n        el.removeAttribute('key');\n    } else if (el.hasAttribute('ref')) {\n        context.deprecate('The \"ref\" attribute is deprecated. Please use \"key\" instead.');\n        componentRef = el.getAttributeValue('ref');\n        el.removeAttribute('ref');\n    }\n\n    if (el.hasAttribute('w-id')) {\n        context.deprecate('The \"w-id\" attribute is deprecated. Please use \"key\" instead.');\n\n        if (componentRef) {\n            this.addError('The \"w-id\" attribute cannot be used in conjuction with the \"ref\" or \"key\" attributes.');\n            return;\n        }\n\n        componentRef = el.getAttributeValue('w-id');\n\n        el.removeAttribute('w-id');\n    }\n\n    if (componentRef) {\n        idExpression = this.buildComponentElIdFunctionCall(componentRef);\n\n        nestedIdExpression = componentRef;\n\n        if (isCustomTag) {\n            // The element is a custom tag\n            this.getComponentArgs().setId(nestedIdExpression);\n        } else {\n            if (el.hasAttribute('id')) {\n                this.addError('The \"ref\", \"key\", and \"w-id\" attributes cannot be used in conjuction with the \"id\" attribute.');\n                return;\n            }\n            el.setAttributeValue('id', idExpression);\n        }\n    } else if (el.hasAttribute('id')) {\n        idExpression = el.getAttributeValue('id');\n\n        if (el.isFlagSet('hasComponentBind')) {\n            // We have to attach a listener to the root element of the component\n            // We will use an empty string as an indicator that it is the root component\n            // element.\n            nestedIdExpression = builder.literal('');\n        } else {\n            // Convert the raw String to a JavaScript expression. we need to prefix\n            // with '#' to make it clear this is a fully resolved element ID\n            nestedIdExpression = builder.concat(\n                builder.literal('#'),\n                idExpression);\n        }\n    } else {\n        // Case 3 - We need to add a unique \"id\" attribute\n        let uniqueElId = this.nextUniqueId();\n\n        nestedIdExpression = isRepeated ? builder.literal(uniqueElId + '[]') : builder.literal(uniqueElId);\n\n        idExpression = this.buildComponentElIdFunctionCall(nestedIdExpression);\n\n        if (isCustomTag) {\n            this.getComponentArgs().setId(nestedIdExpression);\n        } else {\n            el.setAttributeValue('id', idExpression);\n        }\n    }\n\n    var transformHelper = this;\n\n    this.componentIdInfo = {\n        idExpression: idExpression,\n        nestedIdExpression: nestedIdExpression,\n        idVarNode: null,\n        createIdVarNode: function() {\n            if (this.idVarNode) {\n                return this.idVarNode;\n            }\n\n            let uniqueElId = transformHelper.nextUniqueId();\n            let idVarName = '__componentId' + uniqueElId;\n            let idVar = builder.identifier(idVarName);\n\n            this.idVarNode = builder.vars([\n                {\n                    id: idVarName,\n                    init: idExpression\n                }\n            ]);\n\n            this.idExpression = idExpression = idVar;\n\n            this.nestedIdExpression = nestedIdExpression = builder.concat(\n                builder.literal('#'),\n                idVar);\n\n            if (isCustomTag) {\n                transformHelper.getComponentArgs().setId(nestedIdExpression);\n            } else {\n                el.setAttributeValue('id', idExpression);\n            }\n\n            return this.idVarNode;\n        }\n    };\n\n    return this.componentIdInfo;\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleRootNodes.js":"'use strict';\n\nvar path = require('path');\nvar getComponentFiles = require('./getComponentFiles');\n\nconst esprima = require('esprima');\nconst escodegen = require('escodegen');\n\nfunction handleStyleElement(styleEl, transformHelper) {\n    if (styleEl.bodyText) {\n        return;\n    }\n\n    var attrs = styleEl.attributes;\n\n    var styleCode;\n    var lang = 'css';\n\n    var hasStyleBlock = false;\n\n    for (var i=attrs.length-1; i>=0; i--) {\n        var attr = attrs[i];\n        var name = attr.name;\n        if (name.startsWith('{')) {\n            hasStyleBlock = true;\n\n            styleCode = name.slice(1, -1);\n        } else if (name === 'class') {\n            if (attr.value.type !== 'Literal' || typeof attr.value.value !== 'string') {\n                return;\n            }\n\n            lang = attr.value.value;\n        } else {\n            if (hasStyleBlock) {\n                transformHelper.context.addError(styleEl, 'Unsupported attribute on the component style tag: ' + attr.name);\n                return;\n            }\n        }\n    }\n\n    if (styleCode == null) {\n        return;\n    }\n\n    var context = transformHelper.context;\n    context.addDependency({\n        type: lang,\n        code: styleCode.trim(),\n        virtualPath: './'+path.basename(context.filename)+'.'+lang,\n        path: './'+path.basename(context.filename)\n    });\n\n    styleEl.detach();\n}\n\nfunction methodToProperty(method) {\n    return {\n        type: 'Property',\n        key: method.key,\n        computed: false,\n        value: method.value,\n        kind: 'init',\n        method: false,\n        shorthand: false\n    };\n}\n\nfunction classToObject(cls, el, transformHelper) {\n    return {\n        type: 'ObjectExpression',\n        properties: cls.body.body.map((method) => {\n            if(method.type != 'MethodDefinition') {\n                throw Error('Only methods are allowed on single file component class definitions.');\n            }\n\n            if (method.kind === 'method') {\n                return methodToProperty(method);\n            } else if (method.kind === 'constructor') {\n                transformHelper.context.deprecate('The constructor method should not be used for a component, use onCreate instead', el);\n                let converted = methodToProperty(method);\n                converted.key.name = 'onCreate';\n                return converted;\n            } else {\n                return method;\n            }\n        })\n    };\n}\n\nfunction handleClassDeclaration(classEl, transformHelper) {\n    let tree;\n    var wrappedSrc = '('+classEl.tagString+'\\n)';\n\n    try {\n        tree = esprima.parse(wrappedSrc);\n    } catch(err) {\n        var message = 'Unable to parse JavaScript for component class. ' + err;\n\n        if (err.index != null) {\n            var errorIndex = err.index;\n            // message += '\\n' + err.description;\n            if (errorIndex != null && errorIndex >= 0) {\n                transformHelper.context.addError({\n                    pos: classEl.pos + errorIndex,\n                    message: message\n                });\n                return;\n            }\n        }\n\n        transformHelper.context.addError(classEl, message);\n        return;\n    }\n    let expression = tree.body[0].expression;\n\n    if (expression.superClass && expression.superClass.name) {\n        transformHelper.context.addError(classEl, 'A component class is not allowed to use `extends`. See: https://github.com/marko-js/marko/wiki/Error:-Component-class-with-extends');\n        return;\n    }\n\n    let object = classToObject(expression, classEl, transformHelper);\n    let componentVar = transformHelper.context.addStaticVar('marko_component', escodegen.generate(object));\n\n    if (transformHelper.getRendererModule() != null) {\n        transformHelper.context.addError(classEl, 'The component has both an inline component `class` and a separate `component.js`. This is not allowed. See: https://github.com/marko-js/marko/wiki/Error:-Component-inline-and-external');\n        return;\n    }\n\n    var moduleInfo = {\n        inlineId: componentVar,\n        filename: transformHelper.filename,\n        requirePath: './' + path.basename(transformHelper.filename)\n    };\n\n    if (transformHelper.getComponentModule() == null) {\n        transformHelper.setComponentModule(moduleInfo);\n    }\n\n    transformHelper.setRendererModule(moduleInfo);\n\n    classEl.detach();\n}\n\nmodule.exports = function handleRootNodes() {\n    var context = this.context;\n    var builder = this.builder;\n\n    var componentFiles = getComponentFiles(context.filename);\n    if (!componentFiles) {\n        return;\n    }\n\n    var dirname = context.dirname;\n\n    componentFiles.styles.forEach((styleFile) => {\n        context.addDependency('./' + styleFile);\n    });\n\n    if (componentFiles.file) {\n        let file = componentFiles.file;\n\n        let moduleInfo = {\n            filename: path.join(dirname, file),\n            requirePath: './'+file.slice(0, file.lastIndexOf('.'))\n        };\n\n        this.setComponentModule(moduleInfo);\n        this.setRendererModule(moduleInfo);\n    }\n\n    if (componentFiles.browserFile) {\n        let file = componentFiles.browserFile;\n        this.setComponentModule({\n            filename: path.join(dirname, file),\n            requirePath: './' + file.slice(\n                0, file.lastIndexOf('.'))\n        });\n    }\n\n    var templateRoot = this.el;\n\n    var rootNodes = [];\n    var hasLegacyExplicitBind = false;\n    var hasIdCount = 0;\n    var nodeWithAssignedId;\n    var assignedId;\n    var transformHelper = this;\n\n    let walker = context.createWalker({\n        enter(node) {\n            var tagName = node.tagName && node.tagName.toLowerCase();\n\n            if (node.type === 'TemplateRoot' || !node.type) {\n                // Don't worry about the TemplateRoot or an Container node\n            } else if (node.type === 'HtmlElement') {\n                if (node.hasAttribute('w-bind')) {\n                    transformHelper.setHasBoundComponentForTemplate();\n                    hasLegacyExplicitBind = true;\n                } else {\n                    if (node.hasAttribute('id')) {\n                        hasIdCount++;\n                        nodeWithAssignedId = node;\n                        assignedId = node.getAttributeValue('id');\n                    }\n\n                    if (tagName === 'style') {\n                        handleStyleElement(node, transformHelper);\n                    } else {\n                        rootNodes.push(node);\n                    }\n                }\n                walker.skip();\n\n                return;\n            } else if (node.type === 'CustomTag') {\n                rootNodes.push(node);\n\n                walker.skip();\n                return;\n            } else {\n                if (tagName === 'class') {\n                    handleClassDeclaration(node, transformHelper);\n                }\n\n                walker.skip();\n                return;\n            }\n        }\n    });\n\n    walker.walk(templateRoot);\n\n    if (hasLegacyExplicitBind) {\n        //There is an explicit bind so nothing to do\n        return;\n    }\n\n    if (!this.hasBoundComponentForTemplate()) {\n        return;\n    }\n\n    if (rootNodes.length === 0) {\n        return;\n    }\n\n    if (rootNodes.length > 1 && hasIdCount > 0) {\n        // We can only bind a component to multiple top-level elements if we can assign\n        // all of the IDs\n        return;\n    }\n\n    transformHelper.setHasBoundComponentForTemplate();\n\n    var nextKey = 0;\n\n    rootNodes.forEach((curNode, i) => {\n        curNode.setFlag('hasComponentBind');\n\n        if (!curNode.hasAttribute('key') && !curNode.hasAttribute('ref')) {\n            if (curNode.type === 'CustomTag' || rootNodes.length > 1) {\n                curNode.setAttributeValue('key', builder.literal('_r' + (nextKey++)));\n            }\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/getComponentFiles.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\nfunction getComponentFiles(filename) {\n    var ext = path.extname(filename);\n    if (ext === '.js') {\n        return null;\n    }\n\n    var nameNoExt = path.basename(filename, ext);\n\n    var isEntry = 'index' === nameNoExt;\n\n    var fileMatch = '('+nameNoExt.replace(/\\./g, '\\\\.') + '\\\\.' + (isEntry ? '|' : '') + ')';\n    var styleMatch = new RegExp('^'+fileMatch+'style\\\\.\\\\w+$');\n    var componentMatch = new RegExp('^'+fileMatch+'component\\\\.\\\\w+$');\n    var splitComponentMatch = new RegExp('^'+fileMatch+'component-browser\\\\.\\\\w+$');\n\n    var dirname = path.dirname(filename);\n\n    var foundFiles = {\n        styles: [],\n        file: null,\n        browserFile: null\n    };\n\n    var dirFiles = fs.readdirSync(dirname);\n    dirFiles.sort();\n\n    for (let i=dirFiles.length - 1; i>=0; i--) {\n        let file = dirFiles[i];\n\n        if (styleMatch.test(file)) {\n            foundFiles.styles.push(file);\n        } else if (splitComponentMatch.test(file)) {\n            foundFiles.browserFile = file;\n        } else if (componentMatch.test(file)) {\n            foundFiles.file = file;\n        }\n    }\n\n    return foundFiles;\n}\n\nmodule.exports = getComponentFiles;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleIncludeNode.js":"'use strict';\n\nvar includeTagForComponents = require.resolve('../include-tag');\n\nmodule.exports = function(includeNode) {\n    var context = this.context;\n\n    if (!this.hasBoundComponentForTemplate()) {\n        return;\n    }\n\n    var parentNode = includeNode.parentNode;\n\n    if (!parentNode.hasAttribute) {\n        return;\n    }\n\n    parentNode._normalizeChildTextNodes(context, true /* force trim */);\n\n    if (parentNode.childCount === 1) {\n        if (includeNode.hasAttribute('key') || includeNode.hasAttribute('ref')) {\n            this.assignComponentId();\n        }\n\n        let parentTransformHelper = this.getTransformHelper(parentNode);\n\n        if (includeNode.data.bodySlot) {\n            parentTransformHelper.assignComponentId(false /* not repeated */);\n            var componentProps = this.getComponentProps();\n            componentProps.body = parentTransformHelper.getNestedIdExpression();\n        } else {\n            let componentIdInfo = parentTransformHelper.assignComponentId(true /* repeated */);\n            if (!componentIdInfo.idVarNode) {\n                let idVarNode = componentIdInfo.createIdVarNode();\n                parentNode.onBeforeGenerateCode((event) => {\n                    event.insertCode(idVarNode);\n                });\n            }\n        }\n\n        includeNode.setRendererPath(includeTagForComponents);\n\n        includeNode.onBeforeGenerateCode(function() {\n            includeNode.addProp('_elId', parentTransformHelper.getIdExpression());\n        });\n    }\n\n\n\n    // includeNode.generateCodeForDynamicInclude = (options, codegen) => {\n    //     var target = options.target;\n    //     var data = options.data;\n    //\n    //     if (!data) {\n    //         data = builder.literal(null);\n    //     }\n    //\n    //     let includeVar = context.importModule('marko_component_include', this.getMarkoComponentsRequirePath('marko/components/taglib/helpers/include'));\n    //\n    //     let includeArgs = [\n    //         target,\n    //         builder.identifierOut(),\n    //         data\n    //     ];\n    //\n    //     if (parentTransformHelper) {\n    //         includeArgs = includeArgs.concat([\n    //             parentTransformHelper.getIdExpression(),\n    //\n    //         ]);\n    //     }\n    //\n    //     return builder.functionCall(includeVar, includeArgs);\n    // };\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleComponentEvents.js":"'use strict';\n\nvar ATTACH_DETACH_KEY = Symbol('attach-detach');\n\nvar bubbleEventsLookup = {};\n\nrequire('../../bubble').forEach(function(eventType) {\n    bubbleEventsLookup[eventType] = true;\n});\n\nfunction isBubbleEvent(eventType) {\n    return bubbleEventsLookup.hasOwnProperty(eventType);\n}\n\nfunction isUpperCase(c) {\n    return c == c.toUpperCase();\n}\n\nfunction addBubblingEventListener(transformHelper, eventType, targetMethod, extraArgs) {\n    var el = transformHelper.el;\n\n    if (transformHelper.hasBoundComponentForTemplate() === false) {\n        transformHelper.addError('Unable to handle event ' + eventType + '. HTML element is not nested within a component.');\n        return;\n    }\n\n    var builder = transformHelper.builder;\n\n    var addBubblingEventMethod = builder.memberExpression(\n        builder.identifier('__component'),\n        builder.identifier('d'));\n\n    var addBubblingEventArgs = [\n            targetMethod\n        ];\n\n    if (extraArgs) {\n        addBubblingEventArgs.push(builder.arrayExpression(extraArgs));\n    }\n\n    var propValue = builder.functionCall(addBubblingEventMethod, addBubblingEventArgs);\n    var propName = 'on' + eventType.value;\n    el.setPropertyValue(propName, propValue, false);\n\n    if (eventType.value === 'attach' || eventType.value === 'detach') {\n        if (!transformHelper.context.data[ATTACH_DETACH_KEY]) {\n            transformHelper.context.data[ATTACH_DETACH_KEY] = true;\n\n            let requireFuncCall = builder.require(builder.literal('marko/components/attach-detach'));\n            transformHelper.context.addStaticCode(requireFuncCall);\n        }\n\n    }\n}\n\nfunction addDirectEventListener(transformHelper, eventType, targetMethod, extraArgs) {\n    var builder = transformHelper.builder;\n    var el = transformHelper.el;\n\n    var addDomEvent = builder.memberExpression(\n        builder.identifier('__component'),\n        builder.identifier('e'));\n\n    let componentIdInfo = transformHelper.assignComponentId(true /* repeated */);\n    let idVarNode = componentIdInfo.idVarNode ? null : componentIdInfo.createIdVarNode();\n\n    var helperArgs = [\n        eventType,\n        targetMethod,\n        componentIdInfo.idExpression\n    ];\n\n    if (extraArgs) {\n        helperArgs.push(builder.arrayExpression(extraArgs));\n    }\n\n    var addDomEventFunctionCall = builder.functionCall(addDomEvent, helperArgs);\n\n    el.onBeforeGenerateCode((event) => {\n        event.insertCode([\n            idVarNode,\n            addDomEventFunctionCall\n        ]);\n    });\n}\n\nfunction addCustomEventListener(transformHelper, eventType, targetMethod, extraArgs) {\n    var builder = transformHelper.builder;\n\n    // Make sure the component has an assigned scope ID so that we can bind the custom event listener\n    var componentArgs = transformHelper.getComponentArgs();\n\n    if (extraArgs) {\n        extraArgs = builder.arrayExpression(extraArgs);\n    }\n\n    componentArgs.addCustomEvent(eventType, targetMethod, extraArgs);\n}\n\nmodule.exports = function handleComponentEvents() {\n    var el = this.el;\n    var builder = this.builder;\n    var context = this.context;\n    var isCustomTag = el.type !== 'HtmlElement';\n    // We configured the Marko compiler to attach a flag to nodes that\n    // have one or more attributes that match the \"w-on*\" pattern.\n    // We still need to loop over the properties to find and handle\n    // the properties corresponding to those attributes.\n    var hasComponentEvents = this.el.isFlagSet('hasComponentEvents') === true;\n\n    if (hasComponentEvents) {\n        var attrs = el.getAttributes().concat([]);\n\n        attrs.forEach((attr) => {\n            var eventType;\n            var targetMethod;\n            var attrName = attr.name;\n            var argument = attr.argument;\n            var parsedArgs;\n            var extraArgs;\n\n            if (!attrName) {\n                return;\n            }\n\n            if (attrName.startsWith('on') && argument) {\n                eventType = attrName.substring(2); // Chop off \"on\"\n                try {\n                    parsedArgs = builder.parseJavaScriptArgs(argument);\n                } catch (err) {\n                    this.addError('Invalid Javascript Expression for \"' + attrName + '\": ' + err);\n                    return;\n                }\n\n                targetMethod = builder.replacePlaceholderEscapeFuncs(parsedArgs[0], context);\n\n\n\n                if (parsedArgs.length > 1) {\n                    extraArgs = parsedArgs.slice(1);\n                }\n            } else if (attrName.startsWith('w-on')) {\n                context.deprecate('\"w-on*\" attributes are deprecated. Please use \"on*()\" instead.');\n                eventType = attrName.substring(4); // Chop off \"w-on\"\n                targetMethod = attr.value;\n            }\n\n            if (!eventType || !targetMethod) {\n                return;\n            }\n\n            el.removeAttribute(attrName);\n\n            if (isCustomTag) {\n                this.assignComponentId(true /* repeated */);\n\n                // We are adding an event listener for a custom event (not a DOM event)\n                if (eventType.startsWith('-')) {\n                    // Remove the leading dash.\n                    // Example: w-on-before-show → before-show\n                    eventType = eventType.substring(1);\n                } else if (isUpperCase(eventType.charAt(0))) {\n                    // Convert first character to lower case:\n                    // Example: w-onBeforeShow → beforeShow\n                    eventType = eventType.charAt(0).toLowerCase() + eventType.substring(1);\n                }\n\n                eventType = builder.literal(eventType);\n\n                // Node is for a custom tag\n                addCustomEventListener(this, eventType, targetMethod, extraArgs);\n            } else {\n                // We are adding an event listener for a DOM event (not a custom event)\n                //\n                if (eventType.startsWith('-')) {\n                    // Remove the leading dash.\n                    // Example: w-on-before-show → before-show\n                    eventType = eventType.substring(1);\n                }\n\n                // Normalize DOM event types to be all lower case\n                eventType = eventType.toLowerCase();\n\n                // Node is for an HTML element so treat the event as a DOM event\n                var willBubble = isBubbleEvent(eventType);\n\n                eventType = builder.literal(eventType);\n\n                if (willBubble) {\n                    // The event is white listed for bubbling so we know that\n                    // we have already attached a listener on document.body\n                    // that can be used to handle the event. We will add\n                    // a \"data-w-on{eventType}\" attribute to the output HTML\n                    // for this element that will be used to map the event\n                    // to a method on the containing component.\n                    addBubblingEventListener(this, eventType, targetMethod, extraArgs);\n                } else {\n                    // The event does not bubble so we must attach a DOM\n                    // event listener directly to the target element.\n                    addDirectEventListener(this, eventType, targetMethod, extraArgs);\n                }\n            }\n        });\n\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleComponentPreserve.js":"'use strict';\n\nfunction addPreserve(transformHelper, bodyOnly, condition) {\n    let el = transformHelper.el;\n    let context = transformHelper.context;\n    let builder = transformHelper.builder;\n\n    let preserveAttrs = {};\n\n    if (bodyOnly) {\n        preserveAttrs['body-only'] = builder.literal(bodyOnly);\n    }\n\n    if (condition) {\n        preserveAttrs['if'] = condition;\n    }\n\n    let componentIdInfo = transformHelper.assignComponentId(true /* repeated */);\n    let idVarNode = componentIdInfo.idVarNode ? null : componentIdInfo.createIdVarNode();\n\n    preserveAttrs.id = transformHelper.getIdExpression();\n\n    let preserveNode = context.createNodeForEl('w-preserve', preserveAttrs);\n    let idVarNodeTarget;\n\n    if (bodyOnly) {\n        el.moveChildrenTo(preserveNode);\n        el.appendChild(preserveNode);\n        idVarNodeTarget = el;\n    } else {\n        el.wrapWith(preserveNode);\n        idVarNodeTarget = preserveNode;\n    }\n\n    if (idVarNode) {\n        idVarNodeTarget.onBeforeGenerateCode((event) => {\n            event.insertCode(idVarNode);\n        });\n    }\n\n    return preserveNode;\n}\n\nfunction deprecatedWarning(preserveType, transformHelper, el) {\n    let attribute = preserveType.attribute;\n    let suffix = preserveType.suffix;\n    let context = transformHelper.getCompileContext();\n\n    let newAttributeName = 'no-update';\n    if (suffix) {\n        newAttributeName += suffix;\n    }\n\n    context.deprecate(`The '${attribute}' attribute is deprecated. Please use '${newAttributeName}' instead.`);\n}\n\nfunction preserveHandler(transformHelper, preserveType, el) {\n    if (preserveType.deprecated) {\n        deprecatedWarning(preserveType, transformHelper, el);\n    }\n\n    el.removeAttribute(preserveType.attribute);\n    addPreserve(transformHelper, false);\n}\n\nfunction preserveIfHandler(transformHelper, preserveType, el) {\n    if (preserveType.deprecated) {\n        deprecatedWarning(preserveType, transformHelper, el);\n    }\n\n    let attribute = preserveType.attribute;\n    let preserveIfAttr = el.getAttribute(attribute);\n    let preserveIfCondition = preserveIfAttr.argument;\n\n    if (!preserveIfCondition) {\n        transformHelper.addError(`The '${attribute}' attribute should have an argument. For example: <div ${attribute}(someCondition)>`);\n        return;\n    }\n\n    addPreserve(transformHelper, false, transformHelper.builder.expression(preserveIfCondition));\n    el.removeAttribute(attribute);\n}\n\nfunction preserveBodyHandler(transformHelper, preserveType, el) {\n    if (preserveType.deprecated) {\n        deprecatedWarning(preserveType, transformHelper, el);\n    }\n\n    el.removeAttribute(preserveType.attribute);\n    addPreserve(transformHelper, true);\n}\n\nfunction preserveBodyIfHandler(transformHelper, preserveType, el) {\n    if (preserveType.deprecated) {\n        deprecatedWarning(preserveType, transformHelper, el);\n    }\n\n    let attribute = preserveType.attribute;\n    let preserveBodyIfAttr = el.getAttribute(attribute);\n    let preserveBodyIfCondition = preserveBodyIfAttr.argument;\n\n    if (!preserveBodyIfCondition) {\n        transformHelper.addError(`The '${attribute}' attribute should have an argument. For example: <div ${attribute}(someCondition)>`);\n        return;\n    }\n\n    addPreserve(transformHelper, true, transformHelper.builder.expression(preserveBodyIfCondition));\n\n}\n\nconst preserveTypes = [\n    // The new preserve types\n    {\n        attribute: 'no-update',\n        handler: preserveHandler\n    },\n    {\n        attribute: 'no-update-if',\n        handler: preserveIfHandler\n    },\n    {\n        attribute: 'no-update-body',\n        handler: preserveBodyHandler\n    },\n    {\n        attribute: 'no-update-body-if',\n        handler: preserveBodyIfHandler\n    },\n\n    // The deprecated preserve types\n    {\n        attribute: 'w-preserve',\n        handler: preserveHandler,\n        deprecated: true\n    },\n    {\n        attribute: 'w-preserve-if',\n        suffix: '-if',\n        handler: preserveIfHandler,\n        deprecated: true\n    },\n    {\n        attribute: 'w-preserve-body',\n        suffix: '-body',\n        handler: preserveBodyHandler,\n        deprecated: true\n    },\n    {\n        attribute: 'w-preserve-body-if',\n        suffix: '-body-if',\n        handler: preserveBodyIfHandler,\n        deprecated: true\n    }\n];\n\nmodule.exports = function handleComponentPreserve() {\n    let el = this.el;\n\n    for (let i = 0; i < preserveTypes.length; i++) {\n        let preserveType = preserveTypes[i];\n\n        if (el.hasAttribute(preserveType.attribute)) {\n            preserveType.handler(this, preserveType, el);\n            el.removeAttribute(preserveType.attribute);\n            return;\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleComponentPreserveAttrs.js":"const NO_UPDATE_ATTR_SUFFIX = ':no-update';\n\nvar PRESERVE_ATTRS_HELPER_ADDED = Symbol('PRESERVE_ATTRS_HELPER_ADDED');\n\nfunction handleComponentPreserveAttrs() {\n    var el = this.el;\n    var context = this.context;\n    var builder = context.builder;\n\n    var noUpdateAttrs = [];\n\n    el.forEachAttribute(function(attr) {\n        var attrName = attr.name;\n\n        if (attrName && attrName.endsWith(NO_UPDATE_ATTR_SUFFIX)) {\n            var attrIndex = attrName.indexOf(NO_UPDATE_ATTR_SUFFIX);\n            var attrValue = el.getAttributeValue(attrName);\n\n            // Set the attribute value for the real attribute name without the\n            // :no-update suffix, and remove the :no-update suffix attribute\n            var realAttr = attrName.substr(0, attrIndex);\n            el.setAttributeValue(realAttr, attrValue);\n            el.removeAttribute(attrName);\n\n            noUpdateAttrs.push(realAttr);\n        } else if (attrName === 'w-preserve-attrs') {\n            context.deprecate(`The 'w-preserve-attrs' attribute is deprecated. Please use the ':no-update' attribute instead.`);\n\n            var preserveAttrsExpression = el.getAttributeValue('w-preserve-attrs');\n\n            noUpdateAttrs.push.apply(noUpdateAttrs, preserveAttrsExpression.value.split(','));\n            el.removeAttribute('w-preserve-attrs');\n        }\n    });\n\n    if (noUpdateAttrs.length) {\n        el.setPropertyValue('noupdate', builder.literal(noUpdateAttrs));\n\n\n        if (!context.isFlagSet(PRESERVE_ATTRS_HELPER_ADDED)) {\n            context.setFlag(PRESERVE_ATTRS_HELPER_ADDED);\n            context.addStaticCode(\n                this.builder.require(\n                    this.builder.literal('marko/runtime/vdom/preserve-attrs')));\n        }\n\n    }\n}\n\nmodule.exports = handleComponentPreserveAttrs;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleComponentBind.js":"'use strict';\nconst resolveFrom = require('resolve-from');\nconst generateRegisterComponentCode = require('../util/generateRegisterComponentCode');\n\nfunction legacyGetDefaultComponentModule(dirname) {\n    var filename;\n    var legacy = true;\n\n    if ((filename = resolveFrom(dirname, './widget'))) {\n        return {\n            filename,\n            requirePath: './widget',\n            legacy\n        };\n    } else if ((filename = resolveFrom(dirname, './component'))) {\n        return {\n            filename,\n            requirePath: './component',\n            legacy\n        };\n    } else if ((filename = resolveFrom(dirname, './'))) {\n        return {\n            filename,\n            requirePath: './',\n            legacy\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction checkIsInnerBind(el) {\n    var curNode = el;\n\n    while (true) {\n        if (curNode.data.hasBoundComponent) {\n            return true;\n        }\n\n        curNode = curNode.parentNode;\n\n        if (!curNode) {\n            break;\n        }\n    }\n\n    return false;\n}\n\nmodule.exports = function handleComponentBind() {\n    let el = this.el;\n    let context = this.context;\n    let builder = this.builder;\n\n    let componentModule;\n    let rendererModulePath;\n    let rendererModule = this.getRendererModule();\n    let isLegacyComponent = false;\n\n    if (el.hasAttribute('w-bind')) {\n        let bindAttr = el.getAttribute('w-bind');\n\n        context.deprecate('Legacy components using w-bind and defineRenderer/defineComponent or defineComponent are deprecated. See: https://github.com/marko-js/marko/issues/421');\n        this.isLegacyComponent = isLegacyComponent = true;\n\n        // Remove the w-bind attribute since we don't want it showing up in the output DOM\n        el.removeAttribute('w-bind');\n\n        // Read the value for the w-bind attribute. This will be an AST node for the parsed JavaScript\n        let bindAttrValue = bindAttr.value;\n\n        const hasWidgetTypes = context.isFlagSet('hasWidgetTypes');\n\n        if (hasWidgetTypes) {\n            context.deprecate('The <widget-types> tag is deprecated. Please remove it. See: https://github.com/marko-js/marko/issues/514');\n        }\n\n        if (bindAttrValue == null) {\n            componentModule = legacyGetDefaultComponentModule(this.dirname);\n            if (!componentModule) {\n                this.addError('No corresponding JavaScript module found in the same directory (either \"component.js\" or \"index.js\").');\n                return;\n            }\n        } else if (bindAttr.isLiteralValue()) {\n             if (typeof bindAttr.literalValue !== 'string') {\n                 this.addError('The value for the \"w-bind\" attribute should be a string. Actual: ' + componentModule);\n                 return;\n             }\n\n             let requirePath = bindAttr.literalValue;\n             let filename = resolveFrom(this.dirname, requirePath);\n\n             if (!filename) {\n                 this.addError('Target file not found: ' + requirePath + ' (from: ' + this.dirname + ')');\n                 return;\n             }\n\n             componentModule = {\n                 legacy: true,\n                 filename,\n                 requirePath\n             };\n        } else {\n            // This is a dynamic expression. The <widget-types> should have been found.\n            if (!hasWidgetTypes) {\n                this.addError('The <widget-types> tag must be used to declare components when the value of the \"w-bind\" attribute is a dynamic expression.');\n                return;\n            }\n\n            el.insertSiblingBefore(\n                builder.functionCall(\n                    builder.memberExpression(builder.identifier('__component'), builder.identifier('t')),\n                    [\n                        builder.memberExpression(\n                            builder.identifier('marko_componentTypes'),\n                            bindAttrValue,\n                            true /* computed */)\n                    ]));\n        }\n    } else if (el.isFlagSet('hasComponentBind')) {\n        componentModule = this.getComponentModule();\n        rendererModulePath = this.getRendererModule();\n\n\n        if (context.isFlagSet('hasWidgetTypes')) {\n            context.addError('The <widget-types> tag is no longer supported. See: https://github.com/marko-js/marko/issues/514');\n        }\n    } else {\n        return;\n    }\n\n    this.setHasBoundComponentForTemplate();\n\n    let isInnerBind = checkIsInnerBind(el.parentNode);\n\n    el.data.hasBoundComponent = true;\n\n    // A component is bound to the el...\n\n    var componentProps = isInnerBind ? {} : this.getComponentProps();\n    let transformHelper = this;\n\n    var isSplit = false;\n\n    if ((rendererModule && rendererModule !== componentModule) ||\n        (!rendererModule && componentModule)) {\n        componentProps.split = isSplit = true;\n    }\n\n    if (componentModule) {\n        let componentTypeNode;\n        let dependencyModule = isLegacyComponent || isSplit ? componentModule : this.getTemplateModule();\n\n        if (dependencyModule.requirePath) {\n            context.addDependency({ type:'require', path: dependencyModule.requirePath });\n        }\n\n        if (isSplit) {\n            context.addDependency({ type:'require', path: 'marko/components' });\n        }\n\n        componentTypeNode = context.addStaticVar(\n            'marko_componentType',\n            generateRegisterComponentCode(componentModule, this, isSplit));\n\n        componentProps.type = componentTypeNode;\n    }\n\n    if (el.hasAttribute('w-config')) {\n        el.insertSiblingBefore(\n            builder.functionCall(\n                builder.memberExpression(builder.identifier('__component'), builder.identifier('c')),\n                [\n                    el.getAttributeValue('w-config')\n                ]));\n\n        el.removeAttribute('w-config');\n    }\n\n    let id = el.getAttributeValue('id');\n\n    if (id) {\n        componentProps.id = id;\n    }\n\n    let markoComponentVar;\n\n    if (rendererModule) {\n        if (rendererModule.inlineId) {\n            markoComponentVar = rendererModule.inlineId;\n        } else {\n            markoComponentVar = context.addStaticVar('marko_component', builder.require(builder.literal(rendererModule.requirePath)));\n        }\n    }\n\n    if (isInnerBind) {\n        el.setAttributeValue('id',\n            builder.memberExpression(\n                builder.identifier('__component'),\n                builder.identifier('id')));\n\n        // TODO Deprecation warning for inner binds\n        let componentNode = context.createNodeForEl('_component', {\n            props: builder.literal(componentProps)\n        });\n        el.wrapWith(componentNode);\n        return;\n    }\n\n    if (this.firstBind) {\n        this.context.on('beforeGenerateCode:TemplateRoot', function(eventArgs) {\n            eventArgs.node.addRenderFunctionParam(builder.identifier('__component'));\n\n            if (isLegacyComponent) {\n                eventArgs.node.addRenderFunctionParam(builder.identifier('widget'));\n            } else {\n                eventArgs.node.addRenderFunctionParam(builder.identifier('component'));\n                eventArgs.node.addRenderFunctionParam(builder.identifier('state'));\n            }\n\n            eventArgs.node.generateAssignRenderCode = function(eventArgs) {\n                let nodes = [];\n                let templateVar = eventArgs.templateVar;\n                let templateRendererMember = eventArgs.templateRendererMember;\n                let renderFunctionVar = eventArgs.renderFunctionVar;\n\n                let createRendererArgs = [\n                    renderFunctionVar,\n                    builder.literal(componentProps)\n                ];\n\n                if (markoComponentVar) {\n                    createRendererArgs.push(markoComponentVar);\n                }\n\n                nodes.push(builder.assignment(\n                    templateRendererMember,\n                    builder.functionCall(\n                        builder.memberExpression(transformHelper.markoComponentsVar, builder.identifier('r')),\n                        createRendererArgs)));\n\n                if (!isSplit && !isLegacyComponent) {\n                    nodes.push(builder.assignment(\n                        builder.memberExpression(templateVar, builder.identifier('Component')),\n                        builder.functionCall(\n                            builder.memberExpression(transformHelper.markoComponentsVar, builder.identifier('c')),\n                            [\n                                markoComponentVar,\n                                templateRendererMember\n                            ])));\n                }\n\n                return nodes;\n            };\n        });\n    }\n\n    if (el.hasAttribute('key')) {\n        if (!componentProps.roots) {\n            componentProps.roots = [];\n        }\n        var key = el.getAttributeValue('key');\n        componentProps.roots.push(key);\n    } else if (el.hasAttribute('ref')) {\n        if (!componentProps.roots) {\n            componentProps.roots = [];\n        }\n        var ref = el.getAttributeValue('ref');\n        componentProps.roots.push(ref);\n    } else {\n        el.setAttributeValue('id',\n            builder.memberExpression(\n                builder.identifier('__component'),\n                builder.identifier('id')));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/util/generateRegisterComponentCode.js":"'use strict';\n\nconst tryRequire = require('try-require');\nconst lassoModulesClientTransport = tryRequire('lasso-modules-client/transport', require);\nconst ok = require('assert').ok;\n\nfunction generateRegisterComponentCode(componentModule, transformHelper, isSplit) {\n    ok(componentModule, '\"componentModule\" is required');\n    ok(transformHelper, '\"transformHelper\" is required');\n    ok(typeof componentModule.filename === 'string', '\"componentModule.filename\" should be a string');\n    ok(typeof transformHelper.dirname === 'string', '\"transformHelper.dirname\" should be a string');\n\n    let context = transformHelper.context;\n\n    let builder = context.builder;\n\n    let registerComponent = context.addStaticVar('marko_registerComponent',\n        builder.memberExpression(transformHelper.markoComponentsVar, builder.identifier('rc')));\n\n    let typeName = componentModule.filename;\n\n    var isLegacy = componentModule.legacy;\n\n    if (!isLegacy && !isSplit) {\n        typeName = transformHelper.filename;\n    }\n\n    if (lassoModulesClientTransport) {\n        typeName = lassoModulesClientTransport.getClientPath(typeName);\n    }\n\n    let def;\n\n    if (componentModule.legacy) {\n        // This if condition block should be deleted in Marko v5\n        let returnValue = builder.require(builder.literal(componentModule.requirePath));\n\n        let defineComponent = context.addStaticVar('marko_defineWidget',\n            builder.memberExpression(transformHelper.markoComponentsVar, builder.identifier('w')));\n\n        returnValue = builder.functionCall(defineComponent, [returnValue]);\n\n        def = builder.functionDeclaration(null, [] /* params */, [\n            builder.returnStatement(returnValue)\n        ]);\n    } else if (isSplit) {\n        let returnValue = builder.require(builder.literal(componentModule.requirePath));\n\n        def = builder.functionDeclaration(null, [] /* params */, [\n            builder.returnStatement(returnValue)\n        ]);\n    } else {\n        def = builder.functionDeclaration(null, [], [\n            builder.returnStatement(\n                builder.memberExpression(\n                    builder.identifier('module'),\n                    builder.identifier('exports')))\n        ]);\n    }\n\n    return builder.functionCall(registerComponent, [\n        builder.literal(typeName),\n        def\n    ]);\n}\n\nmodule.exports = generateRegisterComponentCode;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/TransformHelper/handleComponentFor.js":"module.exports = function handleComponentFor() {\n    var el = this.el;\n    var context = this.context;\n\n    var componentFor;\n    if (el.hasAttribute('for-ref')) {\n        context.deprecate('The \"for-ref\" tag is deprecated. Please use \"for-key\" instead.');\n        componentFor = el.getAttributeValue('for-ref');\n        el.removeAttribute('for-ref');\n    } else if (el.hasAttribute('for-key')) {\n        componentFor = el.getAttributeValue('for-key');\n        el.removeAttribute('for-key');\n    }\n\n    if (el.hasAttribute('w-for')) {\n        context.deprecate('The \"w-for\" tag is deprecated. Please use \"for-ref\" instead.');\n        if (componentFor) {\n            this.addError('The \"w-for\" tag cannot be used with \"for-ref\" or \"for-key\".');\n            return;\n        } else {\n            componentFor = el.getAttributeValue('w-for');\n        }\n        el.removeAttribute('w-for');\n    }\n\n    if (componentFor == null) {\n        return;\n    }\n\n    // Handle the \"for-ref\" attribute\n    if (el.hasAttribute('for')) {\n        this.addError('The \"for-ref\", \"for-key\", and \"w-for\" attribute cannot be used in conjuction with the \"for\" attribute. (' + (el.pos ? context.getPosInfo(el.pos) : context.filename) + ')');\n    } else {\n        el.setAttributeValue(\n            'for',\n            this.buildComponentElIdFunctionCall(componentFor));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/component-tag.js":"'use strict';\n\nvar BIND_WIDGET_KEY = Symbol();\nmodule.exports = function codeGenerator(el, codegen) {\n    var builder = codegen.builder;\n    var context = codegen.context;\n\n    var bodyFunc = builder.renderBodyFunction(el.body, [\n            builder.identifierOut(),\n            builder.identifier('__component'),\n            builder.identifier('state')\n        ]);\n\n\n    var componentProps = el.getAttributeValue('props');\n\n    var bindComponentVar = context.addStaticVar('marko_bindComponent',\n        builder.require(\n            builder.literal('marko/components/taglib/helpers/bindComponent')));\n\n    if (context.data[BIND_WIDGET_KEY] == null) {\n        context.data[BIND_WIDGET_KEY] = 0;\n    }\n\n    var varName = context.addStaticVar(\n        'marko_bindComponent' + (context.data[BIND_WIDGET_KEY]++),\n        builder.functionCall(bindComponentVar, [\n                componentProps\n            ]));\n\n    return builder.functionCall(varName, [bodyFunc, builder.identifierOut()]);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/getRequirePath-browser.js":"module.exports = function getRequirePath(target, template) {\n    return template.getRequirePath(target);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/include-tag-browser.js":"var normalInclude = require('../../taglibs/core/include-tag').$__doInclude;\nvar componentsUtil = require('../util');\nvar getElementById = componentsUtil.$__getElementById;\n\nvar getComponentsContext = require('../ComponentsContext').$__getComponentsContext;\n\nmodule.exports = function include(input, out) {\n    if (!normalInclude(input, out)) {\n        var elId = input._elId;\n\n        // There's no body content so let's see if we should reuse\n        // the existing body content in the DOM\n        var existingEl = getElementById(out.$__document, elId);\n        if (existingEl) {\n            var componentsContext = getComponentsContext(out);\n            componentsContext.$__globalContext.$__preserveDOMNode(elId, true /* body only */);\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/include-tag.js":"\nfunction doInclude(input, out, throwError) {\n    var target = input._target;\n    var arg = input._arg || input;\n\n    if (target) {\n        if (typeof target === 'function') {\n            return target(out, arg), true;\n        } else if (typeof target === 'string') {\n            return (target && out.text(target)), true;\n        } else if (typeof target === 'object') {\n            if (target.renderBody) {\n                return target.renderBody(out, arg), true;\n            } else if (target.renderer) {\n                return target.renderer(arg, out), true;\n            } else if (target.render) {\n                return target.render(arg, out), true;\n            } else if (target.safeHTML) {\n                return out.write(target.safeHTML), true;\n            } else {\n                if (throwError) {\n                    out.error('Invalid include target');\n                }\n            }\n        }\n    }\n}\n\nfunction includeTag(input, out) {\n    doInclude(input, out, true);\n}\n\nincludeTag.$__doInclude = doInclude;\n\nmodule.exports = includeTag;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/include-tag.js":"var normalInclude = require('../../taglibs/core/include-tag');\n\nmodule.exports = function include(input, out) {\n    normalInclude(input, out);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/init-components-tag-browser.js":"// This tag is a noop in the browser\nmodule.exports = function noop() {};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/init-components-tag.js":"const INIT_COMPONENTS_KEY = Symbol();\n\nvar writeInitComponentsCode = require('../').writeInitComponentsCode;\n\nvar ComponentsContext = require('../ComponentsContext');\n\nfunction handleAwaitBeforeRender(eventArgs) {\n    if (eventArgs.clientReorder) {\n        var asyncFragmentOut = eventArgs.out;\n        asyncFragmentOut.data.components = new ComponentsContext(asyncFragmentOut, undefined, false);\n    }\n}\n\nfunction handleAwaitFinish(eventArgs) {\n    var asyncFragmentOut = eventArgs.out;\n    writeInitComponentsCode(asyncFragmentOut, false);\n}\n\nmodule.exports = function render(input, out) {\n    var global = out.global;\n    if (global[INIT_COMPONENTS_KEY] === undefined) {\n        global[INIT_COMPONENTS_KEY] = true;\n\n        out.on('await:beforeRender', handleAwaitBeforeRender);\n        out.on('await:finish', handleAwaitFinish);\n\n        if (out.isSync() === true) {\n            // Generate initialization code for any of the UI components that were\n            // rendered synchronously\n            writeInitComponentsCode(out, true);\n        } else {\n            // Generate initialization code for any of the UI components that were\n            // rendered asynchronously, but were outside an `<await>` tag\n            // (each `<await>` tag will have its own component initialization block)\n            var asyncOut = out.beginAsync({ last: true, timeout: -1 });\n            out.onLast(function(next) {\n                writeInitComponentsCode(asyncOut, true);\n                asyncOut.end();\n                next();\n            });\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/index.js":"'use strict';\n\nvar warp10 = require('warp10');\nvar escapeEndingScriptTagRegExp = /<\\//g;\n\nfunction flattenHelper(components, flattened, typesArray, typesLookup) {\n    for (var i = 0, len = components.length; i < len; i++) {\n        var componentDef = components[i];\n        var id = componentDef.id;\n        var component = componentDef.$__component;\n        var state = component.state;\n        var input = component.input;\n        var typeName = component.typeName;\n        var customEvents = component.$__customEvents;\n        var scope = component.$__scope;\n\n        component.state = undefined; // We don't use `delete` to avoid V8 deoptimization\n        component.input = undefined; // We don't use `delete` to avoid V8 deoptimization\n        component.typeName = undefined;\n        component.id = undefined;\n        component.$__customEvents = undefined;\n        component.$__scope = undefined;\n\n        if (!typeName) {\n            continue;\n        }\n\n        var typeIndex = typesLookup[typeName];\n        if (typeIndex === undefined) {\n            typeIndex = typesArray.length;\n            typesArray.push(typeName);\n            typesLookup[typeName] = typeIndex;\n        }\n\n        var children = componentDef.$__children;\n\n        if (children !== null) {\n            // Depth-first search (children should be initialized before parent)\n            flattenHelper(children, flattened, typesArray, typesLookup);\n            componentDef.$__children = null;\n        }\n\n        var hasProps = false;\n\n        for (var key in component) {\n            if (component.hasOwnProperty(key) && component[key] !== undefined) {\n                hasProps = true;\n            }\n        }\n\n        var undefinedPropNames;\n\n        if (state) {\n            // Update state properties with an `undefined` value to have a `null`\n            // value so that the property name will be serialized down to the browser.\n            // This ensures that we add the proper getter/setter for the state property.\n            for (var k in state) {\n                if (state[k] === undefined) {\n                    if (undefinedPropNames) {\n                        undefinedPropNames.push(k);\n                    } else {\n                        undefinedPropNames = [k];\n                    }\n                }\n            }\n        }\n\n        var extra = {\n            p: customEvents && scope, // Only serialize scope if we need to attach custom events\n            d: componentDef.$__domEvents,\n            b: componentDef.$__bubblingDomEvents,\n            e: customEvents,\n            w: hasProps ? component : undefined,\n            s: state,\n            r: componentDef.$__roots,\n            u: undefinedPropNames\n        };\n\n        flattened.push([\n            id,                  // 0 = id\n            typeIndex,           // 1 = type\n            input,               // 2 = input\n            extra                // 3\n        ]);\n    }\n}\n\nfunction getRenderedComponents(out, shouldIncludeAll) {\n    var componentDefs;\n    var globalComponentsContext;\n\n    if (shouldIncludeAll === true) {\n        globalComponentsContext = out.global.components;\n\n        if (globalComponentsContext === undefined) {\n            return undefined;\n        }\n    } else {\n        let componentsContext = out.data.components;\n        if (componentsContext === undefined) {\n            return undefined;\n        }\n        let rootComponentDef = componentsContext.$__componentStack[0];\n        componentDefs = rootComponentDef.$__children;\n\n        if (componentDefs === null) {\n            return undefined;\n        }\n\n        rootComponentDef.$__children = null;\n    }\n\n    var flattened = [];\n    var typesLookup = {};\n    var typesArray = [];\n\n    if (shouldIncludeAll === true) {\n        let roots = globalComponentsContext.$__roots;\n        for (let i=0, len=roots.length; i<len; i++) {\n            let root = roots[i];\n            let children = root.$__children;\n            if (children !== null) {\n                flattenHelper(children, flattened, typesArray, typesLookup);\n            }\n        }\n    } else {\n        flattenHelper(componentDefs, flattened, typesArray, typesLookup);\n    }\n\n    if (flattened.length === 0) {\n        return undefined;\n    }\n\n    return {w: flattened, t: typesArray};\n}\n\nfunction writeInitComponentsCode(out, shouldIncludeAll) {\n    var renderedComponents = getRenderedComponents(out, shouldIncludeAll);\n    if (renderedComponents === undefined) {\n        return;\n    }\n\n    var cspNonce = out.global.cspNonce;\n    var nonceAttr = cspNonce ? ' nonce='+JSON.stringify(cspNonce) : '';\n\n    out.write('<script' + nonceAttr + '>' +\n        '(function(){var w=window;w.$components=(w.$components||[]).concat(' +\n        warp10.stringify(renderedComponents).replace(escapeEndingScriptTagRegExp, '\\\\u003C/') +\n         ')||w.$components})()</script>');\n}\n\nexports.writeInitComponentsCode = writeInitComponentsCode;\n\n/**\n * Returns an object that can be sent to the browser using JSON.stringify. The parsed object should be\n * passed to require('marko-components').initComponents(...);\n *\n * @param  {ComponentsContext|AsyncWriter} componentsContext A ComponentsContext or an AsyncWriter\n * @return {Object} An object with information about the rendered components that can be serialized to JSON. The object should be treated as opaque\n */\nexports.getRenderedComponents = function(out) {\n    var renderedComponents = getRenderedComponents(out, true);\n    return warp10.stringifyPrepare(renderedComponents);\n};\n\nexports.r = require('./renderer');\n\nexports.c = function() { /* no op for defining a component on teh server */ };\n\n// registerComponent is a no-op on the server.\n// Fixes https://github.com/marko-js/marko-components/issues/111\nexports.rc = function(typeName) { return typeName; };\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/preserve-tag.js":"var componentsUtil = require('../util');\nvar getElementById = componentsUtil.$__getElementById;\n\nvar getComponentsContext = require('../ComponentsContext').$__getComponentsContext;\n\nmodule.exports = function render(input, out) {\n\n    var global = out.global;\n\n    if (global.$w !== undefined) {\n        var id = input.id;\n\n        // See if the DOM node with the given ID already exists.\n        // If so, then reuse the existing DOM node instead of re-rendering\n        // the children. We have to put a placeholder node that will get\n        // replaced out if we find that the DOM node has already been rendered\n        var condition = input['if'];\n        if (condition !== false) {\n            var existingEl = getElementById(out.$__document, id);\n            if (existingEl) {\n                var componentsContext = getComponentsContext(out);\n                var bodyOnly = input.bodyOnly === true;\n                // Don't actually render anything since the element is already in the DOM,\n                // but keep track that the node is being preserved so that we can ignore\n                // it while transforming the old DOM\n\n                if (!bodyOnly) {\n                    var tagName = existingEl.tagName;\n                    // If we are preserving the entire DOM node (not just the body)\n                    // then that means that we have need to render a placeholder to\n                    // mark the target location. We can then replace the placeholder\n                    // node with the existing DOM node\n                    out.element(tagName, { id: id });\n                }\n\n                componentsContext.$__globalContext.$__preserveDOMNode(id, bodyOnly);\n                return;\n            }\n        }\n    }\n\n    if (input.renderBody) {\n        input.renderBody(out);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/widget-types-tag.js":"'use strict';\n\nconst getTransformHelper = require('./util/getTransformHelper');\nconst generateRegisterComponentCode = require('./util/generateRegisterComponentCode');\nconst resolveFrom = require('resolve-from');\n\nmodule.exports = function codeGenerator(el, codegen) {\n    var context = codegen.context;\n    var transformHelper = getTransformHelper(el, context);\n\n    transformHelper.isLegacyComponent = true;\n\n    var builder = codegen.builder;\n\n    var attrs = el.getAttributes();\n\n    var typesObject = {};\n\n    attrs.forEach((attr) => {\n        if (!attr.isLiteralString()) {\n            codegen.addError('Component type should be a string');\n            return;\n        }\n\n        let requirePath = attr.literalValue;\n\n        let filename = resolveFrom(transformHelper.dirname, requirePath);\n\n        if (!filename) {\n            transformHelper.addError('Target file not found: ' + requirePath + ' (from: ' + transformHelper.dirname + ')');\n            return;\n        }\n\n        let componentModule = {\n            legacy: true,\n            filename: filename,\n            requirePath: requirePath\n        };\n\n        typesObject[attr.name] = generateRegisterComponentCode(componentModule, transformHelper, false);\n    });\n\n    codegen.addStaticVar('marko_componentTypes', builder.literal(typesObject));\n\n    return null;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/html/helper-createInlineTemplate.js":"var Template = require('./Template');\n\nmodule.exports = function(path, renderFunc) {\n    return new Template(path, renderFunc);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/loader/index-browser-dynamic.js":"'use strict';\nmodule.exports = function load(templatePath) {\n    // We make the assumption that the template path is a\n    // fully resolved module path and that the module exists\n    // as a CommonJS module\n    return require(templatePath);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/loader/index-browser.js":"'use strict';\nmodule.exports = function load(templatePath) {\n    throw Error('Not found: ' + templatePath);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/helper-styleAttr.js":"var dashedNames = {};\n\n/**\n * Helper for generating the string for a style attribute\n * @param  {[type]} style [description]\n * @return {[type]}       [description]\n */\nmodule.exports = function(style) {\n    if (!style) {\n        return null;\n    }\n\n    var type = typeof style;\n\n    if (type === 'string') {\n        return style;\n    } else if (type === 'object') {\n        var styles = '';\n        for (var name in style) {\n            var value = style[name];\n            if (value != null) {\n                if (typeof value === 'number' && value) {\n                    value += 'px';\n                }\n\n                var nameDashed = dashedNames[name];\n                if (!nameDashed) {\n                    nameDashed = dashedNames[name] = name.replace(/([A-Z])/g, '-$1').toLowerCase();\n                }\n                styles += nameDashed + ':' + value + ';';\n            }\n        }\n        return styles || null;\n    } else {\n        return null;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/runtime/vdom/preserve-attrs.js":"var extend = require('raptor-util/extend');\n\nfunction removePreservedAttributes(attrs, props, clone) {\n    var preservedAttrs = props && props.noupdate;\n    if (preservedAttrs) {\n        if (clone) {\n            attrs = extend({}, attrs);\n        }\n        preservedAttrs.forEach(function(preservedAttrName) {\n            delete attrs[preservedAttrName];\n        });\n    }\n\n    return attrs;\n}\n\nrequire('./VElement').$__removePreservedAttributes = removePreservedAttributes;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/async-fragment-to-await-transformer.js":"'use strict';\n\nvar newTags = {\n    'async-fragment':'await',\n    'async-fragments':'await-reorderer',\n    'async-fragment-placeholder':'await-placeholder',\n    'async-fragment-timeout':'await-timeout',\n    'async-fragment-error':'await-error'\n};\n\nmodule.exports = function transform(oldNode, context) {\n    var oldTag = oldNode.tagName;\n    var newTag = newTags[oldTag];\n    var provider;\n    var varName;\n    var argument;\n\n    context.deprecate('The <'+oldTag+'> tag is deprecated.  Please use <'+newTag+'> instead.');\n\n    if(oldTag == 'async-fragment'/* new: <await> */) {\n        // need to convert data-provider and var attributes\n        // to an argument: <await(var from dataProvider)>\n        varName = oldNode.getAttributeValue('var').value;\n        provider = oldNode.getAttributeValue('data-provider').toString();\n        argument = varName + ' from ' + provider;\n\n        // now remove the attributes\n        oldNode.removeAttribute('var');\n        oldNode.removeAttribute('data-provider');\n    }\n\n    if(oldTag == 'async-fragments'/* new: <await-reorderer> */) {\n        // all this tag ever did was handling of client reordering\n        // we'll remove the attribute as that's all this new tag does\n        oldNode.removeAttribute('client-reorder');\n    }\n\n    var newNode = context.createNodeForEl(\n        newTag,\n        oldNode.getAttributes(),\n        argument\n    );\n\n    oldNode.replaceWith(newNode);\n    oldNode.moveChildrenTo(newNode);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/await-nested-tag-transformer.js":"'use strict';\n\nmodule.exports = function transform(el, context) {\n    var parentNode = el.parentNode;\n\n    if (parentNode.tagName !== 'await') {\n        context.addError('The <' + el.tagName + '> should be nested within an <await> tag.');\n        return;\n    }\n\n    var targetProp;\n\n    if (el.tagName === 'await-error') {\n        targetProp = 'renderError';\n    } else if (el.tagName === 'await-timeout') {\n        targetProp = 'renderTimeout';\n    } else if (el.tagName === 'await-placeholder') {\n        targetProp = 'renderPlaceholder';\n    }\n\n    var builder = context.builder;\n\n    parentNode.setAttributeValue(targetProp, builder.renderBodyFunction(el.body));\n    el.detach();\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/await-reorderer-tag.js":"'use strict';\n\nconst clientReorder = require('./client-reorder');\n\nmodule.exports = function(input, out) {\n    // We cannot call beginSync() when using renderSync(). In this case we will\n    // ignore the await-reorderer tag.\n    if (out.isSync()) {\n        return;\n    }\n\n    var global = out.global;\n\n    out.flush();\n\n    // We have already invoked an <await-reorderer. We do not need to do this\n    // work again.\n    if (global.__awaitReordererInvoked) {\n        return;\n    }\n\n    global.__awaitReordererInvoked = true;\n\n\n\n    var asyncOut = out.beginAsync({ last: true, timeout: -1, name: 'await-reorderer' });\n    out.onLast(function(next) {\n        var awaitContext = global.__awaitContext;\n        var remaining;\n\n        // Validate that we have remaining <await> instances that need handled\n        if (!awaitContext || !awaitContext.instances || !(remaining = awaitContext.instances.length)) {\n            asyncOut.end();\n            next();\n            return;\n        }\n\n        var done = false;\n\n        function handleAwait(awaitInfo) {\n            awaitInfo.asyncValue.done(function(err, html) {\n                if (done) {\n                    return;\n                }\n\n                if (err) {\n                    done = true;\n                    return asyncOut.error(err);\n                }\n\n                if (!global._afRuntime) {\n                    asyncOut.write(clientReorder.getCode());\n                    global._afRuntime = true;\n                }\n\n                asyncOut.write('<div id=\"af' + awaitInfo.id + '\" style=\"display:none\">' +\n                    html +\n                    '</div>' +\n                    '<script type=\"text/javascript\">$af(' +\n                        (typeof awaitInfo.id === 'number' ? awaitInfo.id : '\"' + awaitInfo.id + '\"') +\n                        (awaitInfo.after ? (',\"' + awaitInfo.after + '\"') : '' ) +\n                    ')</script>');\n\n                awaitInfo.out.writer = asyncOut.writer;\n\n                out.emit('await:finish', awaitInfo);\n\n                out.flush();\n\n                if (--remaining === 0) {\n                    done = true;\n                    asyncOut.end();\n                    next();\n                }\n            });\n        }\n\n        awaitContext.instances.forEach(handleAwait);\n\n        out.on('await:clientReorder', function(awaitInfo) {\n            remaining++;\n            handleAwait(awaitInfo);\n        });\n\n        // Now that we have a listener attached, we want to receive any additional\n        // out-of-sync instances via an event\n        delete awaitContext.instances;\n    });\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/client-reorder.js":"var code;\nvar fs = require('fs');\n\nexports.isSupported = true;\n\nexports.getCode = function() {\n    if (!code) {\n        code = fs.readFileSync(require.resolve('./client-reorder-runtime.min.js'), 'utf8');\n        code = '<script type=\"text/javascript\">' + code + '</script>';\n    }\n    return code;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/await-tag.js":"'use strict';\n\nvar logger = require('raptor-logging').logger(module);\nvar AsyncValue = require('raptor-async/AsyncValue');\nvar isClientReorderSupported = require('./client-reorder').isSupported;\nvar nextTick = require('../../runtime/nextTick');\n\nfunction isPromise(o) {\n    return o && typeof o.then === 'function';\n}\n\nfunction safeRenderBody(renderBody, targetOut, data) {\n    try {\n        renderBody(targetOut, data);\n    } catch(err) {\n        return err;\n    }\n}\n\nfunction promiseToCallback(promise, callback, thisObj) {\n    if (callback) {\n        var finalPromise = promise\n            .then(function(data) {\n                nextTick(callback.bind(this, null, data));\n            })\n            .then(null, function(err) {\n                nextTick(callback.bind(this, err));\n            });\n\n        if (finalPromise.done) {\n            finalPromise.done();\n        }\n    }\n\n    return promise;\n}\n\nfunction requestData(provider, args, callback, thisObj) {\n    if (isPromise(provider)) {\n        // promises don't support a scope so we can ignore thisObj\n        promiseToCallback(provider, callback);\n        return;\n    }\n\n    if (typeof provider === 'function') {\n        var data = (provider.length === 1) ?\n            // one argument so only provide callback to function call\n            provider.call(thisObj, callback) :\n            // two arguments so provide args and callback to function call\n            provider.call(thisObj, args, callback);\n\n        if (data !== undefined) {\n            if (isPromise(data)) {\n                promiseToCallback(data, callback);\n            }\n            else {\n                callback(null, data);\n            }\n        }\n    } else {\n        // Assume the provider is a data object...\n        callback(null, provider);\n    }\n}\n\nmodule.exports = function awaitTag(input, out) {\n    var dataProvider = input._dataProvider;\n    var arg = input.arg || {};\n    arg.out = out;\n\n    var clientReorder = isClientReorderSupported && input.clientReorder === true && !out.isVDOM;\n    var asyncOut;\n    var timeoutId = null;\n    var name = input.name || input._name;\n    var scope = input.scope || this;\n    var method = input.method;\n\n    if (method) {\n        dataProvider = dataProvider[method].bind(dataProvider);\n    }\n\n    var awaitInfo = {\n        name: name,\n        clientReorder: clientReorder,\n        dataProvider: dataProvider\n    };\n\n    var beforeRenderEmitted = false;\n\n    out.emit('await:begin', awaitInfo);\n\n    function renderBody(err, data, renderTimeout) {\n        if (awaitInfo.finished) return;\n\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n\n        var targetOut = awaitInfo.out = asyncOut || out;\n\n        if (!beforeRenderEmitted) {\n            beforeRenderEmitted = true;\n            out.emit('await:beforeRender', awaitInfo);\n        }\n\n        if (err) {\n            if (input.renderError) {\n                console.error('Await (' + name + ') failed. Error:', (err.stack || err));\n                input.renderError(targetOut);\n            } else {\n                targetOut.error(err);\n            }\n        } else if (renderTimeout) {\n            renderTimeout(targetOut);\n        } else {\n            var renderBodyFunc = input.renderBody;\n            if (renderBodyFunc) {\n                var renderBodyErr = safeRenderBody(renderBodyFunc, targetOut, data);\n                if (renderBodyErr) {\n                    return renderBody(renderBodyErr);\n                }\n            }\n        }\n\n        awaitInfo.finished = true;\n\n        if (!clientReorder) {\n            out.emit('await:finish', awaitInfo);\n        }\n\n        if (asyncOut) {\n            asyncOut.end();\n\n            // Only flush if we rendered asynchronously and we aren't using\n            // client-reordering\n            if (!clientReorder) {\n                out.flush();\n            }\n        }\n    }\n\n    requestData(dataProvider, arg, renderBody, scope);\n\n    if (!awaitInfo.finished) {\n        var timeout = input.timeout;\n        var renderTimeout = input.renderTimeout;\n        var renderPlaceholder = input.renderPlaceholder;\n\n        if (timeout == null) {\n            timeout = 10000;\n        } else if (timeout <= 0) {\n            timeout = null;\n        }\n\n        if (timeout != null) {\n            timeoutId = setTimeout(function() {\n                var message = 'Await (' + name + ') timed out after ' + timeout + 'ms';\n\n                awaitInfo.timedout = true;\n\n                if (renderTimeout) {\n                    logger.error(message);\n                    renderBody(null, null, renderTimeout);\n                } else {\n                    renderBody(new Error(message));\n                }\n            }, timeout);\n        }\n\n        if (clientReorder) {\n            var awaitContext = out.global.__awaitContext || (awaitContext = out.global.__awaitContext = {\n                instances: [],\n                nextId: 0\n            });\n\n            var id = awaitInfo.id = input.name || (awaitContext.nextId++);\n            var placeholderIdAttrValue = 'afph' + id;\n\n            if (renderPlaceholder) {\n                out.write('<span id=\"' + placeholderIdAttrValue + '\">');\n                renderPlaceholder(out);\n                out.write('</span>');\n            } else {\n                out.write('<noscript id=\"' + placeholderIdAttrValue + '\"></noscript>');\n            }\n\n            var asyncValue = awaitInfo.asyncValue = new AsyncValue();\n\n            // If `client-reorder` is enabled then we asynchronously render the await instance to a new\n            // AsyncWriter instance so that we can Write to a temporary in-memory buffer.\n            asyncOut = awaitInfo.out = out.createOut();\n\n            awaitInfo.after = input.showAfter;\n\n            var oldEmit = asyncOut.emit;\n\n            // Since we are rendering the await instance to a new and separate out,\n            // we want to proxy any child events to the main AsyncWriter in case anyone is interested\n            // in those events. This is also needed for the following events to be handled correctly:\n            //\n            // - await:begin\n            // - await:beforeRender\n            // - await:finish\n            //\n            asyncOut.emit = function(event) {\n                if (event !== 'finish' && event !== 'error') {\n                    // We don't want to proxy the finish and error events since those are\n                    // very specific to the AsyncWriter associated with the await instance\n                    out.emit.apply(out, arguments);\n                }\n\n                oldEmit.apply(asyncOut, arguments);\n            };\n\n            asyncOut\n                .on('finish', function(result) {\n                    asyncValue.resolve(result.getOutput());\n                })\n                .on('error', function(err) {\n                    asyncValue.reject(err);\n                });\n\n            if (awaitContext.instances) {\n                awaitContext.instances.push(awaitInfo);\n            }\n\n            out.emit('await:clientReorder', awaitInfo);\n        } else {\n            out.flush(); // Flush everything up to this await instance\n            asyncOut = awaitInfo.out = out.beginAsync({\n                timeout: 0, // We will use our code for controlling timeout\n                name: name\n            });\n        }\n    } else if (clientReorder) {\n        // If the async fragment has finished synchronously then we still need to emit the `await:finish` event\n        out.emit('await:finish', awaitInfo);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/await-tag-transformer.js":"'use strict';\n\nvar isObjectEmpty = require('raptor-util/isObjectEmpty');\n\nmodule.exports = function transform(el, context) {\n    if(!el.argument) {\n        context.addError('Invalid <await> tag. Argument is missing. Example: <await(user from data.userProvider)>');\n        return;\n    }\n\n    var match = /^([$A-Z_][0-9A-Z_$]*) from (.*)$/i.exec(el.argument);\n\n    if(!match) {\n        context.addError('Invalid <await> tag. Argument is malformed. Example: <await(user from data.userProvider)>');\n        return;\n    }\n\n    var varName = match[1];\n    var dataProviderAttr = match[2];\n\n    if (!context.util.isValidJavaScriptIdentifier(varName)) {\n        context.addError('Invalid <await> tag. Argument\\'s variable name should be a valid JavaScript identifier. Example: user, as in <await(user from data.userProvider)>');\n        return;\n    }\n\n    var builder = context.builder;\n\n    el.setAttributeValue('_var', builder.literal(varName));\n    el.setAttributeValue('_dataProvider', builder.parseExpression(dataProviderAttr));\n    el.argument = null;\n\n    ////////////////////\n\n    var attrs = el.getAttributes().concat([]);\n    var arg = {};\n\n    attrs.forEach((attr) => {\n        var attrName = attr.name;\n        if (attrName.startsWith('arg-')) {\n            let argName = attrName.substring('arg-'.length);\n            arg[argName] = attr.value;\n            el.removeAttribute(attrName);\n        }\n    });\n\n    var name = el.getAttributeValue('name');\n    if (name == null) {\n        el.setAttributeValue('_name', builder.literal(dataProviderAttr));\n    }\n\n    if (el.hasAttribute('arg')) {\n        if (isObjectEmpty(arg)) {\n            arg = el.getAttributeValue('arg');\n        } else {\n            let mergeVar = context.helper('merge');\n            arg = builder.functionCall(mergeVar, [\n                builder.literal(arg), // Input props from the attributes take precedence\n                el.getAttributeValue('arg')\n            ]);\n        }\n    } else {\n        if (isObjectEmpty(arg)) {\n            arg = null;\n        } else {\n            arg = builder.literal(arg);\n        }\n    }\n\n    if (arg) {\n        el.setAttributeValue('arg', arg);\n    }\n\n    var timeoutMessage = el.getAttributeValue('timeout-message');\n    if (timeoutMessage) {\n        el.removeAttribute('timeout-message');\n        el.setAttributeValue('renderTimeout', builder.renderBodyFunction([\n            builder.text(timeoutMessage)\n        ]));\n    }\n\n    var errorMessage = el.getAttributeValue('error-message');\n    if (errorMessage) {\n        el.removeAttribute('error-message');\n        el.setAttributeValue('renderError', builder.renderBodyFunction([\n            builder.text(errorMessage)\n        ]));\n    }\n\n    var placeholder = el.getAttributeValue('placeholder');\n    if (placeholder) {\n        el.removeAttribute('placeholder');\n        el.setAttributeValue('renderPlaceholder', builder.renderBodyFunction([\n            builder.text(placeholder)\n        ]));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/client-reorder-browser.js":"exports.isSupported = false;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/async/client-reorder-runtime.js":"function $af(id, after, doc, sourceEl, targetEl, docFragment, childNodes, i, len, af) {\n    af = $af;\n\n    if (after && !af[after]) {\n        (af[(after = after + '$')] || (af[after] = [])).push(id);\n    } else {\n        doc = document;\n        sourceEl = doc.getElementById('af' + id);\n        targetEl = doc.getElementById('afph' + id);\n        docFragment = doc.createDocumentFragment();\n        childNodes = sourceEl.childNodes;\n        i = 0;\n        len=childNodes.length;\n\n        for (; i<len; i++) {\n            docFragment.appendChild(childNodes.item(0));\n        }\n\n        targetEl.parentNode.replaceChild(docFragment, targetEl);\n        af[id] = 1;\n\n        after = af[id + '$'];\n\n        if (after) {\n            i = 0;\n            len = after.length;\n\n            for (; i<len; i++) {\n                af(after[i]);\n            }\n        }\n    }\n\n    // sourceEl.parentNode.removeChild(sourceEl);\n}","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/cache/cached-fragment-tag.js":"'use strict';\nmodule.exports = {\n    render: function (input, out) {\n        var cacheKey = input.cacheKey;\n        if (!cacheKey) {\n            throw new Error('cache-key is required for <cached-fragment>');\n        }\n\n        var cacheManager = input.cacheManager;\n\n        var cache = cacheManager.getCache(input.cacheName || 'marko/cached-fragment');\n\n        var asyncOut = out.beginAsync();\n\n        cache.get(cacheKey,\n            {\n                builder: function(callback) {\n                    var nestedOut = out.createOut();\n\n                    if (input.renderBody) {\n                        input.renderBody(nestedOut);\n                    }                    \n\n                    nestedOut\n                        .on('error', callback)\n                        .on('finish', function(result) {\n                            callback(null, result.getOutput());\n                        });\n\n                    nestedOut.end();\n                }\n            }, function(err, result) {\n                if (err) {\n                    return asyncOut.error(err);\n                }\n\n                if (result.$__cloneNode) {\n                    var curChild = result.firstChild;\n                    while(curChild) {\n                        asyncOut.node(curChild.$__cloneNode());\n                        curChild = curChild.nextSibling;\n                    }\n                    asyncOut.end();\n                } else {\n                    asyncOut.end(result);\n                }\n\n\n            });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/cache/cached-fragment-tag-transformer.js":"var defaultCacheManagerPath = require.resolve('./default-cache-manager');\n\nmodule.exports = function(el, context) {\n    if (!el.hasAttribute('cache-manager')) {\n        var requirePath = context.getRequirePath(defaultCacheManagerPath);\n        var defaultCacheManagerVar = context.importModule('__defaultCacheManager', requirePath);\n        el.setAttributeValue('cache-manager', defaultCacheManagerVar);\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/cache/default-cache-manager.js":"var caches = {};\n\nfunction createCache() {\n    var cache = {};\n\n    return {\n        get: function(cacheKey, options, callback) {\n            var value = cache[cacheKey];\n            if (value !== undefined) {\n                return callback(null, value);\n            }\n\n            var builder = options.builder;\n            builder(function(err, value) {\n                if (err) {\n                    return callback(err);\n                }\n\n                if (value === undefined) {\n                    value = null;\n                }\n\n                cache[cacheKey] = value;\n\n                callback(null, value);\n            });\n        }\n    };\n}\n\nvar defaultCacheManager = {\n    getCache: function(cacheName) {\n        return caches[cacheName] || (caches[cacheName] = createCache());\n    }\n};\n\nmodule.exports = defaultCacheManager;","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/assign-tag.js":"module.exports = function codeGenerator(elNode, codegen) {\n    var context = codegen.context;\n    context.deprecate('The \"<assign>\" tag is deprecated. Please use \"$ <js_code>\" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags');\n\n    var attributes = elNode.attributes;\n\n    if (!attributes) {\n        codegen.addError('Invalid <assign> tag. Argument is missing. Example; <assign x=123 />');\n        return elNode;\n    }\n\n    var builder = codegen.builder;\n\n    return attributes.map((attr) => {\n        if (attr.value == null) {\n            return builder.parseExpression(attr.name);\n        } else {\n            return builder.assignment(attr.name, attr.value);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/class-tag.js":"module.exports = function functionCodeGenerator(el, codegen) {\n    if(el.parentNode.type !== 'TemplateRoot') {\n        codegen.addError('class is a static tag and can only be declared at the template root');\n    }\n    codegen.addStaticCode(codegen.builder.expression(el.tagString));\n    return null;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/core-transformer.js":"'use strict';\n\nvar createLoopNode = require('./util/createLoopNode');\n\nvar coreAttrHandlers = [\n    [\n        'while', function(attr, node) {\n            var whileArgument = attr.argument;\n            if (!whileArgument) {\n                return false;\n            }\n\n            var whileNode = this.builder.whileStatement(whileArgument);\n            node.wrapWith(whileNode);\n        }\n    ],\n    [\n        'for', function(attr, node) {\n            var forArgument = attr.argument;\n            if (!forArgument) {\n                return false;\n            }\n\n            var loopNode;\n\n            try {\n                loopNode = createLoopNode(forArgument, null, this.builder);\n            } catch(e) {\n                if (e.code === 'INVALID_FOR') {\n                    this.addError(e.message);\n                    return;\n                } else {\n                    throw e;\n                }\n            }\n\n\n            //Surround the existing node with the newly created loop node\n            // NOTE: The loop node will be one of the following:\n            //       ForEach, ForRange, ForEachProp or ForStatement\n            node.wrapWith(loopNode);\n        }\n    ],\n    [\n        'if', function(attr, node) {\n            var ifArgument = attr.argument;\n            if (!ifArgument) {\n                return false;\n            }\n\n            var test;\n            try {\n                test = this.builder.parseExpression(ifArgument);\n            } catch(e) {\n                test = this.builder.literalFalse();\n                this.addError('Invalid expression for if statement:\\n' + e.message);\n            }\n\n            var ifNode = this.builder.ifStatement(test);\n            //Surround the existing node with an \"If\" node\n            node.wrapWith(ifNode);\n        }\n    ],\n    [\n        'unless', function(attr, node) {\n            var ifArgument = attr.argument;\n            if (!ifArgument) {\n                return false;\n            }\n\n            var test;\n            try {\n                test = this.builder.parseExpression(ifArgument);\n            } catch(e) {\n                test = this.builder.literalFalse();\n                this.addError('Invalid expression for unless statement:\\n' + e.message);\n            }\n\n            test = this.builder.negate(test);\n            var ifNode = this.builder.ifStatement(test);\n            //Surround the existing node with an \"if\" node\n            node.wrapWith(ifNode);\n        }\n    ],\n    [\n        'else-if', function(attr, node) {\n            var elseIfArgument = attr.argument;\n            if (!elseIfArgument) {\n                return false;\n            }\n\n            var test;\n            try {\n                test = this.builder.parseExpression(elseIfArgument);\n            } catch(e) {\n                test = this.builder.literalFalse();\n                this.addError('Invalid expression for else-if statement:\\n' + e.message);\n            }\n\n            var elseIfNode = this.builder.elseIfStatement(test);\n            //Surround the existing node with an \"ElseIf\" node\n            node.wrapWith(elseIfNode);\n        }\n    ],\n    [\n        'else', function(attr, node) {\n            var elseNode = this.builder.elseStatement();\n            //Surround the existing node with an \"Else\" node\n            node.wrapWith(elseNode);\n        }\n    ],\n    [\n        'body-only-if', function(attr, node, el) {\n            var argument = attr.argument;\n            if (!argument) {\n                return false;\n            }\n\n            var test;\n            try {\n                test = this.builder.parseExpression(argument);\n            } catch(e) {\n                test = this.builder.literalFalse();\n                this.addError('Invalid expression for body-only-if statement:\\n' + e.message);\n            }\n\n            el.setBodyOnlyIf(test);\n        }\n    ],\n    [\n        'marko-preserve-whitespace', function(attr, node, el) {\n            el.setPreserveWhitespace(true);\n        }\n    ],\n    [\n        'marko-init', function(attr, node, el) {\n            if (el.tagName !== 'script') {\n                this.addError('The \"marko-init\" attribute should only be used on the <script> tag');\n                return;\n            }\n            this.context.deprecate('The \"marko-init\" attribute is deprecated.  Use the static tag instead. See https://github.com/marko-js/marko/issues/547');\n            var bodyText = el.bodyText;\n            el.noOutput = true;\n            this.context.addStaticCode(bodyText);\n            el.detach();\n            return null;\n        }\n    ],\n    [\n        'template-helpers', function(attr, node, el) {\n            if (el.tagName !== 'script') {\n                this.addError('The \"template-helpers\" attribute should only be used on the <script> tag');\n                return;\n            }\n            this.context.deprecate('The \"template-helpers\" attribute is deprecated and will be removed in the next release candidate. Use the static tag instead. See https://github.com/marko-js/marko/issues/547');\n            var bodyText = el.bodyText;\n            el.noOutput = true;\n            this.context.addStaticCode(bodyText);\n            el.detach();\n            return null;\n        }\n    ],\n    [\n        'include', function(attr, node, el) {\n            var context = this.context;\n\n            if (typeof attr.argument === 'string') {\n                if (attr.argument) {\n                    var includeNode = context.createNodeForEl('include', null, attr.argument);\n                    node.appendChild(includeNode);                    \n                } else {\n                    context.addError(el, 'The include attribute must have an argument. For example: include(\"./target.marko\") or include(data.renderBody)');\n                }\n\n            } else {\n                return false;\n            }\n        }\n    ]\n];\n\nclass AttributeTransformer {\n    constructor(context, el) {\n        this.context = context;\n        this.builder = context.builder;\n        this.el = el;\n    }\n\n    addError(message) {\n        this.context.addError({\n            node: this.el,\n            message: message\n        });\n    }\n}\n\ncoreAttrHandlers.forEach(function(attrHandler) {\n    var name = attrHandler[0];\n    var func = attrHandler[1];\n    AttributeTransformer.prototype[name] = func;\n});\n\nvar attributeTransformers = AttributeTransformer.prototype;\n\nmodule.exports = function transform(el, context) {\n    el.removeAttribute('marko-body'); // This attribute is handled at parse time. We can just remove it now\n\n    var attributeTransfomer;\n    var node = el;\n\n    el.forEachAttribute((attr) => {\n        let attrName = attr.name;\n        if (!attrName) {\n            if (!node.addDynamicAttributes) {\n                context.addError(el, 'Node does not support the \"attrs\" attribute');\n            } else {\n                node.addDynamicAttributes(attr.value);\n            }\n            return;\n        }\n        var attrTransformerFunc = attributeTransformers[attrName];\n        if (attrTransformerFunc) {\n            if (!attributeTransfomer) {\n                attributeTransfomer = new AttributeTransformer(context, el);\n            }\n            var newNode = attributeTransfomer[attrName](attr, node, el);\n            if (newNode !== false) {\n                el.removeAttribute(attrName);\n                if (newNode !== undefined) {\n                    if (newNode) {\n                        newNode.pos = node.pos;\n                    }\n\n                    node = newNode;\n                }\n            }\n        }\n    });\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/util/createLoopNode.js":"var parseFor = require('./parseFor');\n\nfunction createLoopNode(str, body, builder) {\n    var forDef = parseFor(str);\n\n    forDef.body = body;\n\n    if (forDef.loopType === 'ForEach') {\n        return builder.forEach(forDef);\n    } else if (forDef.loopType === 'ForRange') {\n        return builder.forRange(forDef);\n    } else if (forDef.loopType === 'ForEachProp') {\n        return builder.forEachProp(forDef);\n    } else if (forDef.loopType === 'For') {\n        return builder.forStatement(forDef);\n    } else {\n        throw new Error('Unsupported loop type: ' + forDef.loopType);\n    }\n}\n\nmodule.exports = createLoopNode;\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/util/parseFor.js":"'use strict';\nvar removeComments = require('../../../compiler/util/removeComments');\nvar compiler = require('../../../compiler');\n\nvar integerRegExp = /^-?\\d+$/;\nvar numberRegExp = /^-?(?:\\d+|\\d+\\.\\d*|\\d*\\.\\d+|\\d+\\.\\d+)$/;\n\nvar tokenizer = require('../../../compiler/util/tokenizer').create([\n    {\n        name: 'stringDouble',\n        pattern: /\"(?:[^\"]|\\\\\")*\"/,\n    },\n    {\n        name: 'stringSingle',\n        pattern: /'(?:[^']|\\\\')*'/\n    },\n    {\n        name: 'in',\n        pattern: /\\s+in\\s+/,\n    },\n    {\n        name: 'from',\n        pattern: /\\s+from\\s+/\n    },\n    {\n        name: 'to',\n        pattern: /\\s+to\\s+/,\n    },\n    {\n        name: 'step',\n        pattern: /\\s+step\\s+/,\n    },\n    {\n        name: 'semicolon',\n        pattern: /[;]/,\n    },\n    {\n        name: 'separator',\n        pattern: /separator=/\n    },\n    {\n        name: 'status-var',\n        pattern: /status\\-var=/\n    },\n    {\n        name: 'iterator',\n        pattern: /iterator=/\n    },\n    {\n        name: 'pipe',\n        pattern: /\\s+\\|\\s+/\n    },\n    {\n        name: 'groupOpen',\n        pattern: /[\\{\\(\\[]/\n    },\n    {\n        name: 'groupClose',\n        pattern: /[\\}\\)\\]]/\n    },\n    {\n        name: 'array',\n        pattern: /array/\n    }\n]);\n\nvar inRegExp = /^\\s*([$A-Z_][0-9A-Z_$]*)(?:\\s*,\\s*([$A-Z_][0-9A-Z_$]*))?\\s+in\\s+/i;\n\n\nfunction throwError(message) {\n    var error = new Error(message);\n    error.code = 'INVALID_FOR';\n    throw error;\n}\n\nfunction buildIdentifier(name, errorMessage) {\n    try {\n        return compiler.builder.identifier(name);\n    } catch(e) {\n        throwError(errorMessage + ': ' + e.message);\n    }\n}\n\nfunction parseExpression(str, errorMessage) {\n    try {\n        return compiler.builder.parseExpression(str);\n    } catch(e) {\n        throwError(errorMessage + ': ' + e.message);\n    }\n}\n\nfunction parseStatement(str, errorMessage) {\n    try {\n        return compiler.builder.parseStatement(str);\n    } catch(e) {\n        throwError(errorMessage + ': ' + e.message);\n    }\n}\n\nfunction createNumberExpression(str, errorMessage) {\n    if (str == null) {\n        return null;\n    }\n\n    if (integerRegExp.test(str)) {\n        return compiler.builder.literal(parseInt(str, 10));\n    } else if (numberRegExp.test(str)) {\n        return compiler.builder.literal(parseFloat(str));\n    } else {\n        return parseExpression(str, errorMessage);\n    }\n}\n\n/**\n * Parses a for loop string in the following forms:\n *\n * <varName> in <expression>\n * <varName> in <expression> | status-var=<varName> separator=<expression>\n * <varName> from <expression> to <expression>\n * <varName> from <expression> to <expression> step <expression>\n * <init>; <test>; <update>\n */\nmodule.exports = function(str) {\n    str = removeComments(str);\n\n    let depth = 0;\n    var prevToken;\n    var loopType;\n    var pipeFound = false;\n\n    var varName;\n    var nameVarName;\n    var valueVarName;\n    var inExpression;\n    var statusVarName;\n    var separatorExpression;\n    var fromExpression;\n    var toExpression;\n    var stepExpression;\n    var iteratorExpression;\n    var isArray;\n\n    var forInit;\n    var forTest;\n    var forUpdate;\n\n    var inRegExpMatches = inRegExp.exec(str);\n    if (inRegExpMatches) {\n        if (inRegExpMatches[1] && inRegExpMatches[2]) {\n            loopType = 'ForEachProp';\n            nameVarName = inRegExpMatches[1];\n            valueVarName = inRegExpMatches[2];\n        } else {\n            loopType = 'ForEach';\n            varName = inRegExpMatches[1];\n        }\n\n        str = ' in ' + str.substring(inRegExpMatches[0].length);\n    }\n\n    function finishVarName(end) {\n        varName = str.substring(0, end).trim();\n    }\n\n    function finishPrevPart(end) {\n        if (!prevToken) {\n            return;\n        }\n\n        var start = prevToken.end;\n        var part = str.substring(start, end).trim();\n\n        switch(prevToken.name) {\n            case 'from':\n                fromExpression = part;\n                break;\n            case 'to':\n                toExpression = part;\n                break;\n            case 'in':\n                inExpression = part;\n                break;\n            case 'step':\n                stepExpression = part;\n                break;\n            case 'status-var':\n                statusVarName = part;\n                break;\n            case 'separator':\n                separatorExpression = part;\n                break;\n            case 'iterator':\n                iteratorExpression = part;\n                break;\n            case 'array':\n                isArray = true;\n                break;\n            case 'pipe':\n                if (part.length !== 0) {\n                    throwError('Unexpected input: ' + part);\n                    return;\n                }\n                break;\n        }\n    }\n\n    tokenizer.forEachToken(str, (token) => {\n        switch(token.name) {\n            case 'groupOpen':\n                depth++;\n                break;\n            case 'groupClose':\n                depth--;\n                break;\n            case 'in':\n                if (depth === 0) {\n                    prevToken = token;\n                }\n                break;\n            case 'from':\n                if (depth === 0 && !loopType) {\n                    loopType = 'ForRange';\n                    finishVarName(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'to':\n                if (depth === 0 && prevToken && prevToken.name === 'from') {\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'step':\n                if (depth === 0 && prevToken && prevToken.name === 'to') {\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'semicolon':\n                if (depth === 0) {\n                    loopType = 'For';\n\n                    if (forInit == null) {\n                        forInit = str.substring(0, token.start);\n                    } else if (forTest == null) {\n                        forTest = str.substring(prevToken.end, token.start);\n                        forUpdate = str.substring(token.end);\n                    } else {\n                        throwError('Invalid native for loop. Expected format: <init>; <test>; <update>');\n                    }\n\n                    prevToken = token;\n                }\n                break;\n            case 'pipe':\n                if (depth === 0) {\n                    pipeFound = true;\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'status-var':\n                if (depth === 0 && pipeFound && str.charAt(token.start-1) === ' ') {\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'separator':\n                if (depth === 0 && pipeFound && str.charAt(token.start-1) === ' ') {\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'iterator':\n                if (depth === 0 && pipeFound && str.charAt(token.start-1) === ' ') {\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n            case 'array':\n                if (depth === 0 && pipeFound && str.charAt(token.start-1) === ' ') {\n                    finishPrevPart(token.start);\n                    prevToken = token;\n                }\n                break;\n        }\n    });\n\n    finishPrevPart(str.length);\n\n    if (inExpression) {\n        inExpression = parseExpression(inExpression, 'Invalid \"in\" expression');\n    }\n\n    if (separatorExpression) {\n        separatorExpression = parseExpression(separatorExpression, 'Invalid \"separator\" expression');\n    }\n\n    if (iteratorExpression) {\n        iteratorExpression = parseExpression(iteratorExpression, 'Invalid \"iterator\" expression');\n    }\n\n    if (fromExpression) {\n        fromExpression = createNumberExpression(fromExpression, 'Invalid \"from\" expression');\n    }\n\n    if (toExpression) {\n        toExpression = createNumberExpression(toExpression, 'Invalid \"to\" expression');\n    }\n\n    if (stepExpression) {\n        stepExpression = createNumberExpression(stepExpression, 'Invalid \"step\" expression');\n    }\n\n    if (varName != null) {\n        varName = buildIdentifier(varName, 'Invalid variable name');\n    }\n\n    if (nameVarName) {\n        nameVarName = buildIdentifier(nameVarName, 'Invalid name variable');\n    }\n\n    if (valueVarName) {\n        valueVarName = buildIdentifier(valueVarName, 'Invalid value variable');\n    }\n\n    if (statusVarName) {\n        statusVarName = parseExpression(statusVarName, 'Invalid status-var option');\n        if (statusVarName.type === 'Literal') {\n            statusVarName = compiler.builder.identifier(statusVarName.value);\n        } else  if (statusVarName.type !== 'Identifier') {\n            throwError('Invalid status-var option');\n        }\n    }\n\n    if (forInit) {\n        forInit = parseStatement(forInit, 'Invalid for loop init');\n    }\n\n    if (forTest) {\n        forTest = parseExpression(forTest, 'Invalid for loop test');\n    }\n\n    if (forUpdate) {\n        forUpdate = parseExpression(forUpdate, 'Invalid for loop update');\n    }\n\n    // No more tokens... now we need to sort out what happened\n    if (loopType === 'ForEach') {\n        return {\n            'loopType': loopType,\n            'varName': varName,\n            'in': inExpression,\n            'separator': separatorExpression,\n            'statusVarName': statusVarName,\n            'iterator': iteratorExpression,\n            'isArray': isArray\n        };\n    } else if (loopType === 'ForEachProp') {\n        return {\n            'loopType': loopType,\n            'nameVarName': nameVarName,\n            'valueVarName': valueVarName,\n            'in': inExpression,\n            'separator': separatorExpression,\n            'statusVarName': statusVarName\n        };\n    } else if (loopType === 'ForRange') {\n        return {\n            'loopType': loopType,\n            'varName': varName,\n            'from': fromExpression,\n            'to': toExpression,\n            'step': stepExpression\n        };\n    } else if (loopType === 'For') {\n        if (forTest == null) {\n            throwError('Invalid native for loop. Expected format: <init>; <test>; <update>');\n        }\n        return {\n            'loopType': loopType,\n            'init': forInit,\n            'test': forTest,\n            'update': forUpdate\n        };\n    } else {\n        throwError('Invalid for loop');\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/else-if-tag.js":"module.exports = function nodeFactory(el, context) {\n    var argument = el.argument;\n    var attributes = el.attributes;\n\n\n    if (!argument) {\n        context.addError('Invalid <else-if> tag. Argument is missing. Example; <if(foo === true)>');\n        return el;\n    }\n\n    if (attributes.length) {\n        context.addError('Invalid <else-if> tag. Attributes not allowed.');\n        return el;\n    }\n\n    var test;\n    try {\n        test = context.builder.parseExpression(argument);\n    } catch(e) {\n        test = context.builder.literalFalse();\n        context.addError('Invalid expression for else-if statement:\\n' + e.message);\n    }\n\n    var elseIfStatement = context.builder.elseIfStatement(test);\n    return elseIfStatement;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/else-tag.js":"'use strict';\n\nmodule.exports = function nodeFactory(el, context) {\n\n    var elseStatement = context.builder.elseStatement();\n\n    var argument = el.argument;\n    if (argument) {\n        context.addError(elseStatement, 'Invalid <else> tag. Argument is not allowed');\n    }\n\n    if (el.hasAttribute('if')) {\n        let ifAttr = el.getAttribute('if');\n        el.removeAttribute('if');\n\n        if (el.attributes.length) {\n            context.addError(elseStatement, 'Invalid <else if> tag. Only the \"if\" attribute is allowed.');\n            return el;\n        }\n\n        var testExpression = ifAttr.argument;\n        if (!testExpression) {\n            context.addError(elseStatement, 'Invalid <else if> tag. Invalid \"if\" attribute. Expected: <else if(<test>)>');\n            return el;\n        }\n        var elseIfStatement = context.builder.elseIfStatement(testExpression);\n        return elseIfStatement;\n    }\n\n    if (el.attributes.length) {\n        context.addError(elseStatement, 'Invalid <else> tag. Attributes not allowed.');\n        return el;\n    }\n\n    return elseStatement;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/for-tag.js":"var createLoopNode = require('./util/createLoopNode');\n\nmodule.exports = function codeGenerator(elNode, codegen) {\n    var argument = elNode.argument;\n    if (!argument) {\n        codegen.addError('Invalid <for> tag. Argument is missing. Example: <for(color in colors)>');\n        return elNode;\n    }\n\n    var builder = codegen.builder;\n\n    try {\n        var loopNode = createLoopNode(argument, elNode.body, builder);\n        return loopNode;\n    } catch(e) {\n        if (e.code === 'INVALID_FOR') {\n            codegen.addError(e.message);\n        } else {\n            throw e;\n        }\n    }\n\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/if-tag.js":"module.exports = function nodeFactory(elNode, context) {\n    var argument = elNode.argument;\n\n    if (!argument) {\n        context.addError('Invalid <if> tag. Argument is missing. Example; <if(foo === true)>');\n        return elNode;\n    }\n\n    var attributes = elNode.attributes;\n\n    if (attributes.length) {\n        context.addError('Invalid <if> tag. Attributes not allowed.');\n        return;\n    }\n\n    var test;\n\n    try {\n        test = context.builder.parseExpression(argument);\n    } catch(e) {\n        test = context.builder.literalFalse();\n        context.addError('Invalid expression for if statement:\\n' + e.message);\n    }\n\n    return context.builder.ifStatement(test);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/import-tag.js":"var isValidJavaScriptVarName = require('../../compiler/util/isValidJavaScriptVarName');\nvar parseImport = require('./util/parseImport');\n\nmodule.exports = function codeGenerator(el, codegen) {\n    var builder = codegen.builder;\n    var args = parseImport(el.tagString);\n    var vars = {};\n\n    args.forEach(arg => {\n        var varName = arg.name;\n\n        if (!isValidJavaScriptVarName(varName)) {\n            codegen.addError('Invalid JavaScript variable name: ' + varName, 'INVALID_VAR_NAME');\n            return;\n        }\n\n        if (arg.module) {\n            // needs to be require()'d\n            var result = builder.require(builder.literal(arg.value));\n\n            if (varName) {\n                // saves identifier\n                vars[varName] = codegen.addStaticVar(varName, result);\n            } else {\n                codegen.addStaticCode(result);\n            }\n        } else {\n            // ie: { bar } from \"./bar\"\n            var modIdentifier = vars[arg.value.object];\n            if (!modIdentifier) {\n                codegen.addError('Variable not found: ' + arg.value.object);\n                return;\n            }\n\n            codegen.addStaticVar(varName, builder.memberExpression(\n                modIdentifier,\n                builder.identifier(arg.value.property)\n            ));\n        }\n    });\n\n    return [];\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/util/parseImport.js":"\"use strict\";\n\nfunction getSpecifiers(importDeclaration) {\n    var match = /^(.+)\\bfrom\\s*((\"|')(.*?)(\"|'))$/.exec(importDeclaration);\n    if(!match) {\n        return { moduleSpecifier: importDeclaration.replace(/\\\"|\\'/g, \"\").trim() };\n    }\n\n    return {\n        importSpecifierSet: match[1].trim(),\n        moduleSpecifier: match[4].trim()\n    };\n}\n\nfunction getImportSpecifierGroups(importSpecifierSet) {\n    var defaultImport = importSpecifierSet;\n    var decomposedImports = /(?:,\\s*)?{(.*)}$/.exec(importSpecifierSet) || [];\n\n    if(decomposedImports.length) {\n        defaultImport = defaultImport.replace(decomposedImports[0], '');\n        decomposedImports = decomposedImports[1].split(',').map(specifier => specifier.trim());\n    }\n\n    return {\n        defaultImport: defaultImport,\n        decomposedImports: decomposedImports\n    };\n}\n\nfunction getVariableName(moduleSpecifier) {\n    var withoutPath = /([^\\/\\\\]+)$/.exec(moduleSpecifier)[1];\n    var withoutExtension = withoutPath.replace(/\\.[a-z0-9]+$/i, '');\n    return withoutExtension.replace(/[^a-z0-9]+([a-z])/gi, (_, p1) => p1.toUpperCase())+'_module';\n}\n\nfunction getNames(importSpecifier) {\n       var names = importSpecifier.split(/\\bas\\b/);\n\n       if (names.length == 1) {\n            names[1] = names[0];\n       }\n\n       return {\n            exported: names[0].trim(),\n            local: names[1].trim()\n       };\n}\n\nmodule.exports = function importToAssignments(tagString) {\n    var importDeclaration = tagString.replace(/^import/, '').trim();\n    var specifiers = getSpecifiers(importDeclaration);\n    var importSpecifierSet = specifiers.importSpecifierSet;\n    var moduleSpecifier = specifiers.moduleSpecifier;\n\n    if(!importSpecifierSet) {\n        return [ { module: true, value: moduleSpecifier } ];\n    }\n\n    var importGroups = getImportSpecifierGroups(importSpecifierSet);\n    var rootVariable = getNames(importGroups.defaultImport).local || getVariableName(moduleSpecifier);\n    var specifierList = importGroups.decomposedImports.map(getNames).map(names => {\n        return {\n            name: names.local,\n            value: {\n                object: rootVariable,\n                property: names.exported\n            }\n        };\n    });\n\n    return [{ name: rootVariable, value: moduleSpecifier, module: true }].concat(specifierList) ;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/include-html-tag-browser.js":"'use strict';\nmodule.exports = function codeGenerator(el, codegen) {\n    let argument = el.argument;\n    if (!argument) {\n        return;\n    }\n\n    let builder = codegen.builder;\n    let pathExpression = builder.parseExpression(argument);\n    if (pathExpression.type !== 'Literal' || typeof pathExpression.value !== 'string') {\n        codegen.addError('Argument to the <include-text> tag should be a string value: <include-text(\"./foo.txt\")/>');\n        return;\n    }\n\n    var path = pathExpression.value;\n    return builder.text(builder.literal('<include-html> cannot be compiled in the browser (path=\"' + path + '\")'));\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/include-html-tag.js":"'use strict';\n\nvar resolveFrom = require('resolve-from');\nvar fs = require('fs');\n\nmodule.exports = function codeGenerator(el, codegen) {\n    let argument = el.argument;\n    if (!argument) {\n        return;\n    }\n\n    let builder = codegen.builder;\n    let pathExpression = builder.parseExpression(argument);\n    if (pathExpression.type !== 'Literal' || typeof pathExpression.value !== 'string') {\n        codegen.addError('Argument to the <include-html> tag should be a string value: <include-html(\"./foo.txt\")/>');\n        return;\n    }\n\n    var path = pathExpression.value;\n    var dirname = codegen.context.dirname;\n    try {\n        path = resolveFrom(dirname, path);\n    } catch(e) {\n        codegen.addError('File not found: ' + path);\n        return;\n    }\n\n    var txt = fs.readFileSync(path, { encoding: 'utf8' });\n    return builder.text(builder.literal(txt), false /* do not escape since this is HTML*/);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/include-tag-transformer.js":"'use strict';\n\nmodule.exports = function(el, context) {\n    let builder = context.builder;\n\n    if (el.argument) {\n        let args = el.argument && builder.parseJavaScriptArgs(el.argument);\n        el.argument = null;\n\n        let target = args[0];\n        let arg = args[1];\n\n        if (target.type === 'Literal') {\n            target = context.importTemplate(target.value);\n        }\n\n        var includeProps = {\n            _target: target\n        };\n\n        if (arg) {\n            includeProps._arg = arg;\n        }\n\n        el.addProps(includeProps);\n    } else if (!el.hasProp('_target')) {\n        context.addError(el, 'The <include(...)> tag must have an argument: <include(\"./target.marko\")/> or <include(data.renderBody)/>');\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/include-text-tag-browser.js":"'use strict';\nmodule.exports = function codeGenerator(el, codegen) {\n    let argument = el.argument;\n    if (!argument) {\n        return;\n    }\n\n    let builder = codegen.builder;\n    let pathExpression = builder.parseExpression(argument);\n    if (pathExpression.type !== 'Literal' || typeof pathExpression.value !== 'string') {\n        codegen.addError('Argument to the <include-text> tag should be a string value: <include-text(\"./foo.txt\")/>');\n        return;\n    }\n\n    var path = pathExpression.value;\n    return builder.text(builder.literal('<include-text> cannot be compiled in the browser (path=\"' + path + '\")'));\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/include-text-tag.js":"'use strict';\n\nvar resolveFrom = require('resolve-from');\nvar fs = require('fs');\n\nmodule.exports = function codeGenerator(el, codegen) {\n    let argument = el.argument;\n    if (!argument) {\n        return;\n    }\n\n    let builder = codegen.builder;\n    let pathExpression = builder.parseExpression(argument);\n    if (pathExpression.type !== 'Literal' || typeof pathExpression.value !== 'string') {\n        codegen.addError('Argument to the <include-text> tag should be a string value: <include-text(\"./foo.txt\")/>');\n        return;\n    }\n\n    var path = pathExpression.value;\n    var dirname = codegen.context.dirname;\n    try {\n        path = resolveFrom(dirname, path);\n    } catch(e) {\n        codegen.addError('File not found: ' + path);\n        return;\n    }\n\n    var txt = fs.readFileSync(path, { encoding: 'utf8' });\n    return builder.text(builder.literal(txt));\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/invoke-tag.js":"module.exports = function codeGenerator(elNode, codegen) {\n    var context = codegen.context;\n    context.deprecate('The \"<invoke>\" tag is deprecated. Please use \"$ <js_code>\" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags');\n\n    var functionAttr = elNode.attributes[0];\n    if (!functionAttr) {\n        codegen.addError('Invalid <invoke> tag. Missing function attribute. Expected: <invoke console.log(\"Hello World\")');\n        return;\n    }\n\n    var arg = functionAttr.argument;\n\n    if (arg === undefined) {\n        codegen.addError('Invalid <invoke> tag. Missing function arguments. Expected: <invoke console.log(\"Hello World\")');\n        return;\n    }\n\n    var functionName = functionAttr.name;\n    var functionCallExpression = functionName + '(' + arg + ')';\n    return codegen.builder.parseExpression(functionCallExpression);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/macro-body-tag.js":"module.exports = function codeGenerator(elNode, codegen) {\n    var builder = codegen.builder;\n    \n    return builder.ifStatement(builder.identifier('renderBody'), [\n        builder.functionCall('renderBody', ['out'])\n    ]);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/macro-tag.js":"module.exports = function nodeFactory(elNode, context) {\n\n    var attributes = elNode.attributes;\n    var defAttr = attributes[0];\n\n    if(!defAttr || defAttr.value !== undefined) {\n        context.addError(elNode, 'The <macro> tag must contain a name as its first attribute, example: <macro greeting()>');\n        return elNode;\n    }\n\n    var body = elNode.body;\n    var macroName = defAttr.name;\n\n    if (context.isMacro(macroName)) {\n        context.addError(elNode, `<macro> tag with duplicate name of \"${macroName}\" found.`);\n        return elNode;\n    }\n\n    var argument = defAttr.argument;\n    var params;\n    if (argument) {\n        params = argument.split(/\\s*,\\s*/);\n    } else {\n        params = [];\n    }\n\n    var builder = context.builder;\n\n    context.registerMacro(macroName, params);\n\n    return builder.macro(macroName, params, body);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/marko-preserve-whitespace-tag.js":"module.exports = function codeGenerator(elNode, codegen) {\n    return elNode.body;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/static-tag.js":"module.exports = function functionCodeGenerator(el, codegen) {\n    if(el.parentNode.type !== 'TemplateRoot') {\n        codegen.addError('static is a static tag and can only be declared at the template root');\n    }\n\n    var code = el.tagString.replace(/^static\\s*/, '').trim();\n\n    if(code[0] === '{') {\n        var statements = code.slice(1, -1);\n        codegen.addStaticCode(codegen.builder.code(statements));\n    } else {\n        codegen.addStaticCode(codegen.builder.expression(code));\n    }\n\n    return null;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/unless-tag.js":"module.exports = function nodeFactory(elNode, context) {\n    var argument = elNode.argument;\n\n    if (!argument) {\n        context.addError('Invalid <unless> tag. Argument is missing. Example; <unless(foo === true)>');\n        return elNode;\n    }\n\n    var attributes = elNode.attributes;\n\n    if (attributes.length) {\n        context.addError('Invalid <unless> tag. Attributes not allowed.');\n        return;\n    }\n\n    var builder = context.builder;\n\n    var test;\n    try {\n        test = builder.parseExpression(argument);\n    } catch(e) {\n        test = builder.literalFalse();\n        context.addError('Invalid expression for unless statement:\\n' + e.message);\n    }\n\n    return context.builder.ifStatement(builder.negate(test));\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/var-tag.js":"var isValidJavaScriptVarName = require('../../compiler/util/isValidJavaScriptVarName');\n\nmodule.exports = function nodeFactory(el, context) {\n    context.deprecate('The \"<var>\" tag is deprecated. Please use \"$ <js_code>\" for JavaScript in the template. See: https://github.com/marko-js/marko/wiki/Deprecation:-var-assign-invoke-tags');\n\n    var vars;\n\n    try {\n        vars = context.builder.parseStatement(el.tagString);\n    } catch(e) {}\n\n    if (vars) {\n        return vars;\n    }\n\n    var builder = context.builder;\n    var hasError = false;\n\n    var declarations = el.attributes.map((attr) => {\n        var varName = attr.name;\n\n        if (!isValidJavaScriptVarName(varName)) {\n            context.addError('Invalid JavaScript variable name: ' + varName, 'INVALID_VAR_NAME');\n            hasError = true;\n            return;\n        }\n\n        var id = builder.identifier(varName);\n        var init = attr.value;\n\n        return {\n            id: id,\n            init\n        };\n    });\n\n    if (hasError) {\n        return el;\n    }\n\n    return context.builder.vars(declarations);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/core/while-tag.js":"module.exports = function codeGenerator(elNode, codegen) {\n    var argument = elNode.argument;\n    if (!argument) {\n        codegen.addError('Invalid <while> tag. Argument is missing. Example: <while(i < 4)>');\n        return elNode;\n    }\n\n    var builder = codegen.builder;\n\n    return builder.whileStatement(builder.parseExpression(argument), elNode.body);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/html/html-comment-tag.js":"'use strict';\nmodule.exports = function render(input, out) {\n    if (out.write) {\n        out.write('<!--');\n        if (input.renderBody) {\n            input.renderBody(out);\n        }\n        out.write('-->');\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/layout/placeholder-tag.js":"var removeDashes = require('../../compiler/util/removeDashes');\n\nmodule.exports = function render(oldNode, context) {\n    context.deprecate('The <layout-placeholder> tag is deprecated. Please use <include> instead. See: https://github.com/marko-js/marko/issues/452');\n\n    var name = oldNode.getAttributeValue('name');\n    var builder = context.builder;\n    var content;\n\n    if (name.type === 'Literal' && typeof name.value === 'string') {\n        content = builder.memberExpression('input', removeDashes(name.value));\n    } else {\n        content = builder.memberExpression('input', name, true);\n    }\n\n    var newNode = context.createNodeForEl('include');\n    newNode.addProps({ _target:content });\n\n    if (oldNode.firstChild) {\n        var ifNode = builder.ifStatement(content, [newNode]);\n        var elseNode = builder.elseStatement();\n        oldNode.moveChildrenTo(elseNode);\n\n        oldNode.replaceWith(ifNode);\n        ifNode.insertSiblingAfter(elseNode);\n    } else {\n        oldNode.replaceWith(newNode);\n    }\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/layout/put-tag.js":"module.exports = function render(oldNode, context) {\n    context.deprecate('The <layout-put> tag is deprecated. Please use <include> instead. See: https://github.com/marko-js/marko/issues/452');\n\n    var name = oldNode.getAttributeValue('into').value;\n    var value = oldNode.getAttributeValue('value');\n\n    oldNode.removeAttribute('into');\n    oldNode.removeAttribute('value');\n\n    var newNode = context.createNodeForEl('@'+name, oldNode.getAttributes());\n\n    if (value) {\n        newNode.appendChild(context.builder.text(value));\n    }\n\n    oldNode.moveChildrenTo(newNode);\n    oldNode.replaceWith(newNode);\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/taglibs/layout/use-tag.js":"'use strict';\n\nmodule.exports = function transform(oldNode, context) {\n    var argument = oldNode.argument;\n    if (!argument) {\n        context.addError('Invalid <layout-use> tag. Expected: <layout-use(template[, data]) ...>');\n        return;\n    }\n\n    context.deprecate('The <layout-use> tag is deprecated. Please use <include> instead. See: https://github.com/marko-js/marko/issues/452');\n\n    var newNode = context.createNodeForEl('include', oldNode.getAttributes(), argument);\n    oldNode.moveChildrenTo(newNode);\n\n    oldNode.replaceWith(newNode);\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/helpers/bindComponent.js":"var createRendererFunc = require('../../renderer');\n\nmodule.exports = function(componentProps) {\n    var renderer = createRendererFunc(\n        function(data, out, component, state) {\n            data.$renderBody(out, component, state);\n        },\n        componentProps,\n        null);\n\n    return function bindComponent(renderBody, out) {\n        renderer({\n            $renderBody: renderBody\n        }, out);\n    };\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/helpers/componentArgs.js":"var componentArgsHelper = module.exports = function componentArgsHelper(\n        out,\n        componentArgs) {\n\n    out.data.$w = componentArgs;\n};\n\ncomponentArgsHelper.cleanup = function(out) {\n    delete out.data.$w;\n};","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/helpers/getCurrentComponent.js":"/**\n * Helper method to return the ComponentDef for the current component being rendered.\n * This is, it returns the component at the top of the component stack.\n * @param  {AsyncWriter} out The current rendering context that holds info about rendered components.\n * @return {ComponentDef} The ComponentDef instance\n */\nmodule.exports = function getCurrentComponent(out) {\n    var componentsContext = out.data.components;\n    var componentStack;\n    var len;\n\n    if (!componentsContext || (len = (componentStack = componentsContext.$__componentStack).length) < 2) {\n        throw Error('No component found');\n    }\n\n    return componentStack[len - 1];\n};\n","/home/travis/build/npmtest/node-npmtest-marko/node_modules/marko/components/taglib/helpers/renderComponent.js":"module.exports = function renderCompontent(tagRenderer, input, out, componentArgs) {\n    out.$c = componentArgs;\n    tagRenderer(input, out);\n    out.$c = null;\n};\n"}